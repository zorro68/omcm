! ******************************************************************
! ***  CALCULO DE LAS INTEGRALES POR LOS METODOS CUASIMONTECARLO
! ******************************************************************

! ------------------------------------------------------------------
! --- SUBRUTINA QUE CALCULA LAS INTEGRALES POR MONTECARLO
! ------------------------------------------------------------------
    SUBROUTINE INTCMC_GEN(MAT,NUMINT)
	USE ESTRUCT
	USE GLOBAL
    IMPLICIT NONE
	INTEGER*4 MAT,NUMINT
	INTEGER*4 I
	
	
!-----CODIFICA LAS FUNCIONES DE BASE PARA EL CALCULO
	DO I=1,N
		CFUNC(I).NUM=I
		CFUNC(I).F=FB(I).NOMBRE
		CALL CMAT(CFUNC(I).F,CFUNC(I))
	END DO
	

	IF(UNASOLA==1)THEN
		CALL CALCULA_UNA_GEN
    ELSE
		CALL CALCULA_TODAS_GEN(MAT,NUMINT)
	ENDIF

	RETURN
    END

! ------------------------------------------------------
!--------CALCULO DE UNA SOLA INTEGRAL-------------------
! ------------------------------------------------------
	SUBROUTINE CALCULA_UNA_GEN
	USE ESTRUCT
	USE GLOBAL
    IMPLICIT NONE
	REAL*16 VAL,VAL1,ER,CNOR_GEN
	CHARACTER*ILONG INTTOSTR,REALTOSTR,CADIDIOMA,LEERVALOR,CAD

	CADIDIOMA=LEERVALOR('idioma.lng',IDIOMA,'1210')
	CAD=' '
	CALL MENSAJES(CADIDIOMA,CAD,1.Q0)
	
	IF(SN1/=0)THEN
		FB(SN1).ANOR=CNOR_GEN(SN1)
	ENDIF
	IF (SN2/=0.AND.SN2/=SN1)THEN
		FB(SN2).ANOR=CNOR_GEN(SN2)
	ENDIF
	IF (SN3/=0.AND.(SN3/=SN2.AND.SN3/=SN1))THEN
		FB(SN3).ANOR=CNOR_GEN(SN3)
	ENDIF
	IF (SN4/=0.AND.(SN4/=SN3.AND.SN4/=SN2.AND.SN4/=SN1))THEN
		FB(SN4).ANOR=CNOR_GEN(SN4)
    ENDIF
	
	CADIDIOMA=LEERVALOR('idioma.lng',IDIOMA,'1211')
	IF(CLASINT=='J'.OR.CLASINT=='j')THEN
		WRITE(CAD,'(A1,2I2,A2,2I2,A1)')'(',SN1,SN2,' |',SN3,SN4,')'
	ELSEIF(CLASINT=='S'.OR.CLASINT=='s')THEN
		WRITE(CAD,'(A1,I2,A2,I2,A1)')'<',SN1,' |',SN2,'>'
	ELSE
		WRITE(CAD,'(A1,I2,A2,A,A1,I2,A1)')'<',SN1,' |',CLASINT,'|',SN2,'>'
	ENDIF	
	CALL MENSAJES(CADIDIOMA,CAD,50.Q0)
	
    CALL CALCULA(SN1,SN2,SN3,SN4,INTEGRAL,ERINTS)
	!CALL ESCINT(0,0)

	CALL GUARDAVALOR(DIR.INT,'INTEGRALES','TipoInt',TRIM(CLASINT))
	CALL GUARDAVALOR(DIR.INT,'INTEGRALES','Indice1',INTTOSTR(SN1))
	CALL GUARDAVALOR(DIR.INT,'INTEGRALES','Indice2',INTTOSTR(SN2))
	CALL GUARDAVALOR(DIR.INT,'INTEGRALES','Indice3',INTTOSTR(SN3))
	CALL GUARDAVALOR(DIR.INT,'INTEGRALES','Indice4',INTTOSTR(SN4))
	CALL GUARDAVALOR(DIR.INT,'INTEGRALES','Integral',REALTOSTR(INTEGRAL))
	CALL GUARDAVALOR(DIR.INT,'INTEGRALES','Error',REALTOSTR(ERINTS))

	END 

! ------------------------------------------------------
! --------- SUBPROGRAMA PARA NORMALIZAR :
! ------------------------------------------------------
    REAL*16 FUNCTION CNOR_GEN(NB)
	USE ESTRUCT
	USE GLOBAL
	INTEGER*4 NB
    REAL*16 SS,ER
	CHARACTER*1 TIPO

	TIPO=CLASINT
	CLASINT='S'

    IF(CLASMON=='HAS')CALL MONOHAS_GEN(NB,NB,SS,ER)

    IF(CLASMON=='HAL')CALL MONOHAL_GEN(NB,NB,SS,ER) 

    IF(CLASMON=='HAM')CALL MONOHAM_GEN(NB,NB,SS,ER) 

    IF(CLASMON=='RND')CALL MONORND_GEN(NB,NB,SS,ER)
    
    CNOR_GEN=1.Q0/QSQRT(SS)
	CLASINT=TIPO

    RETURN
    END

! ---------------------------------------------------------------------
! --- SUBRUTINA QUE CALCULA LAS INTEGRALES POR MONTECARLO
! --- (TIENE EN CUENTA LAS CTES DE NORMALIZACION ANOR(I))
! ---------------------------------------------------------------------
	SUBROUTINE CALCULA_GEN(NB1,NB2,NB3,NB4,VALINT,ERINT)
    USE GLOBAL
	USE ESTRUCT
	IMPLICIT REAL*16(A-H,O-Z)
	INTEGER*4 NB1,NB2,NB3,NB4
	
    
! ----------- CALCULO DE LAS INTEGRALES : -------------------------
	IF(CLASINT/='J')THEN
! ---  CALCULO HASELGROVE:       
		IF(CLASMON=='HAS')CALL MONOHAS_GEN(NB1,NB2,VAL,ER)
		
! ---  CALCULO HALTON:
		IF(CLASMON=='HAL')CALL MONOHAL_GEN(NB1,NB2,VAL,ER)
	   
! ---  CALCULO HAMMERSLEY:
		IF(CLASMON=='HAM')THEN
			CALL MONOHAM_GEN(NB1,NB2,VAL,ER)
			NMC=NMC/10
			CALL MONOHAM_GEN(NB1,NB2,VAL1,ER)
			NMC=NMC*10
			ER= 0.1Q0*QABS(VAL-VAL1)
		ENDIF

! ---  CALCULO MONTECARLO ORDINARIO:
		IF(CLASMON=='RND')CALL MONORND_GEN(NB1,NB2,VAL,ER)

		VALINT=VAL*FB(NB1).ANOR*FB(NB2).ANOR
		ERINT=ER*FB(NB1).ANOR*FB(NB2).ANOR
	ENDIF

	IF(CLASINT=='J')THEN
! --- CALCULO HASELGROVE:
		IF(CLASMON=='HAS')CALL BIELHAS_GEN(NB1,NB2,NB3,NB4,VAL,ER)

! ---  CALCULO HALTON:
		IF(CLASMON=='HAL')CALL BIELHAL_GEN(NB1,NB2,NB3,NB4,VAL,ER)

! ---  CALCULO HAMMERSLEY Y ESTIMACION DEL ERROR:
		IF(CLASMON=='HAM')THEN
			CALL BIELHAM_GEN(NB1,NB2,NB3,NB4,VAL,ER)
			NMC=NMC/10
			CALL BIELHAM_GEN(NB1,NB2,NB3,NB4,VAL1,ER)
			NMC=NMC*10
			ER=0.1Q0*QABS(VAL-VAL1)
		ENDIF

! --- CALCULO MONTECARLO ORDINARIO:
        IF(CLASMON=='RND')CALL BIELRND_GEN(NB1,NB2,NB3,NB4,VAL,ER)

        VALINT=VAL*FB(NB1).ANOR*FB(NB2).ANOR*FB(NB3).ANOR*FB(NB4).ANOR
		ERINT=ER*FB(NB1).ANOR*FB(NB2).ANOR*FB(NB3).ANOR*FB(NB4).ANOR
    ENDIF

    RETURN
    END

! ---------------------------------------------------------------------
! --- SUBRUTINA QUE CALCULA TODAS LAS INTEGRALES POR MONTECARLO
! ---------------------------------------------------------------------
	SUBROUTINE CALCULA_TODAS_GEN(MAT,NUMINT)
	USE ESTRUCT
	USE GLOBAL
    IMPLICIT NONE
	INTEGER*4 MAT,NUMINT,I
	REAL*16 CNOR_GEN
	CHARACTER*ILONG CADIDIOMA,LEERVALOR,CAD

    IF(MAT==0)THEN
		CADIDIOMA=LEERVALOR('idioma.lng',IDIOMA,'1210')		
		CAD=' '
		CALL MENSAJES(CADIDIOMA,CAD,1.Q0)

		DO I=1,N
			FB(I).ANOR=CNOR_GEN(I)
        END DO
		CALL INTCMC_MONO_GEN(MAT)
    ELSEIF (MAT>0) THEN
		CALL LEEINT(MAT,NUMINT)
		CALL INTCMC_MONO_GEN(MAT)
    END IF

    IF(NEL>1.AND.MAT<=4)THEN
        CALL INTCMC_BI_GEN(MAT,NUMINT)
	ENDIF

	END

! ------------------------------------------------------------
! --------- SUBPROGRAMA PARA CALCULAR   S(p,q), H(p,q), X(p,q) 
! --------- Y(p,q) y Z(p,q) 
! ------------------------------------------------------------
	SUBROUTINE INTCMC_MONO_GEN(MAT)
	USE ESTRUCT
	USE GLOBAL
    IMPLICIT NONE
	CHARACTER*ILONG LEERVALOR,CADIDIOMA,CAD
	INTEGER*4 MAT,I,J,INPQ_F
    REAL*16 TIEN,TMONO,TBIEL,TTOTAL,DENS,SS,ES,PCTO,DENT,TT,ET,DENV,VV,EV,DENH,HH,EH,DENX,XX,EX,DENY,YY,EY,DENZ,ZZ,EZ
    	
    TIEN=0.Q0
	TMONO=DBLE(7.Q0*N*(N+1)) !SON 7 TIPOS DE INTEGRALES MONO: S,T,V,H,X,Y,Z
	TBIEL=0.Q0
	IF (NEL>1)TBIEL=2.7Q0*DBLE(N_INT_BI) !CADA INTEGRAL BI TIENE UN PESO DE 2.7 VECES 2 MONO
	TTOTAL=TMONO+TBIEL
    
	CADIDIOMA=LEERVALOR('idioma.lng',IDIOMA,'1212')		
	
	IF(MAT<1)THEN
		!CALL ESCINT(0,0)
	ENDIF
	
	IF(MAT<2)THEN
		ESMED=0.Q0
		ESMAX=0.Q0
		DENS=0.Q0  
		CLASINT='S'
		DO I=1,N
			DO J=I,N
				IF (I==J)THEN
					SS=1.0Q0
					ES=0.Q0
				ELSE
					CALL CALCULA_GEN(I,J,0,0,SS,ES)
				ENDIF
				S(INPQ_F(I,J))=SS
				IF(ES>ESMAX)ESMAX=ES
				DENS=DENS+1.Q0
				ESMED=ESMED + (ES-ESMED)/DENS
				TIEN=TIEN+2.0Q0
				PCTO=1.0Q2*TIEN/TTOTAL
				WRITE(CAD,'(A1,I2,A2,I2,A1,A,F5.1,A)')'<',I,' |',J,'>',' (',PCTO,'%)'
				CALL MENSAJES(CADIDIOMA,CAD,PCTO)
			ENDDO
		ENDDO
		!MAT=1
		!CALL ESCINT(1,0)
	ENDIF
		
	IF(MAT<3)THEN
		ETMED=0.Q0
		ETMAX=0.Q0
		DENT=DFLOAT(N)
		CLASINT='T'
		DO I=1,N
			DO J=I,N
				CALL CALCULA_GEN(I,J,0,0,TT,ET)
				T(INPQ_F(I,J))=TT
				IF(ET>ETMAX)ETMAX=ET
				DENT=DENT+1.Q0
				ETMED=ETMED + (ET-ETMED)/DENT
				TIEN=TIEN+2.0Q0
				PCTO=1.0Q2*TIEN/TTOTAL
				WRITE(CAD,'(A1,I2,A2,A,A1,I2,A1,A,F5.1,A)')'<',I,' |',CLASINT,'|',J,'>',' (',PCTO,'%)'
				CALL MENSAJES(CADIDIOMA,CAD,PCTO)
			ENDDO
		ENDDO
		!MAT=2
		!CALL ESCINT(MAT,NUMINT)
		  
		EVMED=0.Q0
		EVMAX=0.Q0
		DENV=DFLOAT(N)
		CLASINT='V'
		DO I=1,N
			DO J=I,N
				CALL CALCULA_GEN(I,J,0,0,VV,EV)
				V(INPQ_F(I,J))=VV
				DENV=DENV+1.Q0
				EVMED=EVMED + (EV-EVMED)/DENV
				TIEN=TIEN+2.0Q0
				PCTO=1.0Q2*TIEN/TTOTAL
				WRITE(CAD,'(A1,I2,A2,A,A1,I2,A1,A,F5.1,A)')'<',I,' |',CLASINT,'|',J,'>',' (',PCTO,'%)'
				CALL MENSAJES(CADIDIOMA,CAD,PCTO)
			ENDDO
		ENDDO
		!MAT=2
		!CALL ESCINT(MAT,NUMINT)

		EHMED=0.Q0
		EHMAX=0.Q0
		DENH=DFLOAT(N)
		CLASINT='H'
		DO I=1,N
			DO J=I,N
				!CALL CALCULA(I,J,0,0,HH,EH)
				HH=T(INPQ_F(I,J))+V(INPQ_F(I,J))
				EH=ET+EV
				H(INPQ_F(I,J))=HH
				IF(EH>EHMAX)EHMAX=EH
				DENH=DENH+1.Q0
				EHMED=EHMED + (EH-EHMED)/DENH
				TIEN=TIEN+2.0Q0
				PCTO=1.0Q2*TIEN/TTOTAL
				WRITE(CAD,'(A1,I2,A2,A,A1,I2,A1,A,F5.1,A)')'<',I,' |',CLASINT,'|',J,'>',' (',PCTO,'%)'
				CALL MENSAJES(CADIDIOMA,CAD,PCTO)
			ENDDO
		ENDDO
		!MAT=2
		!CALL ESCINT(2,0)
	ENDIF
	
	IF(MAT<4)THEN
		NN.NX=1
		NN.NY=0
		NN.NZ=0
		CLASINT='X'
		EXMED=0.Q0
		EXMAX=0.Q0
		DENX=DFLOAT(N)
		CLASINT='X'
		DO I=1,N
			DO J=I,N
				CALL CALCULA_GEN(I,J,0,0,XX,EX)
				!IF(ISNAN(XX))XX=0.Q0;EX=0.Q0 !PARA EVITAR QUE SE CUELGUE
				XMAT(INPQ_F(I,J))=XX
				IF(EX>EXMAX)EXMAX=EX
				DENX=DENX+1.Q0
				EXMED=EXMED + (EX-EXMED)/DENX
				IF(QABS(POT(1))>CERO)HH= HH - POT(1)*XX
				TIEN=TIEN+2.0Q0
				PCTO=1.0Q2*TIEN/TTOTAL
				WRITE(CAD,'(A1,I2,A2,A,A1,I2,A1,A,F5.1,A)')'<',I,' |',CLASINT,'|',J,'>',' (',PCTO,'%)'
				CALL MENSAJES(CADIDIOMA,CAD,PCTO)
			ENDDO
		ENDDO
		!MAT=3
		!CALL ESCINT(MAT,NUMINT)
			
		NN.NX=0
		NN.NY=1
		NN.NZ=0
		CLASINT='Y'
		EYMED=0.Q0
		EYMAX=0.Q0
		DENY=DFLOAT(N)
		CLASINT='Y'
		DO I=1,N
			DO J=I,N
				CALL CALCULA_GEN(I,J,0,0,YY,EY)
				!IF(ISNAN(YY))YY=0.Q0;EY=0.Q0 !PARA EVITAR QUE SE CUELGUE
				YMAT(INPQ_F(I,J))=YY
				IF(EY>EYMAX)EYMAX=EY
				DENY=DENY+1.Q0
				EYMED=EYMED + (EY-EYMED)/DENY
				IF(QABS(POT(2))>CERO)HH= HH - POT(2)*YY
				TIEN=TIEN+2.0Q0
				PCTO=1.0Q2*TIEN/TTOTAL
				WRITE(CAD,'(A1,I2,A2,A,A1,I2,A1,A,F5.1,A)')'<',I,' |',CLASINT,'|',J,'>',' (',PCTO,'%)'
				CALL MENSAJES(CADIDIOMA,CAD,PCTO)
			ENDDO
		ENDDO
		!MAT=3
		!CALL ESCINT(MAT,NUMINT)

		NN.NX=0
		NN.NY=0
		NN.NZ=1
		CLASINT='Z'
		EZMED=0.Q0
		EZMAX=0.Q0
		DENZ=DFLOAT(N)
		CLASINT='Z'
		DO I=1,N
			DO J=I,N
				CALL CALCULA_GEN(I,J,0,0,ZZ,EZ)
				!IF(ISNAN(ZZ))ZZ=0.Q0;EZ=0.Q0 !PARA EVITAR QUE SE CUELGUE
				ZMAT(INPQ_F(I,J))=ZZ
				IF(EZ>EZMAX)EZMAX=EZ
				DENZ=DENZ+1.Q0
				EZMED=EZMED + (EZ-EZMED)/DENZ
				IF(QABS(POT(3))>CERO)HH= HH - POT(3)*ZZ
				TIEN=TIEN+2.0Q0
				PCTO=1.0Q2*TIEN/TTOTAL
				WRITE(CAD,'(A1,I2,A2,A,A1,I2,A1,A,F5.1,A)')'<',I,' |',CLASINT,'|',J,'>',' (',PCTO,'%)'
				CALL MENSAJES(CADIDIOMA,CAD,PCTO)
			ENDDO
		ENDDO
		MAT=3
		!CALL ESCINT(MAT,0)
	ENDIF
				
    RETURN
    END

! ---------------------------------------------------
! --------- SUBROGRAMA PARA CALCULAR (p,q|r,s) 
! --------- POR   M O N T E C A R L O.
! --------- (DESDE LA "NUMINT+1" HASTA LA "NN")
! ---------------------------------------------------
	SUBROUTINE INTCMC_BI_GEN(MAT,NUMINT)
	USE GLOBAL
	USE ESTRUCT
    IMPLICIT NONE
	INTEGER*4 NUMINT,MAT,PASO,CONTPASO
	CHARACTER*ILONG LEERVALOR,CADIDIOMA,CAD
    REAL*16 DEN,TMONO,TBIEL,TTOTAL,TIEN,PCTO,RINT,ERINT
    INTEGER*4 K,NPQ,NQ,NP,NRS,NS,NR
	
	CADIDIOMA=LEERVALOR('idioma.lng',IDIOMA,'1213')		
    
	ERMED=0.Q0
    ERMAX=0.Q0
    DEN=0.0Q0
    TMONO=DBLE(7.Q0*N*(N+1)) !SON 7 TIPOS DE INTEGRALES MONO: S,T,V,H,X,Y,Z
    TBIEL=0.Q0
	IF (NEL>1)TBIEL=2.7Q0*DBLE(N_INT_BI)
    TTOTAL=TMONO+TBIEL
    TIEN=TMONO
    NPQ=0
    K=0
    MAT=4
	PASO=N_INT_BI/N
	CONTPASO=0

    DO NQ=1,N
		DO NP=1,NQ
			NPQ=NPQ+1
			NRS=0
			DO NS=1,N
				DO NR=1,NS
					NRS=NRS+1
					IF(NRS>NPQ)GOTO 10
					K=K+1
					IF(K>NUMINT)THEN
						TIEN=TIEN+2.7Q0
						PCTO=1.Q02*TIEN/TTOTAL
						WRITE(CAD,'(A1,2I2,A2,2I2,A1,A,F5.1,A)')'(',NP,NQ,' |',NR,NS,')',' (',PCTO,'%)'
						CALL MENSAJES(CADIDIOMA,CAD,PCTO)

						CLASINT='J'
						CALL CALCULA_GEN(NP,NQ,NR,NS,RINT,ERINT)
						IF(ERINT>ERMAX)ERMAX=ERINT
						DEN=DEN+1.0Q0
						ERMED=ERMED+(ERINT-ERMED)/DEN
						R(K)=RINT

						NUMINT=K
						CONTPASO=CONTPASO+1
						IF(CONTPASO>PASO)THEN
							CONTPASO=0
							!CALL ESCINT(MAT,NUMINT)
						ENDIF
					ENDIF
				ENDDO
			ENDDO
10		CONTINUE
		END DO
	END DO

	!IF(CONTPASO>0)CALL ESCINT(MAT,NUMINT)

	RETURN 
    END
    
!*********************************************************************
!****************** METODO MONTECARLO ********************************
!*********************************************************************

! --------------------------------------------------------------------
! ----- Cálculo por MONTECARLO de integrales monoelectronicas <p|A|q>
! ----- con  A= 1, T, V, o H=T+V  y FUNCIONES DE BASE SIN NORMALIZAR.
! ----- (NUMEROS PSEUDOALEATORIOS CONGRUENCIALES)
! ----- INCLUYE ESTIMACION DEL ERROR ( BASTANTE GROSERA)
! --------------------------------------------------------------------
	SUBROUTINE MONORND_GEN(NB1,NB2,SSM,ER)
    USE GLOBAL
	USE ESTRUCT
	IMPLICIT NONE
	TYPE(RCSTFI)::POLAR
	TYPE(XYZ)::P,P1,P2,P12
	TYPE(DAT_METODO)::MET
	TYPE(XY)::PPOLIGR(1:INCREMENT+1),PPOLIGT(1:INCREMENT+1),PPOLIGF(1:INCREMENT+1)
	REAL*16 STRPOLIGR(INCREMENT),STRPOLIGT(INCREMENT),STRPOLIGF(INCREMENT)
	REAL*16 SSM,ER,VALPRE,DENOM,YFUNC_GEN,Y
	REAL*16 ARPR,ARPT,ARPF,AT,W,WR,WT,WF,GR,GGR,GT,GF
	REAL*16 SPAR(10)
	INTEGER*4 NB1,NB2,N10,IISEM,IMAL,I,J,I10,NULA
	REAL*16 DISTCENTROS,CONSTNORM,Y0,Y1,Y2,Y3

	P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z

! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		P12.X=P1.X
		P12.Y=P1.Y
		P12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		P12.X=(P1.X+P2.X)/2.Q0
		P12.Y=(P1.Y+P2.Y)/2.Q0
		P12.Z=(P1.Z+P2.Z)/2.Q0
	ENDIF

! -- CALCULO DE LA FUNCIÓN DE PESO
	CALL FPESO_GEN(NB1,NB2,P1,P2,P12,ARPR,AT,ARPT,ARPF,PPOLIGR,PPOLIGT,PPOLIGF,STRPOLIGR,STRPOLIGT,STRPOLIGF)

! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS,Y0,Y1,Y2,Y3,EXP0,EXP1)

! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSM=0.Q0
	
! --ESTABLECE SI LA INTEGRAL SE PUEDE CONSIDERAR NULA (AHORRA TIEMPO)
	!CALL PREPARA(NB1,NB2,P1,P2,P12,VALPRE,'RND',ARPR,AT,PPOLIGR,STRPOLIGR)
	!IF(VALPRE<=CERO)THEN
	!	ER=0.Q0
	!	RETURN
	!ENDIF

! ---------CALCULO MONTE CARLO: --------------------------------
    IISEM=ISEM
	
    N10=NMC/10
	IMAL=0
	DENOM=0.Q0

	OUTER: DO I10=1,10
		INNER: DO I=1,N10
			IF (NPOLIG==0)THEN
				GGR=RAN(IISEM)
				IF(GGR<=0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GR=-QLOG(Y0-GGR*Y1)/EXP0
				W=EXP(-EXP0*GR)
				CONSTNORM=Y1/EXP0
				GT=RAN(IISEM)
	       		IF(GT<=0.OR.GT>1.Q0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GF=RAN(IISEM)
				POLAR.R=GR
				POLAR.CST=1.Q0-2.*GT
				POLAR.FI=2.Q0*PI*GF
			ELSE IF (NPOLIG==1)THEN
				CALL INV_FDEN_R(IMAL,ARPR,AT,GR,WR,MET,PPOLIGR,STRPOLIGR,CLASMON,IISEM)
				GT=(IISEM)
				IF(GT<=0.OR.GT>1.Q0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GF=RAN(IISEM)
				W=WR
				CONSTNORM=AT
				POLAR.R=GR
				POLAR.CST=1.Q0-2.*GT
				POLAR.FI=2.Q0*PI*GF
			ELSE IF (NPOLIG==2)THEN
				CALL INV_FDEN_R(IMAL,ARPR,AT,GR,WR,MET,PPOLIGR,STRPOLIGR,CLASMON,IISEM)
				CALL INV_FDEN_ANG(IMAL,ARPT,GT,WT,MET,PPOLIGT,STRPOLIGT,CLASMON,IISEM)
				GF=RAN(IISEM)
				W=WR*WT
				CONSTNORM=AT*ARPT
				POLAR.R=GR
				POLAR.CST=GT
				POLAR.FI=2.Q0*PI*GF
			ELSE IF (NPOLIG==3)THEN
				CALL INV_FDEN_R(IMAL,ARPR,AT,GR,WR,MET,PPOLIGR,STRPOLIGR,CLASMON,IISEM)
				CALL INV_FDEN_ANG(IMAL,ARPT,GT,WT,MET,PPOLIGT,STRPOLIGT,CLASMON,IISEM)
				CALL INV_FDEN_ANG(IMAL,ARPF,GF,WF,MET,PPOLIGF,STRPOLIGF,CLASMON,IISEM)
				W=WR*WT*WF
				CONSTNORM=AT*ARPT*ARPF
				POLAR.R=GR
				POLAR.CST=GT
				POLAR.FI=GF
			END IF			

			IF (DISTCENTROS==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				CALL POLAR2CAR(POLAR,P)	!PASO DE POLARES A CARTESIANAS
					
				P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
				P.Y=P.Y+P12.Y
				P.Z=P.Z+P12.Z

				Y=YFUNC_GEN(NB1,NB2,P,P1,P2)*POLAR.R**2/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				IF (EXP1/=0.Q0)THEN
					POLAR.CST=-QLOG(Y2-GT*Y3)/EXP1
					CONSTNORM=0.5Q0*CONSTNORM*Y3/EXP1 !EL 0.5 ES PORQUE DESPUES MULTIPLICAMOS POR 4PI Y EN ESTE CASO ES 2PI
					W=W*EXP(-EXP1*POLAR.CST)
				ENDIF
				CALL SPHER2CAR(POLAR,DISTCENTROS,P)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
				P.Y=P.Y+P12.Y
				P.Z=P.Z+P12.Z
				
				Y=YFUNC_GEN(NB1,NB2,P,P1,P2)*(POLAR.R**2-POLAR.CST**2)*(DISTCENTROS/2.Q0)**3/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ENDIF
						
			DENOM=DENOM+1.Q0
			SSM= SSM + (Y-SSM)/DENOM
        END DO INNER
		SPAR(I10)=SSM
	END DO OUTER

    ER=0.Q0
    DO J=1,2
		ER= ER + QABS(SPAR(J)-SSM)*DFLOAT(J)/1.0Q01
	END DO
    ER=ER/2.0Q0

	SSM=4.Q0*PI*SSM*CONSTNORM  !4*pi*constnorm es al cte normalización de la función densidad
    ER=4.Q0*PI*ER*CONSTNORM

	RETURN
    END

    ! --------------------------------------------------------------------
!     PREPARACION DEL CALCULO DE UNA INTEGRAL MONOELECTRONICA:
!     DETERMINA SI ES NULA
! --------------------------------------------------------------------
	SUBROUTINE PREPARA(NB1,NB2,P1,P2,P12,VALPRE,CMON,ARP,AT,PPOLIG,STRPOLIG)
	USE GLOBAL   !,ONLY: INCREMENT,PI,RECORT
	USE ESTRUCT  !, ONLY: RCSTFI,XYZ,DAT_METODO,XY
    IMPLICIT NONE
    TYPE(RCSTFI)::POLAR
	TYPE(XYZ)::P,P1,P2,P12
	TYPE(DAT_METODO)::MET
	TYPE(XY)::PPOLIG(1:INCREMENT+1)
	REAL*16 STRPOLIG(INCREMENT)
	REAL*16 YFUNC_GEN,PUNTO,XMENOS,YMENOS,ZMENOS
	REAL*16 VALPRE,VALPREX,VALPREY,VALPREZ,QMIN1
	REAL*16 ARP,AT,GGR,GR,GT,GF,W,DISTCENTROS,Y0,Y1,Y2,Y3
	INTEGER*4 I,NP,IMAL,JSEM
	INTEGER*4 NB1,NB2
	CHARACTER*3 CMON
    
	NP=10
    VALPREX=0.Q0
    VALPREY=0.Q0
    VALPREZ=0.Q0
	JSEM=1
	
	DISTCENTROS=0.Q0 !ESTO LO HACE SIEMPRE EN POLARES
	CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS,Y0,Y1,Y2,Y3,EXP0,EXP1)
    		
	DO I=1,NP
		CALL INV_FDEN_R(IMAL,ARP,AT,GR,W,MET,PPOLIG,STRPOLIG,CMON,JSEM)
		GT=RAN(JSEM)
		GF=RAN(JSEM)
		
		! ---  PASO A CARTESIANAS
		POLAR.R=GR
		POLAR.CST=1.Q0-2.*GT
		POLAR.FI=2.Q0*PI*GF
		CALL POLAR2CAR(POLAR,P)

		P.X=P.X+P12.X
		P.Y=P.Y+P12.Y
		P.Z=P.Z+P12.Z

		PUNTO=YFUNC_GEN(NB1,NB2,P,P1,P2)*POLAR.R**2/W
		
		P.X=-P.X
		XMENOS=YFUNC_GEN(NB1,NB2,P,P1,P2)*POLAR.R**2/W
		VALPREX=VALPREX+(PUNTO+XMENOS)**2
		
		P.X=-P.X
		P.Y=-P.Y
		YMENOS=YFUNC_GEN(NB1,NB2,P,P1,P2)*POLAR.R**2/W
		VALPREY=VALPREY+(PUNTO+YMENOS)**2

		P.Y=-P.Y
		P.Z=-P.Z
		ZMENOS=YFUNC_GEN(NB1,NB2,P,P1,P2)*POLAR.R**2/W
		VALPREZ=VALPREZ+(PUNTO+ZMENOS)**2
	END DO

	VALPRE=QMIN1(VALPREX,VALPREY,VALPREZ)
	
	RETURN
    END
    
!--------------------------------------------------------------------
!  SUBROUTINE QUE CALCULA EL PRODUCTO F1*OP(F2)
!--------------------------------------------------------------------
    REAL*16 FUNCTION YFUNC_GEN(N1,N2,P,P1,P2)
    USE ESTRUCT
	USE GLOBAL
    IMPLICIT NONE
	INTEGER*4 N1,N2
    REAL*16 V1,V2,FBASE_GEN,TBASE_GEN,VBASE_GEN,HBASE_GEN,XBASE_GEN
	TYPE(RCSTFI)::POLAR1,POLAR2
	TYPE(XYZ)::P,PB1,PB2,P1,P2

! ---  CALCULO DE LAS COORDENADAS DEL ELECTRON
! ---  RESPECTO AL CENTRO DE  CADA FUNCION DE BASE:
    PB1.X=P.X-P1.X
    PB1.Y=P.Y-P1.Y
    PB1.Z=P.Z-P1.Z
    PB2.X=P.X-P2.X
    PB2.Y=P.Y-P2.Y
    PB2.Z=P.Z-P2.Z

! ---  PASO A POLARES:
    CALL CAR2POLAR(PB1,POLAR1)
	CALL CAR2POLAR(PB2,POLAR2)
		
! --- CALCULO DEL PRODUCTO P(1)*Q(1) (FALTA MULTIPLICAR POR EL ELEMENTO DE VOLUMEN/W)
	!V0=POLAR.R**2/W
	V1=FBASE_GEN(N1,POLAR1)

	SELECT CASE (CLASINT)
		CASE ('S')
			V2=FBASE_GEN(N2,POLAR2)
		CASE ('T')
			V2=TBASE_GEN(N2,POLAR2)
		CASE ('V')
			V2=VBASE_GEN(N2,POLAR2,P2)
		CASE ('H')
			V2=HBASE_GEN(N2,POLAR2,P2)
		CASE ('X','Y','Z')
			V2=XBASE_GEN(N2,POLAR2,P)
		CASE ('J')
			V2=FBASE_GEN(N2,POLAR2)
	END SELECT
	!IF(ISNAN(V2))V2=0.Q0 !PARA EVITAR QUE SE CUELGUE

	YFUNC_GEN=V1*V2

    END

! --------------------------------------------------------------------
! ----- Cálculo  por  MONTECARLO  de integrales (p q | r s).
! ----- FUNCIONES DE BASE SIN NORMALIZAR.
! ----- NUMEROS PSEUDOALEATORIOS TIPO "NUMERICAL RECIPES".
! ----- (EXPLICACIONES MAS COMPLETAS EN SUBROUTINE BIELHAS) 
! ----- INCLUYE ESTIMACION (GROSERA) DEL ERROR
! --------------------------------------------------------------------
	SUBROUTINE BIELRND_GEN(NB1,NB2,NB3,NB4,SSM,ER)
	USE GLOBAL
	USE ESTRUCT
    IMPLICIT NONE
    TYPE(DAT_METODO)::MET
	TYPE(RCSTFI)::POLAR12,POLAR34
	TYPE(XYZ)::P,P12,P34,P1,P2,P3,P4,PC12,PC34
	TYPE(XY)::PPOLIGR1(1:INCREMENT+1),PPOLIGR2(1:INCREMENT+1)
	TYPE(XY)::PPOLIGT1(1:INCREMENT+1),PPOLIGT2(1:INCREMENT+1)
	TYPE(XY)::PPOLIGF1(1:INCREMENT+1),PPOLIGF2(1:INCREMENT+1)
    REAL*16 STRPOLIGR1(INCREMENT),STRPOLIGR2(INCREMENT)
	REAL*16 STRPOLIGT1(INCREMENT),STRPOLIGT2(INCREMENT)
	REAL*16 STRPOLIGF1(INCREMENT),STRPOLIGF2(INCREMENT)
	REAL*16 DISTCENTROS12,DISTCENTROS34
    INTEGER*4 NB1,NB2,NB3,NB4,N10,IMAL,IISEM,I10,I,J
    REAL*16 SSM,VALPRE,ER,ARPR1,ARPR2,AT1,AT2,ARPT1,ARPT2,ARPF1,ARPF2,B12,C12,B34,C34,Y012,Y112,Y212,Y312,Y034,Y134,Y234,Y334,DENOM,ANTOT
    REAL*16 GGR1,GGR2,GR1,GR2,W1,W2,GT1,GT2,GF1,GF2,WR1,WR2,WT1,WT2,WF1,WF2,Y1,Y2,Y,RR
    REAL*16 CONSTNORM,YFUNC_GEN
    REAL*16 SPAR(10)

	P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z
	P3.X=FB(NB3).X
	P3.Y=FB(NB3).Y
	P3.Z=FB(NB3).Z
	P4.X=FB(NB4).X
	P4.Y=FB(NB4).Y
	P4.Z=FB(NB4).Z

! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS12=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS12==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC12.X=P1.X
		PC12.Y=P1.Y
		PC12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC12.X=(P1.X+P2.X)/2.Q0
		PC12.Y=(P1.Y+P2.Y)/2.Q0
		PC12.Z=(P1.Z+P2.Z)/2.Q0
	ENDIF
	DISTCENTROS34=QSQRT((P3.X-P4.X)**2+(P3.Y-P4.Y)**2+(P3.Z-P4.Z)**2)
	IF (DISTCENTROS34==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC34.X=P3.X
		PC34.Y=P3.Y
		PC34.Z=P3.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC34.X=(P3.X+P4.X)/2.Q0
		PC34.Y=(P3.Y+P4.Y)/2.Q0
		PC34.Z=(P3.Z+P4.Z)/2.Q0
	ENDIF

! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSM=0.Q0

! -- CALCULA SI SE PUEDE CONSIDERAR NULA LA INTEGRAL (EN CASO DE NO SER UNA SOLA)
	IF (UNASOLA==1) THEN
		CALL PREPARA2(NB1,NB2,NB3,NB4,P1,P2,P3,P4,VALPRE)
		IF(VALPRE<=CERO)THEN
			ER=0.Q0
			RETURN
		ENDIF
	ENDIF

! -- CALCULO DE LA FUNCIÓN DE PESO	
	CALL FPESO_GEN(NB1,NB2,P1,P2,PC12,ARPR1,AT1,ARPT1,ARPF1,PPOLIGR1,PPOLIGT1,PPOLIGF1,STRPOLIGR1,STRPOLIGT1,STRPOLIGF1)
	B12=EXP0
	C12=EXP1
	CALL FPESO_GEN(NB3,NB4,P3,P4,PC34,ARPR2,AT2,ARPT2,ARPF2,PPOLIGR2,PPOLIGT2,PPOLIGF2,STRPOLIGR2,STRPOLIGT2,STRPOLIGF2)
	B34=EXP0
	C34=EXP1

! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS12,Y012,Y112,Y212,Y312,B12,C12)
	CALL CONSTNORMRECORT(NB3,NB4,DISTCENTROS34,Y034,Y134,Y234,Y334,B34,C34)

! ------- PARTE CENTRAL DEL CALCULO DE LA INTEGRAL ------------
    N10=NMC/10
    IMAL=0
	IISEM=ISEM
	DENOM=0.Q0

	OUTER: DO I10=1,10
		INNER: DO I=1,N10
			IF (NPOLIG==0)THEN
				GGR1=RAN(IISEM)
				IF(GGR1<=0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GGR2=RAN(IISEM)     
				IF(GGR2<=0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GR1=-QLOG(Y012-GGR1*Y112)/B12
				GR2=-QLOG(Y034-GGR2*Y134)/B34
				W1=EXP(-B12*GR1)
				W2=EXP(-B34*GR2)
				CONSTNORM=(Y112*Y134)/(B12*B34)
				GT1=RAN(IISEM)     
				IF(GT1<=0.OR.GT1>1.Q0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GF1=RAN(IISEM)      
				GT2=RAN(IISEM)
				IF(GT2<=0.OR.GT2>1.Q0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GF2=RAN(IISEM)			
				POLAR12.R=GR1
				POLAR12.CST=1.Q0-2.*GT1
				POLAR12.FI=2.Q0*PI*GF1
				POLAR34.R=GR2
				POLAR34.CST=1.Q0-2.*GT2
				POLAR34.FI=2.Q0*PI*GF2
			ELSE IF (NPOLIG==1)THEN
				CALL INV_FDEN_R(IMAL,ARPR1,AT1,GR1,WR1,MET,PPOLIGR1,STRPOLIGR1,CLASMON,IISEM)
				CALL INV_FDEN_R(IMAL,ARPR2,AT2,GR2,WR2,MET,PPOLIGR2,STRPOLIGR2,CLASMON,IISEM)
				GT1=RAN(IISEM)
				GF1=RAN(IISEM)
				GT2=RAN(IISEM)
				GF2=RAN(IISEM)
				W1=WR1
				W2=WR2
				CONSTNORM=AT1*AT2
				POLAR12.R=GR1
				POLAR12.CST=1.Q0-2.*GT1
				POLAR12.FI=2.Q0*PI*GF1
				POLAR34.R=GR2
				POLAR34.CST=1.Q0-2.*GT2
				POLAR34.FI=2.Q0*PI*GF2
			ELSE IF (NPOLIG==2)THEN
				CALL INV_FDEN_R(IMAL,ARPR1,AT1,GR1,WR1,MET,PPOLIGR1,STRPOLIGR1,CLASMON,IISEM)
				CALL INV_FDEN_R(IMAL,ARPR2,AT2,GR2,WR2,MET,PPOLIGR2,STRPOLIGR2,CLASMON,IISEM)
				CALL INV_FDEN_ANG(IMAL,ARPT1,GT1,WT1,MET,PPOLIGT1,STRPOLIGT1,CLASMON,IISEM)
				CALL INV_FDEN_ANG(IMAL,ARPT2,GT2,WT2,MET,PPOLIGT2,STRPOLIGT2,CLASMON,IISEM)
				GF1=RAN(IISEM)
				GF2=RAN(IISEM)
				W1=WR1*WT1
				W2=WR2*WT2
				CONSTNORM=AT1*AT2*ARPT1*ARPT2
				POLAR12.R=GR1
				POLAR12.CST=GT1
				POLAR12.FI=2.Q0*PI*GF1
				POLAR34.R=GR2
				POLAR34.CST=GT2
				POLAR34.FI=2.Q0*PI*GF2
			ELSE IF (NPOLIG==3)THEN
				CALL INV_FDEN_R(IMAL,ARPR1,AT1,GR1,WR1,MET,PPOLIGR1,STRPOLIGR1,CLASMON,IISEM)
				CALL INV_FDEN_R(IMAL,ARPR2,AT2,GR2,WR2,MET,PPOLIGR2,STRPOLIGR2,CLASMON,IISEM)
				CALL INV_FDEN_ANG(IMAL,ARPT1,GT1,WT1,MET,PPOLIGT1,STRPOLIGT1,CLASMON,IISEM)
				CALL INV_FDEN_ANG(IMAL,ARPF1,GF1,WF1,MET,PPOLIGF1,STRPOLIGF1,CLASMON,IISEM)
				CALL INV_FDEN_ANG(IMAL,ARPT2,GT2,WT2,MET,PPOLIGT2,STRPOLIGT2,CLASMON,IISEM)
				CALL INV_FDEN_ANG(IMAL,ARPF2,GF2,WF2,MET,PPOLIGF2,STRPOLIGF2,CLASMON,IISEM)
				W1=WR1*WT1*WF1
				W2=WR2*WT2*WF2
				CONSTNORM=AT1*AT2*ARPT1*ARPT2*ARPF1*ARPF2			
				POLAR12.R=GR1
				POLAR12.CST=GT1
				POLAR12.FI=GF1
				POLAR34.R=GR2
				POLAR34.CST=GT2
				POLAR34.FI=GF2
			END IF

! ---   LOS VALORES DE POLARES O ELIPSOIDALES GENERADOS LO SON RESPECTO A UN ORIGEN QUE
! ---   PUEDE CAMBIARSE MEDIANTE LAS TRANSFORMACIONES QUE SIGUEN:

			IF (DISTCENTROS12==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				CALL POLAR2CAR(POLAR12,P12)	!PASO DE POLARES A CARTESIANAS
					
				P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
				P12.Y=P12.Y+PC12.Y
				P12.Z=P12.Z+PC12.Z

				Y1=YFUNC_GEN(NB1,NB2,P12,P1,P2)*POLAR12.R**2/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				IF (C12/=0.Q0)THEN
					POLAR12.CST=-QLOG(Y212-GT1*Y312)/C12
					CONSTNORM=0.5Q0*CONSTNORM*Y112/B12 !EL 0.5 ES PORQUE DESPUES MULTIPLICAMOS POR 4PI Y EN ESTE CASO ES 2PI
					W1=W1*EXP(-C12*POLAR12.CST)
				ENDIF
				CALL SPHER2CAR(POLAR12,DISTCENTROS12,P12)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
				P12.Y=P12.Y+PC12.Y
				P12.Z=P12.Z+PC12.Z
				
				Y1=YFUNC_GEN(NB1,NB2,P12,P1,P2)*(POLAR12.R**2-POLAR12.CST**2)*(DISTCENTROS12/2.Q0)**3/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ENDIF
			IF (DISTCENTROS34==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				CALL POLAR2CAR(POLAR34,P34)	!PASO DE POLARES A CARTESIANAS
					
				P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
				P34.Y=P34.Y+PC34.Y
				P34.Z=P34.Z+PC34.Z

				Y2=YFUNC_GEN(NB3,NB4,P34,P3,P4)*POLAR34.R**2/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				IF (C34/=0.Q0)THEN
					POLAR34.CST=-QLOG(Y234-GT2*Y334)/C34
					CONSTNORM=0.5Q0*CONSTNORM*Y134/B34 !EL 0.5 ES PORQUE DESPUES MULTIPLICAMOS POR 4PI Y EN ESTE CASO ES 2PI
					W2=W2*EXP(-C34*POLAR34.CST)
				ENDIF
				CALL SPHER2CAR(POLAR34,DISTCENTROS34,P34)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
				P34.Y=P34.Y+PC34.Y
				P34.Z=P34.Z+PC34.Z
				
				Y2=YFUNC_GEN(NB3,NB4,P34,P3,P4)*(POLAR34.R**2-POLAR34.CST**2)*(DISTCENTROS34/2.Q0)**3/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ENDIF

			Y=Y1*Y2

! --- CALCULO DE LA DISTANCIA r12 :
			P.X=P34.X-P12.X
			P.Y=P34.Y-P12.Y
			P.Z=P34.Z-P12.Z
			RR=P.X*P.X+P.Y*P.Y+P.Z*P.Z
			IF(RR<=CERO)THEN
				IMAL=IMAL+1
				CYCLE INNER
			ENDIF
			Y=Y/QSQRT(RR)
			DENOM=DENOM+1.Q0
			SSM=SSM+(Y-SSM)/DENOM
        ENDDO INNER
		SPAR(I10)=SSM
	ENDDO OUTER
        
    ER=0.Q0
    DO J=1,2
		ER= ER + QABS(SPAR(J)-SSM)*DFLOAT(J)/1.0Q01
	END DO
    ER=ER/2.0Q0

    ANTOT=1.6Q1*PI*PI*CONSTNORM
    SSM=ANTOT*SSM
    ER=ANTOT*ER

    RETURN
    END
     
! --------------------------------------------------------------------
!     PREPARACION DEL CALCULO DE UNA INTEGRAL BIELECTRONICA:
!     DETERMINA SI ES NULA
! --------------------------------------------------------------------
	SUBROUTINE PREPARA2(NB1,NB2,NB3,NB4,P1,P2,P3,P4,VALPRE)
    USE GLOBAL
	USE ESTRUCT
	IMPLICIT NONE
    TYPE(XYZ)::P1,P2,P3,P4
    INTEGER*4 NB1,NB2,NB3,NB4,NPQ,NRS,INPQ_F
    REAL*16 VALPRE,ASPQ,ASRS
    
    VALPRE=1.Q0
  
    IF(QABS(P1.X-P2.X)>CERO)RETURN
	IF(QABS(P1.Y-P2.Y)>CERO)RETURN
	IF(QABS(P1.Z-P2.Z)>CERO)RETURN
	IF(QABS(P1.X-P3.X)>CERO)RETURN
	IF(QABS(P1.Y-P3.Y)>CERO)RETURN
	IF(QABS(P1.Z-P3.Z)>CERO)RETURN
	IF(QABS(P1.X-P4.X)>CERO)RETURN
	IF(QABS(P1.Y-P4.Y)>CERO)RETURN
	IF(QABS(P1.Z-P4.Z)>CERO)RETURN
	
    NPQ=INPQ_F(NB1,NB2)
    NRS=INPQ_F(NB3,NB4)
    ASPQ=QABS(S(NPQ))
    ASRS=QABS(S(NRS))

    IF(ASPQ<=CERO.AND.ASRS>CERO)VALPRE=0.Q0
    IF(ASRS<=CERO.AND.ASPQ>CERO)VALPRE=0.Q0

    RETURN
    END

 !*********************************************************************
!****************** METODO DE HALTON *********************************
!*********************************************************************

! --------------------------------------------------------------------
! ----- Cálculo por MONTECARLO de integrales monoelectronicas <p|A|q>
! ----- con  A= 1,X,T,V, o H=T+V  y FUNCIONES DE BASE SIN NORMALIZAR.
! ----- (NUMEROS DE HALTON - NO ADMITEN SEMILLA VARIABLE)
! ----- INCLUYE ESTIMACION DEL ERROR ( BASTANTE GROSERA) 
! --------------------------------------------------------------------
	SUBROUTINE MONOHAL_GEN(NB1,NB2,SSM,ER)
	USE ESTRUCT
	USE GLOBAL
	IMPLICIT NONE
    TYPE(RCSTFI)::POLAR
	TYPE(XYZ)::P,P1,P2,P12
	TYPE(DAT_METODO)::MET,MET1,MET2
	TYPE(XY)::PPOLIGR(1:INCREMENT+1),PPOLIGT(1:INCREMENT+1),PPOLIGF(1:INCREMENT+1)
	REAL*16 STRPOLIGR(INCREMENT),STRPOLIGT(INCREMENT),STRPOLIGF(INCREMENT)
	REAL*16 SSM,ER,VALPRE,DENOM,YFUNC_GEN,Y,HALTON
	REAL*16 ARPR,ARPT,ARPF,AT,W,WR,WT,WF,GR,GGR,GT,GF
	REAL*16 SPAR(10)
	INTEGER*4 NB1,NB2,N10,IISEM,IMAL,I,J,I10,NULA
	REAL*16 DISTCENTROS,CONSTNORM,Y0,Y1,Y2,Y3
    INTEGER*8 NRA2,NRA3,NRA5,NRB2,NRB3,NRB5
    
	P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z

! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		P12.X=P1.X
		P12.Y=P1.Y
		P12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		P12.X=(P1.X+P2.X)/2.Q0
		P12.Y=(P1.Y+P2.Y)/2.Q0
		P12.Z=(P1.Z+P2.Z)/2.Q0
	ENDIF

! -- CALCULO DE LA FUNCIÓN DE PESO
	CALL FPESO_GEN(NB1,NB2,P1,P2,P12,ARPR,AT,ARPT,ARPF,PPOLIGR,PPOLIGT,PPOLIGF,STRPOLIGR,STRPOLIGT,STRPOLIGF)

! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS,Y0,Y1,Y2,Y3,EXP0,EXP1)

! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSM=0.Q0

! --ESTABLECE SI LA INTEGRAL SE PUEDE CONSIDERAR NULA (AHORRA TIEMPO)
	CALL PREPARA(NB1,NB2,P1,P2,P12,VALPRE,'RND',ARPR,AT,PPOLIGR,STRPOLIGR)
	IF(VALPRE<=CERO)THEN
		ER=0.Q0
		RETURN
	ENDIF

! ---------CALCULO MONTE CARLO: --------------------------------
	NRA2=0
    NRA3=0
    NRA5=0
    NRB2=1
    NRB3=1
    NRB5=1
    N10=NMC/10
    IMAL=0
    DENOM=0.Q0

    MET.NUM=2
	MET.NR1=NRA2
	MET.NR2=NRB2
	MET1.NUM=3
	MET1.NR1=NRA3
	MET1.NR2=NRB3
	MET2.NUM=5
	MET2.NR1=NRA5
	MET2.NR2=NRB5
    OUTER: DO I10=1,10
		INNER: DO I=1,N10
			IF (NPOLIG==0) THEN !SÓLO LAS EXPONENCIALES (SLATER Y GAUSSIANAS)
				GGR=HALTON(2,NRA2,NRB2)
				IF(GGR<=0)THEN
					CYCLE INNER
				END IF
				GR=-QLOG(Y0-GGR*Y1)/EXP0
				W=EXP(-EXP0*GR)
				CONSTNORM=Y1/EXP0
				GT=HALTON(3,NRA3,NRB3)  
				IF(GT<=0.OR.GT>1.Q0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GF=HALTON(5,NRA5,NRB5)
				POLAR.R=GR
				POLAR.CST=1.Q0-2.*GT
				POLAR.FI=2.Q0*PI*GF
			ELSE IF (NPOLIG==1)THEN
				CALL INV_FDEN_R(IMAL,ARPR,AT,GR,WR,MET,PPOLIGR,STRPOLIGR,CLASMON,0)
				GT=HALTON(3,NRA3,NRB3)  
				IF(GT<=0.OR.GT>1.Q0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GF=HALTON(5,NRA5,NRB5)
				W=WR
				CONSTNORM=AT
				POLAR.R=GR
				POLAR.CST=1.Q0-2.*GT
				POLAR.FI=2.Q0*PI*GF
			ELSE IF (NPOLIG==2)THEN
				CALL INV_FDEN_R(IMAL,ARPR,AT,GR,WR,MET,PPOLIGR,STRPOLIGR,CLASMON,0)
				CALL INV_FDEN_ANG(IMAL,ARPT,GT,WT,MET1,PPOLIGT,STRPOLIGT,CLASMON,0)
				GF=HALTON(5,NRA5,NRB5)
				W=WR*WT
				CONSTNORM=AT*ARPT
				POLAR.R=GR
				POLAR.CST=GT
				POLAR.FI=2.Q0*PI*GF
			ELSE IF (NPOLIG==3)THEN
				CALL INV_FDEN_R(IMAL,ARPR,AT,GR,WR,MET,PPOLIGR,STRPOLIGR,CLASMON,0)
				CALL INV_FDEN_ANG(IMAL,ARPT,GT,WT,MET1,PPOLIGT,STRPOLIGT,CLASMON,0)
				CALL INV_FDEN_ANG(IMAL,ARPF,GF,WF,MET2,PPOLIGF,STRPOLIGF,CLASMON,0)			
				W=WR*WT*WF
				CONSTNORM=AT*ARPT*ARPF
				POLAR.R=GR
				POLAR.CST=GT
				POLAR.FI=GF
			END IF
			
			IF (DISTCENTROS==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				CALL POLAR2CAR(POLAR,P)	!PASO DE POLARES A CARTESIANAS
					
				P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
				P.Y=P.Y+P12.Y
				P.Z=P.Z+P12.Z

				Y=YFUNC_GEN(NB1,NB2,P,P1,P2)*POLAR.R**2/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				CALL SPHER2CAR(POLAR,DISTCENTROS,P)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
				P.Y=P.Y+P12.Y
				P.Z=P.Z+P12.Z
				
				Y=YFUNC_GEN(NB1,NB2,P,P1,P2)*(POLAR.R**2-POLAR.CST**2)*(DISTCENTROS/2.Q0)**3/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ENDIF

			DENOM=DENOM+1.Q0
			SSM= SSM + (Y-SSM)/DENOM
        ENDDO INNER
		SPAR(I10)=SSM
	ENDDO OUTER

    ER=0.Q0
    DO J=1,2
		ER= ER + QABS(SPAR(J)-SSM)*DFLOAT(J)/1.0Q01
	END DO
    ER=ER/2.0Q0

	SSM=4.Q0*PI*SSM*CONSTNORM
	ER=4.Q0*PI*ER*CONSTNORM

    RETURN
    END

! --------------------------------------------------------------------
! ----- Cálculo  por  MONTECARLO  de integrales (p q | r s).
! ----- (FUNCIONES DE BASE SIN NORMALIZAR)
! ----- (NUMEROS DE HALTON)
! ----- atencion:  Los numeros de Halton NO admiten semilla.
! ----- INCLUYE ESTIMACION DEL ERROR ( BASTANTE GROSERA) 
! ----- (EXPLICACIONES MAS COMPLETAS EN SUBROUTINE BIELHAS)
! --------------------------------------------------------------------
	SUBROUTINE BIELHAL_GEN(NB1,NB2,NB3,NB4,SSM,ER)
	USE GLOBAL
	USE ESTRUCT
    IMPLICIT NONE
    TYPE(DAT_METODO)::MET,MET1,MET2,MET3,MET4,MET5
	TYPE(RCSTFI)::POLAR12,POLAR34
	TYPE(XYZ)::P,P12,P34,P1,P2,P3,P4,PC12,PC34
	TYPE(XY)::PPOLIGR1(1:INCREMENT+1),PPOLIGR2(1:INCREMENT+1)
	TYPE(XY)::PPOLIGT1(1:INCREMENT+1),PPOLIGT2(1:INCREMENT+1)
	TYPE(XY)::PPOLIGF1(1:INCREMENT+1),PPOLIGF2(1:INCREMENT+1)
	REAL*16 STRPOLIGR1(INCREMENT),STRPOLIGR2(INCREMENT)
	REAL*16 STRPOLIGT1(INCREMENT),STRPOLIGT2(INCREMENT)
	REAL*16 STRPOLIGF1(INCREMENT),STRPOLIGF2(INCREMENT)    
	REAL*16 DISTCENTROS12,DISTCENTROS34
    REAL*16 SPAR(10)
    INTEGER*4 NB1,NB2,NB3,NB4,N10,IMAL,I10,I,J
    INTEGER*8 NRA2,NRA3,NRA5,NRA7,NRA11,NRA13,NRB2,NRB3,NRB5,NRB7,NRB11,NRB13
    REAL*16 SSM,ER,VALPRE,DENOM,CONSTNORM,YFUNC_GEN,HALTON,ANTOT
    REAL*16 B12,B34,Y012,Y112,Y212,Y312,C12,Y034,Y134,Y234,Y334,C34,Y,Y1,Y2,RR
    REAL*16 ARPR1,AT1,ARPT1,ARPF1,ARPR2,AT2,ARPT2,ARPF2
    REAL*16 GGR1,GGR2,GR1,GR2,W1,W2,GT1,GF1,GT2,GF2,WR1,WR2,WT1,WT2,WF1,WF2


	P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z
	P3.X=FB(NB3).X
	P3.Y=FB(NB3).Y
	P3.Z=FB(NB3).Z
	P4.X=FB(NB4).X
	P4.Y=FB(NB4).Y
	P4.Z=FB(NB4).Z

! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS12=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS12==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC12.X=P1.X
		PC12.Y=P1.Y
		PC12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC12.X=(P1.X+P2.X)/2.Q0
		PC12.Y=(P1.Y+P2.Y)/2.Q0
		PC12.Z=(P1.Z+P2.Z)/2.Q0
	ENDIF
	DISTCENTROS34=QSQRT((P3.X-P4.X)**2+(P3.Y-P4.Y)**2+(P3.Z-P4.Z)**2)
	IF (DISTCENTROS34==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC34.X=P3.X
		PC34.Y=P3.Y
		PC34.Z=P3.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC34.X=(P3.X+P4.X)/2.Q0
		PC34.Y=(P3.Y+P4.Y)/2.Q0
		PC34.Z=(P3.Z+P4.Z)/2.Q0
	ENDIF

! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSM=0.Q0

! -- CALCULA SI SE PUEDE CONSIDERAR NULA LA INTEGRAL (EN CASO DE NO SER UNA SOLA)
	IF (UNASOLA==1) THEN
		CALL PREPARA2(NB1,NB2,NB3,NB4,P1,P2,P3,P4,VALPRE)
		IF(VALPRE<=CERO)THEN
			ER=0.Q0
			RETURN
		ENDIF
	ENDIF

! -- CALCULO DE LA FUNCIÓN DE PESO	
	CALL FPESO_GEN(NB1,NB2,P1,P2,PC12,ARPR1,AT1,ARPT1,ARPF1,PPOLIGR1,PPOLIGT1,PPOLIGF1,STRPOLIGR1,STRPOLIGT1,STRPOLIGF1)
	B12=EXP0
	CALL FPESO_GEN(NB3,NB4,P3,P4,PC34,ARPR2,AT2,ARPT2,ARPF2,PPOLIGR2,PPOLIGT2,PPOLIGF2,STRPOLIGR2,STRPOLIGT2,STRPOLIGF2)
	B34=EXP0

! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS12,Y012,Y112,Y212,Y312,B12,C12)
	CALL CONSTNORMRECORT(NB3,NB4,DISTCENTROS34,Y034,Y134,Y234,Y334,B34,C34)

! ------- PARTE CENTRAL DEL CALCULO DE LA INTEGRAL ------------
    NRA2=0
    NRA3=0
    NRA5=0
    NRB2=1
    NRB3=1
    NRB5=1
    NRA7=0
    NRA11=0
    NRA13=0
    NRB7=1
    NRB11=1
    NRB13=1
    N10=NMC/10
    DENOM=0.Q0
    IMAL=0

	MET.NUM=2
	MET.NR1=NRA2
	MET.NR2=NRB2
	MET1.NUM=3
	MET1.NR1=NRA3
	MET1.NR2=NRB3
	MET2.NUM=5
	MET2.NR1=NRA5
	MET2.NR2=NRB5
	MET3.NUM=7
	MET3.NR1=NRA7
	MET3.NR2=NRB7
	MET4.NUM=11
	MET4.NR1=NRA11
	MET4.NR2=NRB11
	MET5.NUM=13
	MET5.NR1=NRA13
	MET5.NR2=NRB13
    
	OUTER: DO I10=1,10
		INNER: DO I=1,N10
			IF (NPOLIG==0)THEN		
				GGR1=HALTON(2,NRA2,NRB2)
				IF(GGR1<=0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GGR2=HALTON(3,NRA3,NRB3)
				IF(GGR2<=0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GR1=-QLOG(Y012-GGR1*Y112)/B12
				GR2=-QLOG(Y034-GGR2*Y134)/B34
				W1=EXP(-B12*GR1)
				W2=EXP(-B34*GR2)
				CONSTNORM=(Y112*Y134)/(B12*B34)
				GT1=HALTON(5,NRA5,NRB5)
				IF(GT1<=0.OR.GT1>1.Q0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GF1=HALTON(7,NRA7,NRB7)
				GT2=HALTON(11,NRA11,NRB11)
				IF(GT2<=0.OR.GT2>1.Q0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GF2=HALTON(13,NRA13,NRB13)
				POLAR12.R=GR1
				POLAR12.CST=1.Q0-2.*GT1
				POLAR12.FI=2.Q0*PI*GF1
				POLAR34.R=GR2
				POLAR34.CST=1.Q0-2.*GT2
				POLAR34.FI=2.Q0*PI*GF2
			ELSE IF (NPOLIG==1)THEN
				CALL INV_FDEN_R(IMAL,ARPR1,AT1,GR1,WR1,MET,PPOLIGR1,STRPOLIGR1,CLASMON,0)
				CALL INV_FDEN_R(IMAL,ARPR2,AT2,GR2,WR2,MET1,PPOLIGR2,STRPOLIGR2,CLASMON,0)
				GT1=HALTON(5,NRA5,NRB5)
				GF1=HALTON(7,NRA7,NRB7)
				GT2=HALTON(11,NRA11,NRB11)
				GF2=HALTON(13,NRA13,NRB13)     
				W1=WR1
				W2=WR2
				CONSTNORM=AT1*AT2
				POLAR12.R=GR1
				POLAR12.CST=1.Q0-2.*GT1
				POLAR12.FI=2.Q0*PI*GF1
				POLAR34.R=GR2
				POLAR34.CST=1.Q0-2.*GT2
				POLAR34.FI=2.Q0*PI*GF2
			ELSE IF (NPOLIG==2)THEN
				CALL INV_FDEN_R(IMAL,ARPR1,AT1,GR1,WR1,MET,PPOLIGR1,STRPOLIGR1,CLASMON,0)
				CALL INV_FDEN_R(IMAL,ARPR2,AT2,GR2,WR2,MET1,PPOLIGR2,STRPOLIGR2,CLASMON,0)
				CALL INV_FDEN_ANG(IMAL,ARPT1,GT1,WT1,MET2,PPOLIGT1,STRPOLIGT1,CLASMON,0)
				CALL INV_FDEN_ANG(IMAL,ARPT2,GT2,WT2,MET4,PPOLIGT2,STRPOLIGT2,CLASMON,0)
				GF1=HALTON(7,NRA7,NRB7)      
				GF2=HALTON(13,NRA13,NRB13)
				W1=WR1*WT1
				W2=WR2*WT2
				CONSTNORM=AT1*AT2*ARPT1*ARPT2
				POLAR12.R=GR1
				POLAR12.CST=GT1
				POLAR12.FI=2.Q0*PI*GF1
				POLAR34.R=GR2
				POLAR34.CST=GT2
				POLAR34.FI=2.Q0*PI*GF2
			ELSE IF (NPOLIG==3)THEN
				CALL INV_FDEN_R(IMAL,ARPR1,AT1,GR1,WR1,MET,PPOLIGR1,STRPOLIGR1,CLASMON,0)
				CALL INV_FDEN_R(IMAL,ARPR2,AT2,GR2,WR2,MET1,PPOLIGR2,STRPOLIGR2,CLASMON,0)
				CALL INV_FDEN_ANG(IMAL,ARPT1,GT1,WT1,MET2,PPOLIGT1,STRPOLIGT1,CLASMON,0)
				CALL INV_FDEN_ANG(IMAL,ARPF1,GF1,WF1,MET3,PPOLIGF1,STRPOLIGF1,CLASMON,0)
				CALL INV_FDEN_ANG(IMAL,ARPT2,GT2,WT2,MET4,PPOLIGT2,STRPOLIGT2,CLASMON,0)
				CALL INV_FDEN_ANG(IMAL,ARPF2,GF2,WF2,MET5,PPOLIGF2,STRPOLIGF2,CLASMON,0)
				W1=WR1*WT1*WF1
				W2=WR2*WT2*WF2
				CONSTNORM=AT1*AT2*ARPT1*ARPT2*ARPF1*ARPF2    			
				POLAR12.R=GR1
				POLAR12.CST=GT1
				POLAR12.FI=GF1
				POLAR34.R=GR2
				POLAR34.CST=GT2
				POLAR34.FI=GF2
			END IF

! ---   LOS VALORES DE POLARES O ELIPSOIDALES GENERADOS LO SON RESPECTO A UN ORIGEN QUE
! ---   PUEDE CAMBIARSE MEDIANTE LAS TRANSFORMACIONES QUE SIGUEN:

			IF (DISTCENTROS12==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				CALL POLAR2CAR(POLAR12,P12)	!PASO DE POLARES A CARTESIANAS
					
				P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
				P12.Y=P12.Y+PC12.Y
				P12.Z=P12.Z+PC12.Z

				Y1=YFUNC_GEN(NB1,NB2,P12,P1,P2)*POLAR12.R**2/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				CALL SPHER2CAR(POLAR12,DISTCENTROS12,P12)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
				P12.Y=P12.Y+PC12.Y
				P12.Z=P12.Z+PC12.Z
				
				Y1=YFUNC_GEN(NB1,NB2,P12,P1,P2)*(POLAR12.R**2-POLAR12.CST**2)*(DISTCENTROS12/2.Q0)**3/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ENDIF
			IF (DISTCENTROS34==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				CALL POLAR2CAR(POLAR34,P34)	!PASO DE POLARES A CARTESIANAS
					
				P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
				P34.Y=P34.Y+PC34.Y
				P34.Z=P34.Z+PC34.Z

				Y2=YFUNC_GEN(NB3,NB4,P34,P3,P4)*POLAR34.R**2/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				CALL SPHER2CAR(POLAR34,DISTCENTROS34,P34)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
				P34.Y=P34.Y+PC34.Y
				P34.Z=P34.Z+PC34.Z
				
				Y2=YFUNC_GEN(NB3,NB4,P34,P3,P4)*(POLAR34.R**2-POLAR34.CST**2)*(DISTCENTROS34/2.Q0)**3/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ENDIF

			Y=Y1*Y2

! --- CALCULO DE LA DISTANCIA r12 :
			P.X=P34.X-P12.X
			P.Y=P34.Y-P12.Y
			P.Z=P34.Z-P12.Z
			RR=P.X*P.X+P.Y*P.Y+P.Z*P.Z
			IF(RR<=CERO)THEN
				IMAL=IMAL+1
				CYCLE INNER
			ENDIF
			Y=Y/QSQRT(RR)
			DENOM=DENOM+1.Q0
			SSM=SSM+(Y-SSM)/DENOM
        ENDDO INNER
		SPAR(I10)=SSM
	ENDDO OUTER

    ER=0.Q0
    DO J=1,2
		ER= ER + QABS(SPAR(J)-SSM)*DFLOAT(J)/1.0Q01
	END DO
	ER=ER/2.0Q0

	ANTOT=1.6Q1*PI*PI*CONSTNORM
	SSM=ANTOT*SSM
	ER=ANTOT*ER
      
    RETURN
    END

!*********************************************************************
!****************** METODO DE HAMMERSLEY *****************************
!*********************************************************************

! --------------------------------------------------------------------
! ----- CAlculo por MONTECARLO de integrales monoelectronicas <p|A|q>
! ----- con  A= 1,X,T,V, o H=T+V  y FUNCIONES DE BASE SIN NORMALIZAR.
! ----- (NUMEROS DE HAMMERSLEY)
! --------------------------------------------------------------------
	SUBROUTINE MONOHAM_GEN(NB1,NB2,SSM,ER)
	USE ESTRUCT
	USE GLOBAL
	IMPLICIT NONE
	TYPE(RCSTFI)::POLAR
	TYPE(XYZ)::P,P1,P2,P12
	TYPE(DAT_METODO)::MET,MET1
	TYPE(XY)::PPOLIGR(1:INCREMENT+1),PPOLIGT(1:INCREMENT+1),PPOLIGF(1:INCREMENT+1)
	REAL*16 STRPOLIGR(INCREMENT),STRPOLIGT(INCREMENT),STRPOLIGF(INCREMENT)
	REAL*16 SPAR(10)
	INTEGER*4 NB1,NB2,IMAL,I
    INTEGER*8 NRA2,NRA3,NRB2,NRB3
	REAL*16 DISTCENTROS,CONSTNORM,Y0,Y1,Y2,Y3
    REAL*16 SSM,ER,VALPRE,AL,DELT,DENOM,YFUNC_GEN,HALTON
    REAL*16 ARPR,AT,ARPT,ARPF,GGR,GR,W,GT,GF,WR,WT,WF,Y

	P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z

! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		P12.X=P1.X
		P12.Y=P1.Y
		P12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		P12.X=(P1.X+P2.X)/2.Q0
		P12.Y=(P1.Y+P2.Y)/2.Q0
		P12.Z=(P1.Z+P2.Z)/2.Q0
	ENDIF

! -- CALCULO DE LA FUNCIÓN DE PESO
	CALL FPESO_GEN(NB1,NB2,P1,P2,P12,ARPR,AT,ARPT,ARPF,PPOLIGR,PPOLIGT,PPOLIGF,STRPOLIGR,STRPOLIGT,STRPOLIGF)

! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS,Y0,Y1,Y2,Y3,EXP0,EXP1)

! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSM=0.Q0

! --ESTABLECE SI LA INTEGRAL SE PUEDE CONSIDERAR NULA (AHORRA TIEMPO)
	CALL PREPARA(NB1,NB2,P1,P2,P12,VALPRE,'RND',ARPR,AT,PPOLIGR,STRPOLIGR)
    IF(VALPRE<=CERO)THEN
		ER=0.Q0
		RETURN
	ENDIF
	   
! ---------CALCULO MONTE CARLO: --------------------------------
    NRA2=0
    NRA3=0
    NRB2=1
    NRB3=1
    AL=CERO
    DELT=1.Q0/DFLOAT(NMC)
    IMAL=0
    DENOM=0.Q0


    MET.NUM=2
	MET.NR1=NRA2
	MET.NR2=NRB2
	MET1.NUM=3
	MET1.NR1=NRA3
	MET1.NR2=NRB3
	DO I=1,NMC-1
		AL=AL+DELT
		IF (NPOLIG==0)THEN
			GGR=AL
			GR=-QLOG(Y0-GGR*Y1)/EXP0
			W=EXP(-EXP0*GR)
			CONSTNORM=Y1/EXP0
			GT=HALTON(2,NRA2,NRB2)
			IF(GT<=0.OR.GT>1.Q0)THEN
				IMAL=IMAL+1
				CYCLE
			END IF
			GF=HALTON(3,NRA3,NRB3)
			POLAR.R=GR
			POLAR.CST=1.Q0-2.*GT
			POLAR.FI=2.Q0*PI*GF
		ELSE IF(NPOLIG==1)THEN
			GR=AL
			CALL INV_FDEN_R(IMAL,ARPR,AT,GR,WR,MET,PPOLIGR,STRPOLIGR,CLASMON,0)
			GT=HALTON(2,NRA2,NRB2)
       		IF(GT<=0.OR.GT>1.Q0)THEN
				IMAL=IMAL+1
				CYCLE
			END IF
			GF=HALTON(3,NRA3,NRB3)
			W=WR
			CONSTNORM=AT
			POLAR.R=GR
			POLAR.CST=1.Q0-2.*GT
			POLAR.FI=2.Q0*PI*GF
		ELSE IF(NPOLIG==2)THEN
			GR=AL
			CALL INV_FDEN_R(IMAL,ARPR,AT,GR,WR,MET,PPOLIGR,STRPOLIGR,CLASMON,0)
			CALL INV_FDEN_ANG(IMAL,ARPT,GT,WT,MET,PPOLIGT,STRPOLIGT,'HAL',0)
			GF=HALTON(3,NRA3,NRB3)          
			W=WR*WT
			CONSTNORM=AT*ARPT
			POLAR.R=GR
			POLAR.CST=GT
			POLAR.FI=2.Q0*PI*GF
		ELSE IF(NPOLIG==3)THEN
			GR=AL
			CALL INV_FDEN_R(IMAL,ARPR,AT,GR,WR,MET,PPOLIGR,STRPOLIGR,CLASMON,0)
			CALL INV_FDEN_ANG(IMAL,ARPT,GT,WT,MET,PPOLIGT,STRPOLIGT,'HAL',0)
			CALL INV_FDEN_ANG(IMAL,ARPF,GF,WF,MET1,PPOLIGF,STRPOLIGF,'HAL',0)
			W=WR*WT*WF
			CONSTNORM=AT*ARPT*ARPF
			POLAR.R=GR
			POLAR.CST=GT
			POLAR.FI=GF
		END IF

		IF (DISTCENTROS==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
			CALL POLAR2CAR(POLAR,P)	!PASO DE POLARES A CARTESIANAS
				
			P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
			P.Y=P.Y+P12.Y
			P.Z=P.Z+P12.Z

			Y=YFUNC_GEN(NB1,NB2,P,P1,P2)*POLAR.R**2/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
		ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
			CALL SPHER2CAR(POLAR,DISTCENTROS,P)	!PASO DE ELIPSOIDALES A CARTESIANAS
			
			P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
			P.Y=P.Y+P12.Y
			P.Z=P.Z+P12.Z
			
			Y=YFUNC_GEN(NB1,NB2,P,P1,P2)*(POLAR.R**2-POLAR.CST**2)*(DISTCENTROS/2.Q0)**3/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
		ENDIF

		DENOM=DENOM+1.Q0
		SSM= SSM + (Y-SSM)/DENOM
    ENDDO

	SSM=4.Q0*PI*SSM*CONSTNORM
	
	!NREC=NREC+1
	!IF (NREC==1) THEN
	!	NMC=NMC/10
	!	CALL MONOHAM(NB1,NB2,P1,P2,SSM1,ER)
	!	NMC=NMC*10		
	!	ER=0.1Q0*QABS(SSM-SSM1)
	!ELSE
	!	NREC=0
	!END IF

    RETURN
    END

! --------------------------------------------------------------------
! ----- Cálculo  por  MONTECARLO  de integrales (p q | r s).
! ----- (FUNCIONES DE BASE SIN NORMALIZAR)
! ----- (NUMEROS DE HAMMERSLEY)
! ----- atencion:  Los numeros de Halton NO admiten semilla.
! --------------------------------------------------------------------
	SUBROUTINE BIELHAM_GEN(NB1,NB2,NB3,NB4,SSM,ER)
	USE GLOBAL
	USE ESTRUCT
    IMPLICIT NONE
    TYPE(DAT_METODO)::MET,MET1,MET2,MET3,MET4
	TYPE(RCSTFI)::POLAR12,POLAR34
	TYPE(XYZ)::P,P12,P34,P1,P2,P3,P4,PC12,PC34
	TYPE(XY)::PPOLIGR1(1:INCREMENT+1),PPOLIGR2(1:INCREMENT+1)
	TYPE(XY)::PPOLIGT1(1:INCREMENT+1),PPOLIGT2(1:INCREMENT+1)
	TYPE(XY)::PPOLIGF1(1:INCREMENT+1),PPOLIGF2(1:INCREMENT+1)
	REAL*16 STRPOLIGR1(INCREMENT),STRPOLIGR2(INCREMENT)
	REAL*16 STRPOLIGT1(INCREMENT),STRPOLIGT2(INCREMENT)
	REAL*16 STRPOLIGF1(INCREMENT),STRPOLIGF2(INCREMENT)	
	REAL*16 DISTCENTROS12,DISTCENTROS34
    !REAL*16 SPAR(10)
    INTEGER*4 NB1,NB2,NB3,NB4,IMAL,I
    INTEGER*8 NRA2,NRA3,NRA5,NRA7,NRA11,NRB2,NRB3,NRB5,NRB7,NRB11
    REAL*16 SSM,ER,VALPRE,DELT,DENOM,AL,CONSTNORM,YFUNC_GEN,HALTON,ANTOT
    REAL*16 B12,B34,Y012,Y112,Y212,Y312,C12,Y034,Y134,Y234,Y334,C34,Y,Y1,Y2,RR
    REAL*16 ARPR1,AT1,ARPT1,ARPF1,ARPR2,AT2,ARPT2,ARPF2
    REAL*16 GGR1,GGR2,GR1,GR2,W1,W2,GT1,GF1,GT2,GF2,WR1,WR2,WT1,WT2,WF1,WF2

	P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z
	P3.X=FB(NB3).X
	P3.Y=FB(NB3).Y
	P3.Z=FB(NB3).Z
	P4.X=FB(NB4).X
	P4.Y=FB(NB4).Y
	P4.Z=FB(NB4).Z

! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS12=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS12==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC12.X=P1.X
		PC12.Y=P1.Y
		PC12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC12.X=(P1.X+P2.X)/2.Q0
		PC12.Y=(P1.Y+P2.Y)/2.Q0
		PC12.Z=(P1.Z+P2.Z)/2.Q0
	ENDIF
	DISTCENTROS34=QSQRT((P3.X-P4.X)**2+(P3.Y-P4.Y)**2+(P3.Z-P4.Z)**2)
	IF (DISTCENTROS34==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC34.X=P3.X
		PC34.Y=P3.Y
		PC34.Z=P3.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC34.X=(P3.X+P4.X)/2.Q0
		PC34.Y=(P3.Y+P4.Y)/2.Q0
		PC34.Z=(P3.Z+P4.Z)/2.Q0
	ENDIF

! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSM=0.Q0
    
! -- CALCULA SI SE PUEDE CONSIDERAR NULA LA INTEGRAL (EN CASO DE NO SER UNA SOLA)
	IF (UNASOLA==1) THEN
		CALL PREPARA2(NB1,NB2,NB3,NB4,P1,P2,P3,P4,VALPRE)
		IF(VALPRE<=CERO)THEN
			ER=0.Q0
			RETURN
		ENDIF
	ENDIF

! -- CALCULO DE LA FUNCIÓN DE PESO	
	CALL FPESO_GEN(NB1,NB2,P1,P2,PC12,ARPR1,AT1,ARPT1,ARPF1,PPOLIGR1,PPOLIGT1,PPOLIGF1,STRPOLIGR1,STRPOLIGT1,STRPOLIGF1)
	B12=EXP0
	CALL FPESO_GEN(NB3,NB4,P3,P4,PC34,ARPR2,AT2,ARPT2,ARPF2,PPOLIGR2,PPOLIGT2,PPOLIGF2,STRPOLIGR2,STRPOLIGT2,STRPOLIGF2)
	B34=EXP0

! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS12,Y012,Y112,Y212,Y312,B12,C12)
	CALL CONSTNORMRECORT(NB3,NB4,DISTCENTROS34,Y034,Y134,Y234,Y334,B34,C34)

! ------- PARTE CENTRAL DEL CALCULO DE LA INTEGRAL ------------
    NRA2=0
    NRA3=0
    NRA5=0
    NRB2=1
    NRB3=1
    NRB5=1
    NRA7=0
    NRA11=0
    NRB7=1
    NRB11=1
    DELT=1.Q0/DFLOAT(NMC)
    IMAL=0
    DENOM=0.Q0
    AL=0.Q0

	MET.NUM=2
	MET.NR1=NRA2
	MET.NR2=NRB2
	MET1.NUM=3
	MET1.NR1=NRA3
	MET1.NR2=NRB3
	MET2.NUM=5
	MET2.NR1=NRA5
	MET2.NR2=NRB5
	MET3.NUM=7
	MET3.NR1=NRA7
	MET3.NR2=NRB7
	MET4.NUM=11
	MET4.NR1=NRA11
	MET4.NR2=NRB11
	DO I=1,NMC-1
		AL=AL+DELT
		IF (NPOLIG==0)THEN
			GGR1=AL
			GGR2=HALTON(2,NRA2,NRB2)
			IF(GGR2<=0)THEN
				IMAL=IMAL+1
				CYCLE
			END IF
			GR1=-QLOG(Y012-GGR1*Y112)/B12
			GR2=-QLOG(Y034-GGR2*Y134)/B34
			W1=EXP(-B12*GR1)
			W2=EXP(-B34*GR2)
			CONSTNORM=(Y112*Y134)/(B12*B34)
			GT1=HALTON(3,NRA3,NRB3)     
			IF(GT1<=0.Q0.OR.GT1>1.Q0)THEN
				IMAL=IMAL+1
				CYCLE
			END IF
			GF1=HALTON(5,NRA5,NRB5)
			GT2=HALTON(7,NRA7,NRB7)
			IF(GT2<=0.Q0.OR.GT2>1.Q0)THEN
				IMAL=IMAL+1
				CYCLE
			END IF
			GF2=HALTON(11,NRA11,NRB11)
			POLAR12.R=GR1
			POLAR12.CST=1.Q0-2.*GT1
			POLAR12.FI=2.Q0*PI*GF1
			POLAR34.R=GR2
			POLAR34.CST=1.Q0-2.*GT2
			POLAR34.FI=2.Q0*PI*GF2
		ELSE IF (NPOLIG==1)THEN
			GR1=AL
			CALL INV_FDEN_R(IMAL,ARPR1,AT1,GR1,WR1,MET,PPOLIGR1,STRPOLIGR1,CLASMON,0)
			CALL INV_FDEN_R(IMAL,ARPR2,AT2,GR2,WR2,MET,PPOLIGR2,STRPOLIGR2,'HAL',0)
			GT1=HALTON(3,NRA3,NRB3)
			GF1=HALTON(5,NRA5,NRB5)
			GT2=HALTON(7,NRA7,NRB7)     
			GF2=HALTON(11,NRA11,NRB11)
			W1=WR1
			W2=WR2
			CONSTNORM=AT1*AT2
			POLAR12.R=GR1
			POLAR12.CST=1.Q0-2.*GT1
			POLAR12.FI=2.Q0*PI*GF1
			POLAR34.R=GR2
			POLAR34.CST=1.Q0-2.*GT2
			POLAR34.FI=2.Q0*PI*GF2
		ELSE IF (NPOLIG==2)THEN
			GR1=AL
			CALL INV_FDEN_R(IMAL,ARPR1,AT1,GR1,WR1,MET,PPOLIGR1,STRPOLIGR1,CLASMON,0)
			CALL INV_FDEN_R(IMAL,ARPR2,AT2,GR2,WR2,MET,PPOLIGR2,STRPOLIGR2,'HAL',0)
			CALL INV_FDEN_ANG(IMAL,ARPT1,GT1,WT1,MET1,PPOLIGT1,STRPOLIGT1,'HAL',0)
			CALL INV_FDEN_ANG(IMAL,ARPT2,GT2,WT2,MET3,PPOLIGT2,STRPOLIGT2,'HAL',0)
			GF1=HALTON(5,NRA5,NRB5)
			GF2=HALTON(11,NRA11,NRB11)
			W1=WR1*WT1
			W2=WR2*WT2
			CONSTNORM=AT1*AT2*ARPT1*ARPT2
			POLAR12.R=GR1
			POLAR12.CST=GT1
			POLAR12.FI=2.Q0*PI*GF1
			POLAR34.R=GR2
			POLAR34.CST=GT2
			POLAR34.FI=2.Q0*PI*GF2
		ELSE IF (NPOLIG==3)THEN
			GR1=AL
			CALL INV_FDEN_R(IMAL,ARPR1,AT1,GR1,WR1,MET,PPOLIGR1,STRPOLIGR1,CLASMON,0)
			CALL INV_FDEN_R(IMAL,ARPR2,AT2,GR2,WR2,MET,PPOLIGR2,STRPOLIGR2,'HAL',0)
			CALL INV_FDEN_ANG(IMAL,ARPT1,GT1,WT1,MET1,PPOLIGT1,STRPOLIGT1,'HAL',0)
			CALL INV_FDEN_ANG(IMAL,ARPF1,GF1,WF1,MET2,PPOLIGF1,STRPOLIGF1,'HAL',0)
			CALL INV_FDEN_ANG(IMAL,ARPT2,GT2,WT2,MET3,PPOLIGT2,STRPOLIGT2,'HAL',0)
			CALL INV_FDEN_ANG(IMAL,ARPF2,GF2,WF2,MET4,PPOLIGF2,STRPOLIGF2,'HAL',0)
			W1=WR1*WT1*WF1
			W2=WR2*WT2*WF2
			CONSTNORM=AT1*AT2*ARPT1*ARPT2*ARPF1*ARPF2		
			POLAR12.R=GR1
			POLAR12.CST=GT1
			POLAR12.FI=GF1
			POLAR34.R=GR2
			POLAR34.CST=GT2
			POLAR34.FI=GF2
		END IF

! ---   LOS VALORES DE POLARES O ELIPSOIDALES GENERADOS LO SON RESPECTO A UN ORIGEN QUE
! ---   PUEDE CAMBIARSE MEDIANTE LAS TRANSFORMACIONES QUE SIGUEN:

		IF (DISTCENTROS12==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
			CALL POLAR2CAR(POLAR12,P12)	!PASO DE POLARES A CARTESIANAS
				
			P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
			P12.Y=P12.Y+PC12.Y
			P12.Z=P12.Z+PC12.Z

			Y1=YFUNC_GEN(NB1,NB2,P12,P1,P2)*POLAR12.R**2/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
		ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
			CALL SPHER2CAR(POLAR12,DISTCENTROS12,P12)	!PASO DE ELIPSOIDALES A CARTESIANAS
			
			P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
			P12.Y=P12.Y+PC12.Y
			P12.Z=P12.Z+PC12.Z
			
			Y1=YFUNC_GEN(NB1,NB2,P12,P1,P2)*(POLAR12.R**2-POLAR12.CST**2)*(DISTCENTROS12/2.Q0)**3/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
		ENDIF
		IF (DISTCENTROS34==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
			CALL POLAR2CAR(POLAR34,P34)	!PASO DE POLARES A CARTESIANAS
				
			P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
			P34.Y=P34.Y+PC34.Y
			P34.Z=P34.Z+PC34.Z

			Y2=YFUNC_GEN(NB3,NB4,P34,P3,P4)*POLAR34.R**2/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
		ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
			CALL SPHER2CAR(POLAR34,DISTCENTROS34,P34)	!PASO DE ELIPSOIDALES A CARTESIANAS
			
			P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
			P34.Y=P34.Y+PC34.Y
			P34.Z=P34.Z+PC34.Z
			
			Y2=YFUNC_GEN(NB3,NB4,P34,P3,P4)*(POLAR34.R**2-POLAR34.CST**2)*(DISTCENTROS34/2.Q0)**3/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
		ENDIF

		Y=Y1*Y2

! --- CALCULO DE LA DISTANCIA r12 :
		P.X=P34.X-P12.X
		P.Y=P34.Y-P12.Y
		P.Z=P34.Z-P12.Z
		RR=P.X*P.X+P.Y*P.Y+P.Z*P.Z
		IF(RR<=CERO)THEN
			IMAL=IMAL+1
			CYCLE
		ENDIF
		Y=Y/QSQRT(RR)
		DENOM=DENOM+1.Q0
		SSM=SSM+(Y-SSM)/DENOM
    ENDDO
		

	ANTOT=1.6Q1*PI*PI*CONSTNORM
	SSM=ANTOT*SSM
      
    RETURN
    END


!*********************************************************************
!****************** METODO DE HASELGROVE *****************************
!*********************************************************************

! --------------------------------------------------------------------
! ----- Cálculo por MONTECARLO de integrales monoelectronicas <p|A|q>
! ----- A= 1, X, T ,V   ¢ H=T+V   (FUNCIONES DE BASE SIN NORMALIZAR)
! ----- (NUMEROS DE HASELGROVE)
! ----- INCLUYE ESTIMACION DEL ERROR (BASTANTE GROSERA)
! --------------------------------------------------------------------
    SUBROUTINE MONOHAS_GEN(NB1,NB2,SSM,ER)
	USE ESTRUCT
	USE GLOBAL
	IMPLICIT NONE
    TYPE(RCSTFI)::POLAR
	TYPE(XYZ)::P,P1,P2,P12
	TYPE(DAT_METODO)::MET
	TYPE(XY)::PPOLIGR(1:INCREMENT+1),PPOLIGT(1:INCREMENT+1),PPOLIGF(1:INCREMENT+1)
	REAL*16 STRPOLIGR(INCREMENT),STRPOLIGT(INCREMENT),STRPOLIGF(INCREMENT)
	REAL*16 SPAR(10)
	INTEGER*4 NB1,NB2,IMAL,I,J,I10,IISEM,N10
    INTEGER*4 NRA2,NRA3,NRB2,NRB3
    REAL*16 RAIZ2,RAIZ3,RAIZ5,DNUMERO,HAS
	REAL*16 DISTCENTROS,CONSTNORM,Y0,Y1,Y2,Y3
    REAL*16 SSM,ER,VALPRE,DEN,YFUNC_GEN
    REAL*16 ARPR,AT,ARPT,ARPF,GGR,GR,W,GT,GF,WR,WT,WF,Y

	RAIZ2=QSQRT(2.Q0)
    RAIZ3=QSQRT(3.Q0)
    RAIZ5=QSQRT(5.Q0)

	P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z
	
! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		P12.X=P1.X
		P12.Y=P1.Y
		P12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		P12.X=(P1.X+P2.X)/2.Q0
		P12.Y=(P1.Y+P2.Y)/2.Q0
		P12.Z=(P1.Z+P2.Z)/2.Q0
	ENDIF

! -- CALCULO DE LA FUNCIÓN DE PESO	
	CALL FPESO_GEN(NB1,NB2,P1,P2,P12,ARPR,AT,ARPT,ARPF,PPOLIGR,PPOLIGT,PPOLIGF,STRPOLIGR,STRPOLIGT,STRPOLIGF)

! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS,Y0,Y1,Y2,Y3,EXP0,EXP1)

! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSM=0.Q0

! --ESTABLECE SI LA INTEGRAL SE PUEDE CONSIDERAR NULA (AHORRA TIEMPO)
	CALL PREPARA(NB1,NB2,P1,P2,P12,VALPRE,'RND',ARPR,AT,PPOLIGR,STRPOLIGR)
    IF(VALPRE<=CERO)THEN
		ER=0.Q0
		RETURN
	ENDIF

! ---------CALCULO MONTE CARLO: --------------------------------
	IISEM=ISEM

    DNUMERO=DFLOAT((IISEM-1)*NMC)
    N10=NMC/10
    DEN=0.Q0

    OUTER: DO I10=1,10
		INNER: DO I=1,N10
			IF (NPOLIG==0) THEN
				DNUMERO=DNUMERO+1.Q0
				GGR=HAS(RAIZ2,DNUMERO)
				IF(GGR<=0)THEN
					CYCLE INNER
				END IF
				GR=-QLOG(Y0-GGR*Y1)/EXP0
				W=EXP(-EXP0*GR)
				CONSTNORM=Y1/EXP0
				GT=HAS(RAIZ3,DNUMERO)
				GF=HAS(RAIZ5,DNUMERO)
				POLAR.R=GR
				POLAR.CST=1.Q0-2.*GT
				POLAR.FI=2.Q0*PI*GF
			ELSE IF(NPOLIG==1)THEN
				DNUMERO=DNUMERO+1.Q0
				MET.RAIZ=RAIZ2
				MET.DNUMERO=DNUMERO
				CALL INV_FDEN_R(IMAL,ARPR,AT,GR,WR,MET,PPOLIGR,STRPOLIGR,CLASMON,0)
				GT= HAS(RAIZ3,DNUMERO)
				GF=HAS(RAIZ5,DNUMERO)
				W=WR
				CONSTNORM=AT
				POLAR.R=GR
				POLAR.CST=1.Q0-2.*GT
				POLAR.FI=2.Q0*PI*GF
			ELSE IF (NPOLIG==2)THEN
				DNUMERO=DNUMERO+1.Q0
				MET.RAIZ=RAIZ2
				MET.DNUMERO=DNUMERO
				CALL INV_FDEN_R(IMAL,ARPR,AT,GR,WR,MET,PPOLIGR,STRPOLIGR,CLASMON,0)
				MET.RAIZ=RAIZ3
				CALL INV_FDEN_ANG(IMAL,ARPT,GT,WT,MET,PPOLIGT,STRPOLIGT,CLASMON,0)
				GF=HAS(RAIZ5,DNUMERO)
				W=WR*WT
				CONSTNORM=AT*ARPT
				POLAR.R=GR
				POLAR.CST=GT
				POLAR.FI=2.Q0*PI*GF
			ELSE IF (NPOLIG==3)THEN
				DNUMERO=DNUMERO+1.Q0
				MET.RAIZ=RAIZ2
				MET.DNUMERO=DNUMERO
				CALL INV_FDEN_R(IMAL,ARPR,AT,GR,WR,MET,PPOLIGR,STRPOLIGR,CLASMON,0)
				MET.RAIZ=RAIZ3
				CALL INV_FDEN_ANG(IMAL,ARPT,GT,WT,MET,PPOLIGT,STRPOLIGT,CLASMON,0)
				MET.RAIZ=RAIZ5
				CALL INV_FDEN_ANG(IMAL,ARPF,GF,WF,MET,PPOLIGF,STRPOLIGF,CLASMON,0)			
				W=WR*WT*WF
				CONSTNORM=AT*ARPT*ARPF
				POLAR.R=GR
				POLAR.CST=GT
				POLAR.FI=GF
			END IF
			
			IF (DISTCENTROS==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				CALL POLAR2CAR(POLAR,P)	!PASO DE POLARES A CARTESIANAS
					
				P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
				P.Y=P.Y+P12.Y
				P.Z=P.Z+P12.Z

				Y=YFUNC_GEN(NB1,NB2,P,P1,P2)*POLAR.R**2/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				CALL SPHER2CAR(POLAR,DISTCENTROS,P)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
				P.Y=P.Y+P12.Y
				P.Z=P.Z+P12.Z
				
				Y=YFUNC_GEN(NB1,NB2,P,P1,P2)*(POLAR.R**2-POLAR.CST**2)*(DISTCENTROS/2.Q0)**3/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ENDIF

			DEN=DEN+1.Q0
			SSM=SSM + (Y-SSM)/DEN
        ENDDO INNER
		SPAR(I10)=SSM
	ENDDO OUTER

	ER=0.Q0
    DO J=1,2
		ER= ER + QABS(SPAR(J)-SSM)*DFLOAT(J)/1.0Q01
	END DO
    ER=ER/2.0Q0

	SSM=4.Q0*PI*SSM*CONSTNORM
	ER=4.Q0*PI*ER*CONSTNORM

    RETURN
    END

! --------------------------------------------------------------------
! ----- Cálculo  por  MONTECARLO  de integrales (p q | r s).
! ----- (FUNCIONES DE BASE SIN NORMALIZAR)
! ----- (NUMEROS DE HASELGROVE)
! ----- P1,P2,P3,P4= COORDENADAS DE LOS CENTROS DE LAS FS. DE BASE.
! ----- PC12,PC34= COORDENADAS DE LOS CENTROS DE LAS FUNCIONES DE PESO.
! ----- ESTIMA EL ERROR, A PARTIR DE UNA PROGRESION DE *2* RESULTADOS 
! ----- INTERMEDIOS.
! --------------------------------------------------------------------
	SUBROUTINE BIELHAS_GEN(NB1,NB2,NB3,NB4,SSM,ER)
	USE GLOBAL
	USE ESTRUCT
    IMPLICIT NONE
    TYPE(DAT_METODO)::MET
	TYPE(RCSTFI)::POLAR12,POLAR34
	TYPE(XYZ)::P,P12,P34,P1,P2,P3,P4,PC12,PC34
	TYPE(XY)::PPOLIGR1(1:INCREMENT+1),PPOLIGR2(1:INCREMENT+1)
	TYPE(XY)::PPOLIGT1(1:INCREMENT+1),PPOLIGT2(1:INCREMENT+1)
	TYPE(XY)::PPOLIGF1(1:INCREMENT+1),PPOLIGF2(1:INCREMENT+1)
	REAL*16 STRPOLIGR1(INCREMENT),STRPOLIGR2(INCREMENT)
	REAL*16 STRPOLIGT1(INCREMENT),STRPOLIGT2(INCREMENT)
	REAL*16 STRPOLIGF1(INCREMENT),STRPOLIGF2(INCREMENT)
	REAL*16 DISTCENTROS12,DISTCENTROS34
    REAL*16 SPAR(10)
    INTEGER*4 NB1,NB2,NB3,NB4,IMAL,I,J,I10,N10
    REAL*16 RAIZ2,RAIZ3,RAIZ5,RAIZ7,RAIZ11,RAIZ13
    REAL*16 SSM,ER,VALPRE,DNUMERO,DENOM,CONSTNORM,YFUNC_GEN,ANTOT,HAS
    REAL*16 B12,B34,Y012,Y112,Y212,Y312,C12,Y034,Y134,Y234,Y334,C34,Y,Y1,Y2,RR
    REAL*16 ARPR1,AT1,ARPT1,ARPF1,ARPR2,AT2,ARPT2,ARPF2
    REAL*16 GGR1,GGR2,GR1,GR2,W1,W2,GT1,GF1,GT2,GF2,WR1,WR2,WT1,WT2,WF1,WF2
    
    RAIZ2=QSQRT(2.Q0)
    RAIZ3=QSQRT(3.Q0)
    RAIZ5=QSQRT(5.Q0)
    RAIZ7=QSQRT(7.Q0)
    RAIZ11=QSQRT(11.Q0)
    RAIZ13=QSQRT(1.3Q01)

	P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z
	P3.X=FB(NB3).X
	P3.Y=FB(NB3).Y
	P3.Z=FB(NB3).Z
	P4.X=FB(NB4).X
	P4.Y=FB(NB4).Y
	P4.Z=FB(NB4).Z

! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS12=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS12==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC12.X=P1.X
		PC12.Y=P1.Y
		PC12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC12.X=(P1.X+P2.X)/2.Q0
		PC12.Y=(P1.Y+P2.Y)/2.Q0
		PC12.Z=(P1.Z+P2.Z)/2.Q0
	ENDIF
	DISTCENTROS34=QSQRT((P3.X-P4.X)**2+(P3.Y-P4.Y)**2+(P3.Z-P4.Z)**2)
	IF (DISTCENTROS34==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC34.X=P3.X
		PC34.Y=P3.Y
		PC34.Z=P3.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC34.X=(P3.X+P4.X)/2.Q0
		PC34.Y=(P3.Y+P4.Y)/2.Q0
		PC34.Z=(P3.Z+P4.Z)/2.Q0
	ENDIF

! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSM=0.Q0
    
! -- CALCULA SI SE PUEDE CONSIDERAR NULA LA INTEGRAL (EN CASO DE NO SER UNA SOLA)
	IF (UNASOLA==1) THEN
		CALL PREPARA2(NB1,NB2,NB3,NB4,P1,P2,P3,P4,VALPRE)
		IF(VALPRE<=CERO)THEN
			ER=0.Q0
			RETURN
		ENDIF
	ENDIF

! -- CALCULO DE LA FUNCIÓN DE PESO	
	CALL FPESO_GEN(NB1,NB2,P1,P2,PC12,ARPR1,AT1,ARPT1,ARPF1,PPOLIGR1,PPOLIGT1,PPOLIGF1,STRPOLIGR1,STRPOLIGT1,STRPOLIGF1)
	B12=EXP0
	CALL FPESO_GEN(NB3,NB4,P3,P4,PC34,ARPR2,AT2,ARPT2,ARPF2,PPOLIGR2,PPOLIGT2,PPOLIGF2,STRPOLIGR2,STRPOLIGT2,STRPOLIGF2)
	B34=EXP0

! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS12,Y012,Y112,Y212,Y312,B12,C12)
	CALL CONSTNORMRECORT(NB3,NB4,DISTCENTROS34,Y034,Y134,Y234,Y334,B34,C34)

! ------- PARTE CENTRAL DEL CALCULO DE LA INTEGRAL ------------
	DENOM=0.Q0
    DNUMERO=DFLOAT((ISEM-1)*NMC)
    N10=NMC/10
    IMAL=0
	
	OUTER: DO I10=1,10
		INNER: DO I=1,N10
			IF (NPOLIG==0)THEN
				DNUMERO=DNUMERO+1.Q0
				GGR1=HAS(RAIZ2,DNUMERO)
				IF(GGR1<=0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GGR2=HAS(RAIZ3,DNUMERO)
				IF(GGR2<=0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GR1=-QLOG(Y012-GGR1*Y112)/B12
				GR2=-QLOG(Y034-GGR2*Y134)/B34
				W1=EXP(-B12*GR1)
				W2=EXP(-B34*GR2)
				CONSTNORM=(Y112*Y134)/(B12*B34)
				GT1=HAS(RAIZ5,DNUMERO)
				IF(GT1<=0.Q0.OR.GT1>1.Q0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF
				GF1=HAS(RAIZ7,DNUMERO)
				GT2=HAS(RAIZ11,DNUMERO)
				IF(GT2<=0.Q0.OR.GT2>1.Q0)THEN
					IMAL=IMAL+1
					CYCLE INNER
				END IF     
				GF2=HAS(RAIZ13,DNUMERO)     
				POLAR12.R=GR1
				POLAR12.CST=1.Q0-2.*GT1
				POLAR12.FI=2.Q0*PI*GF1
				POLAR34.R=GR2
				POLAR34.CST=1.Q0-2.*GT2
				POLAR34.FI=2.Q0*PI*GF2
			ELSE IF (NPOLIG==1) THEN
				DNUMERO=DNUMERO+1.Q0
				MET.DNUMERO=DNUMERO
				MET.RAIZ=RAIZ2
				CALL INV_FDEN_R(IMAL,ARPR1,AT1,GR1,WR1,MET,PPOLIGR1,STRPOLIGR1,CLASMON,0)
				MET.RAIZ=RAIZ3
				CALL INV_FDEN_R(IMAL,ARPR2,AT2,GR2,WR2,MET,PPOLIGR2,STRPOLIGR2,CLASMON,0)
				GT1=HAS(RAIZ5,DNUMERO)
				GF1=HAS(RAIZ7,DNUMERO)      
				GT2=HAS(RAIZ11,DNUMERO)     
				GF2=HAS(RAIZ13,DNUMERO)
				W1=WR1
				W2=WR2
				CONSTNORM=AT1*AT2
				POLAR12.R=GR1
				POLAR12.CST=1.Q0-2.*GT1
				POLAR12.FI=2.Q0*PI*GF1
				POLAR34.R=GR2
				POLAR34.CST=1.Q0-2.*GT2
				POLAR34.FI=2.Q0*PI*GF2
			ELSE IF (NPOLIG==2) THEN
				DNUMERO=DNUMERO+1.Q0
				MET.DNUMERO=DNUMERO
				MET.RAIZ=RAIZ2
				CALL INV_FDEN_R(IMAL,ARPR1,AT1,GR1,WR1,MET,PPOLIGR1,STRPOLIGR1,CLASMON,0)
				MET.RAIZ=RAIZ3
				CALL INV_FDEN_R(IMAL,ARPR2,AT2,GR2,WR2,MET,PPOLIGR2,STRPOLIGR2,CLASMON,0)
				MET.RAIZ=RAIZ5
				CALL INV_FDEN_ANG(IMAL,ARPT1,GT1,WT1,MET,PPOLIGT1,STRPOLIGT1,CLASMON,0)
				MET.RAIZ=RAIZ11
				CALL INV_FDEN_ANG(IMAL,ARPT2,GT2,WT2,MET,PPOLIGT2,STRPOLIGT2,CLASMON,0)
				GF1=HAS(RAIZ7,DNUMERO)
				GF2=HAS(RAIZ13,DNUMERO)
				W1=WR1*WT1
				W2=WR2*WT2
				CONSTNORM=AT1*AT2*ARPT1*ARPT2
				POLAR12.R=GR1
				POLAR12.CST=GT1
				POLAR12.FI=2.Q0*PI*GF1
				POLAR34.R=GR2
				POLAR34.CST=GT2
				POLAR34.FI=2.Q0*PI*GF2
			ELSE IF (NPOLIG==3) THEN
				DNUMERO=DNUMERO+1.Q0
				MET.DNUMERO=DNUMERO
				MET.RAIZ=RAIZ2
				CALL INV_FDEN_R(IMAL,ARPR1,AT1,GR1,WR1,MET,PPOLIGR1,STRPOLIGR1,CLASMON,0)
				MET.RAIZ=RAIZ3
				CALL INV_FDEN_R(IMAL,ARPR2,AT2,GR2,WR2,MET,PPOLIGR2,STRPOLIGR2,CLASMON,0)
				MET.RAIZ=RAIZ5
				CALL INV_FDEN_ANG(IMAL,ARPT1,GT1,WT1,MET,PPOLIGT1,STRPOLIGT1,CLASMON,0)
				MET.RAIZ=RAIZ7
				CALL INV_FDEN_ANG(IMAL,ARPF1,GF1,WF1,MET,PPOLIGF1,STRPOLIGF1,CLASMON,0)
				MET.RAIZ=RAIZ11
				CALL INV_FDEN_ANG(IMAL,ARPT2,GT2,WT2,MET,PPOLIGT2,STRPOLIGT2,CLASMON,0)
				MET.RAIZ=RAIZ13
				CALL INV_FDEN_ANG(IMAL,ARPF2,GF2,WF2,MET,PPOLIGF2,STRPOLIGF2,CLASMON,0)
				W1=WR1*WT1*WF1
				W2=WR2*WT2*WF2
				CONSTNORM=AT1*AT2*ARPT1*ARPT2*ARPF1*ARPF2					
				POLAR12.R=GR1
				POLAR12.CST=GT1
				POLAR12.FI=GF1
				POLAR34.R=GR2
				POLAR34.CST=GT2
				POLAR34.FI=GF2
			END IF

! ---   LOS VALORES DE POLARES O ELIPSOIDALES GENERADOS LO SON RESPECTO A UN ORIGEN QUE
! ---   PUEDE CAMBIARSE MEDIANTE LAS TRANSFORMACIONES QUE SIGUEN:

			IF (DISTCENTROS12==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				CALL POLAR2CAR(POLAR12,P12)	!PASO DE POLARES A CARTESIANAS
					
				P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
				P12.Y=P12.Y+PC12.Y
				P12.Z=P12.Z+PC12.Z

				Y1=YFUNC_GEN(NB1,NB2,P12,P1,P2)*POLAR12.R**2/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				CALL SPHER2CAR(POLAR12,DISTCENTROS12,P12)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
				P12.Y=P12.Y+PC12.Y
				P12.Z=P12.Z+PC12.Z
				
				Y1=YFUNC_GEN(NB1,NB2,P12,P1,P2)*(POLAR12.R**2-POLAR12.CST**2)*(DISTCENTROS12/2.Q0)**3/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ENDIF
			IF (DISTCENTROS34==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				CALL POLAR2CAR(POLAR34,P34)	!PASO DE POLARES A CARTESIANAS
					
				P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
				P34.Y=P34.Y+PC34.Y
				P34.Z=P34.Z+PC34.Z

				Y2=YFUNC_GEN(NB3,NB4,P34,P3,P4)*POLAR34.R**2/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				CALL SPHER2CAR(POLAR34,DISTCENTROS34,P34)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
				P34.Y=P34.Y+PC34.Y
				P34.Z=P34.Z+PC34.Z
				
				Y2=YFUNC_GEN(NB3,NB4,P34,P3,P4)*(POLAR34.R**2-POLAR34.CST**2)*(DISTCENTROS34/2.Q0)**3/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			ENDIF

			Y=Y1*Y2

! --- CALCULO DE LA DISTANCIA r12 :
			P.X=P34.X-P12.X
			P.Y=P34.Y-P12.Y
			P.Z=P34.Z-P12.Z
			RR=P.X*P.X+P.Y*P.Y+P.Z*P.Z
			IF(RR<=CERO)THEN
				IMAL=IMAL+1
				CYCLE INNER
			ENDIF
			Y=Y/QSQRT(RR)
			DENOM=DENOM+1.Q0
			SSM=SSM+(Y-SSM)/DENOM
        ENDDO INNER
		SPAR(I10)=SSM
	ENDDO OUTER

    ER=0.Q0
    DO J=1,2
		ER= ER + QABS(SPAR(J)-SSM)*DFLOAT(J)/1.0Q01
	END DO
	ER=ER/2.0Q0

	ANTOT=1.6Q1*PI*PI*CONSTNORM
	SSM=ANTOT*SSM
	ER=ANTOT*ER

    RETURN
    END

    
    
    
!*********************************************************************
!******CALCULO DE LAS FUNCIONES UTILIZADAS EN EL PROGRAMA*************
!*********************************************************************
! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DE UNA
! ---   FUNCION DE BASE EN UN PUNTO "R,TETA,FI".
! ---   AQUI SE SUPONE DE TIPO: 
! ---	F(r) * Yreal(teta,fi) * SIGMA(r)
! ---   CST=cos(teta)
! ---   NTIPO da la clase de parte angular
! -------------------------------------------------------------
    REAL*16 FUNCTION FBASE_GEN(NB,POL)
	USE GLOBAL
	USE ESTRUCT
    INTEGER*4 NB,I
	REAL*16 SIGMA,CALCFUNC,FACTANG,SFBASE_GEN

	TYPE (RCSTFI) :: POL

    FBASE_GEN=CALCFUNC(POL.R,CFUNC(NB))*FACTANG(FB(NB).NTF,POL.CST,POL.FI)
	IF(RECORT==1.OR.RECORT==2) THEN
		FBASE_GEN=FBASE_GEN*SIGMA(NB,POL.R)
    ENDIF
    
    RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL OPERADOR  T
! ---   APLICADO A UNA FUNCION DE BASE EN UN PUNTO "R,TETA,FI".
! ---   (CST ES EL COSENO DE TETA)
! -------------------------------------------------------------
    REAL*16 FUNCTION TBASE_GEN(NB,POL)
	USE GLOBAL
	USE ESTRUCT
	IMPLICIT NONE
	TYPE(RCSTFI)::POL !,POL1,POL2
	INTEGER*4 NB,L
    REAL*16 PRIMERAD,SEGUNDAD
    REAL*16 FBASE_GEN

    L=0
    IF(FB(NB).NTF>=1)L=1
    IF(FB(NB).NTF>=4)L=2
    IF(FB(NB).NTF>=9)L=3
    
	!POL1.R=POL.R+DELTA
	!POL1.CST=POL.CST
	!POL1.FI=POL.FI

	!POL2.R=POL.R-DELTA
	!POL2.CST=POL.CST
	!POL2.FI=POL.FI

	!PRIMERAD=DERIVA(NB,POL)
	!SEGUNDAD=(DERIVA(NB,POL1)-DERIVA(NB,POL2))/(2.Q0*DELTA)
    
	CALL DERIVA2_GEN(NB,POL,PRIMERAD,SEGUNDAD)

	!CALL RICHARD(NB,POL,DELTA,1,1,PRIMERAD)
	!CALL RICHARD(NB,POL,DELTA,1,2,SEGUNDAD)
	TBASE_GEN=SEGUNDAD+PRIMERAD*2.Q0/POL.R
    TBASE_GEN=TBASE_GEN-DFLOAT(L*(L+1))*FBASE_GEN(NB,POL)/POL.R**2
    TBASE_GEN=-0.5Q0*TBASE_GEN

	RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DE LA DERIVADA PRIMERA Y SEGUNDA
! ---   RESPECTO A R DE UNA FUNCION DE BASE EN UN PUNTO "R,TETA,FI".
! ---   CST=cos(teta)  
! ---   NTIPO da la clase de parte angular
! -------------------------------------------------------------
    SUBROUTINE DERIVA2_GEN(NB,P,DT1,DT2)
	USE GLOBAL
	USE ESTRUCT
	IMPLICIT REAL*16(A-H,O-Z)
	RECORD/RCSTFI/P,P1,P2
	REAL*16 D1,D2,DFR1,DFR2,DT1,DT2,RR
	INTEGER*4 NB
    REAL*16 DELTA
    
    DELTA=1.Q-6 
    
    P1.R=P.R+DELTA
	P1.CST=P.CST
	P1.FI=P.FI

    P2.R=P.R-DELTA
	P2.CST=P.CST
	P2.FI=P.FI

	IF (RECORT==0)THEN
		F0=FBASE_GEN(NB,P)
		F1=FBASE_GEN(NB,P1)
		F2=FBASE_GEN(NB,P2)
		DT1=(F1-F2)/(2.Q0*DELTA)
		DT2=(F1+F2-2.Q0*F0)/DELTA**2
	ELSEIF (RECORT==1) THEN
		RECORT=0  !ESTO SE HACE PARA QUE NO MULTIPLIQUE POR LA F. SIGMA
		F0=FBASE_GEN(NB,P)
		F1=FBASE_GEN(NB,P1)
		F2=FBASE_GEN(NB,P2)
		RECORT=1
		D1=(F1-F2)/(2.Q0*DELTA)
		D2=(F1+F2-2.Q0*F0)/DELTA**2
		DFR1=0.Q0
		DFR2=0.Q0
		IF(FB(NB).RECOR.TIPORECORT==0)THEN
			IF (P.R<FB(NB).RECOR.R1.AND.P.R>FB(NB).RECOR.R1-FB(NB).RECOR.D1) THEN
				RR=P.R-FB(NB).RECOR.R1
				DFR1=FB(NB).RECOR.COEF(1)+2.Q0*FB(NB).RECOR.COEF(2)*RR+3.Q0*FB(NB).RECOR.COEF(3)*RR*RR
				DFR2=2.Q0*FB(NB).RECOR.COEF(2)+6.Q0*FB(NB).RECOR.COEF(3)*RR
			ENDIF
		ELSEIF(FB(NB).RECOR.TIPORECORT==1)THEN
			IF (P.R>FB(NB).RECOR.R0.AND.P.R<FB(NB).RECOR.R0+FB(NB).RECOR.D0) THEN
				RR=P.R-FB(NB).RECOR.R0
				DFR1=FB(NB).RECOR.COEF(1)+2.Q0*FB(NB).RECOR.COEF(2)*RR+3.Q0*FB(NB).RECOR.COEF(3)*RR*RR
				DFR2=2.Q0*FB(NB).RECOR.COEF(2)+6.Q0*FB(NB).RECOR.COEF(3)*RR
			ENDIF
		ELSEIF(FB(NB).RECOR.TIPORECORT==2)THEN
			IF (P.R>FB(NB).RECOR.R0.AND.P.R<FB(NB).RECOR.R0+FB(NB).RECOR.D0) THEN
				RR=P.R-FB(NB).RECOR.R0
				DFR1=FB(NB).RECOR.COEF(1)+2.Q0*FB(NB).RECOR.COEF(2)*RR+3.Q0*FB(NB).RECOR.COEF(3)*RR*RR
				DFR2=2.Q0*FB(NB).RECOR.COEF(2)+6.Q0*FB(NB).RECOR.COEF(3)*RR
			ELSEIF (P.R<FB(NB).RECOR.R1.AND.P.R>FB(NB).RECOR.R1-FB(NB).RECOR.D1) THEN
				RR=P.R-FB(NB).RECOR.R1
				DFR1=FB(NB).RECOR.COEF(4)+2.Q0*FB(NB).RECOR.COEF(5)*RR+3.Q0*FB(NB).RECOR.COEF(6)*RR*RR
				DFR2=2.Q0*FB(NB).RECOR.COEF(5)+6.Q0*FB(NB).RECOR.COEF(6)*RR
			ENDIF
		ENDIF
		DT1=SIGMA(NB,P.R)*D1+F0*DFR1
		DT2=SIGMA(NB,P.R)*D2+F0*DFR2+2.Q0*D1*DFR1
	ELSEIF (RECORT==2) THEN
		RECORT=0	!ESTO SE HACE PARA QUE NO MULTIPLIQUE POR LA F. SIGMA
		F0=FBASE_GEN(NB,P)
		F1=FBASE_GEN(NB,P1)
		F2=FBASE_GEN(NB,P2)
		RECORT=2
		D1=(F1-F2)/(2.Q0*DELTA)
		D2=(F1+F2-2.Q0*F0)/DELTA**2
		DFR1=0.Q0
		DFR2=0.Q0
		IF(FB(NB).RECOR.TIPORECORT==0)THEN
			IF (P.R<FB(NB).RECOR.R1.AND.P.R>FB(NB).RECOR.R1-FB(NB).RECOR.D1) THEN
				RR=P.R-FB(NB).RECOR.R1
				DFR1=3.Q0*FB(NB).RECOR.COEF(1)*RR*RR+4.Q0*FB(NB).RECOR.COEF(2)*RR*RR*RR+5.Q0*FB(NB).RECOR.COEF(3)*RR*RR*RR*RR
				DFR2=6.Q0*FB(NB).RECOR.COEF(1)*RR+12.Q0*FB(NB).RECOR.COEF(2)*RR*RR+20.Q0*FB(NB).RECOR.COEF(3)*RR*RR*RR
			ENDIF
		ELSEIF(FB(NB).RECOR.TIPORECORT==1)THEN
			IF (P.R>FB(NB).RECOR.R0.AND.P.R<FB(NB).RECOR.R0+FB(NB).RECOR.D0) THEN
				RR=P.R-FB(NB).RECOR.R0
				DFR1=3.Q0*FB(NB).RECOR.COEF(1)*RR*RR+4.Q0*FB(NB).RECOR.COEF(2)*RR*RR*RR+5.Q0*FB(NB).RECOR.COEF(3)*RR*RR*RR*RR
				DFR2=6.Q0*FB(NB).RECOR.COEF(1)*RR+12.Q0*FB(NB).RECOR.COEF(2)*RR*RR+20.Q0*FB(NB).RECOR.COEF(3)*RR*RR*RR
			ENDIF
		ELSEIF(FB(NB).RECOR.TIPORECORT==2)THEN
			IF (P.R>FB(NB).RECOR.R0.AND.P.R<FB(NB).RECOR.R0+FB(NB).RECOR.D0) THEN
				RR=P.R-FB(NB).RECOR.R0
				DFR1=3.Q0*FB(NB).RECOR.COEF(1)*RR*RR+4.Q0*FB(NB).RECOR.COEF(2)*RR*RR*RR+5.Q0*FB(NB).RECOR.COEF(3)*RR*RR*RR*RR
				DFR2=6.Q0*FB(NB).RECOR.COEF(1)*RR+12.Q0*FB(NB).RECOR.COEF(2)*RR*RR+20.Q0*FB(NB).RECOR.COEF(3)*RR*RR*RR
			ELSEIF (P.R<FB(NB).RECOR.R1.AND.P.R>FB(NB).RECOR.R1-FB(NB).RECOR.D1) THEN
				RR=P.R-FB(NB).RECOR.R1
				DFR1=3.Q0*FB(NB).RECOR.COEF(4)*RR*RR+4.Q0*FB(NB).RECOR.COEF(5)*RR*RR*RR+5.Q0*FB(NB).RECOR.COEF(6)*RR*RR*RR*RR
				DFR2=6.Q0*FB(NB).RECOR.COEF(4)*RR+12.Q0*FB(NB).RECOR.COEF(5)*RR*RR+20.Q0*FB(NB).RECOR.COEF(6)*RR*RR*RR
			ENDIF
		ENDIF
		DT1=SIGMA(NB,P.R)*D1+F0*DFR1
		DT2=SIGMA(NB,P.R)*D2+F0*DFR2+2.Q0*D1*DFR1
	ENDIF

    RETURN
    END

! ----------------------------------------------------------------------
!     CALCULA LA DERIVADA DE UNA FUNCION F(X)
!     POR APROXIMACION PARABOLICA Y EXTRAPOLACION DE RICHARDSON 
! --------------------------------------------------------------------- 
    RECURSIVE SUBROUTINE RICHARD(NB,P,H,NPASOS,ORDEN,RES)
	USE ESTRUCT
    REAL*16 H,H2,HH,DERIVA,A,R1,R2,RES,DR1,DR2
    INTEGER*4 NPASOS,ORDEN
	TYPE(RCSTFI)::P,P1,P2
	INTEGER*4 NB,I

	IF (ORDEN==1) THEN
		A=1.Q0
		IF(NPASOS==0)THEN
			RES=DERIVA(NB,P)
			RETURN
		ENDIF

		DO I=1,NPASOS		
			A=4.Q0*A
			CALL RICHARD(NB,P,H,I-1,ORDEN,R1)
			H2=0.5Q0*H
			CALL RICHARD(NB,P,H2,I-1,ORDEN,R2)
			RES=(A*R2-R1)/(A-1.Q0)  
		ENDDO
	ELSEIF (ORDEN==2) THEN
		HH=H*10.Q0
		P1.R=P.R+HH
		P1.CST=P.CST
		P1.FI=P.FI
		CALL RICHARD(NB,P1,H,NPASOS,ORDEN-1,R1)
		P2.R=P.R-HH
		P2.CST=P.CST
		P2.FI=P.FI
		CALL RICHARD(NB,P2,H,NPASOS,ORDEN-1,R2)
		DR1=(R1-R2)/(2.Q0*HH)
		P1.R=P.R+HH/2.Q0
		CALL RICHARD(NB,P1,H,NPASOS,ORDEN-1,R1)
		P2.R=P.R-HH/2.Q0
		CALL RICHARD(NB,P2,H,NPASOS,ORDEN-1,R2)
		DR2=(R1-R2)/HH
		RES=(4.Q0*DR2-DR1)/3.Q0
	ENDIF
	   
	RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DE LA DERIVADA RESPECTO A R
! ---   DE UNA FUNCION DE BASE EN UN PUNTO "R,TETA,FI".
! ---   CST=cos(teta)  
! ---   NTIPO da la clase de parte angular
! -------------------------------------------------------------
    REAL*16 FUNCTION DERIVA(NB,P)
	USE GLOBAL
	USE ESTRUCT
	IMPLICIT REAL*16(A-H,O-Z)
	TYPE(RCSTFI)::P,P1,P2
	INTEGER*4 NB

    P1.R=P.R+DELTA
	P1.CST=P.CST
	P1.FI=P.FI

    P2.R=P.R-DELTA
	P2.CST=P.CST
	P2.FI=P.FI
	
	F1=FBASE_GEN(NB,P1)
	F2=FBASE_GEN(NB,P2)
	DERIVA=(F1-F2)/(2.Q0*DELTA)
	
    RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL PRODUCTO
! ---   "V" POR UNA FUNCION DE BASE.
! ---   (CST ES EL COSENO DE TETA)
! ---    EL PUNTO (R,CST,FI) ENTRA YA DEFINIDO RESPECTO AL
! ---    ORIGEN DE LA FUNCION DE BASE IMPLICADA,  PERO LAS
! ---    COORDENADAS NUCLEARES (entran respecto al origen)
! ---    SON TRASLADADAS POR EL SUBPROGRAMA.
! -------------------------------------------------------------
	REAL*16 FUNCTION VBASE_GEN(NB,POL,CENT)
	USE ESTRUCT
	USE GLOBAL
	IMPLICIT NONE
    TYPE(RCSTFI)::POL
	TYPE(XYZ)::P,CENT,PP0
	INTEGER*4 NB,K
    REAL*16 X0,Y0,Z0,FBASE_GEN
	  
	CALL POLAR2CAR(POL,P)
	
    VBASE_GEN=0.Q0
! --- CALCULO DE LAS COORDENADAS DE CADA NUCLEO RESPECTO AL 
! --- CENTRO DE LA SEGUNDA FUNCION DE BASE:
    IF(NUC==0)RETURN
	DO K=1,NUC
		PP0.X=NUCLEOS(K).X-CENT.X
		PP0.Y=NUCLEOS(K).Y-CENT.Y	!CENT ES EL CENTRO DEL POTENCIAL
		PP0.Z=NUCLEOS(K).Z-CENT.Z	
		X0=P.X-PP0.X
		Y0=P.Y-PP0.Y
		Z0=P.Z-PP0.Z 
		R0=QSQRT(X0*X0+Y0*Y0+Z0*Z0)   
		IF(R0<CERO)R0=CERO
		VBASE_GEN=VBASE_GEN-NUCLEOS(K).CARGA/R0
	END DO

    VBASE_GEN=VBASE_GEN*FBASE_GEN(NB,POL)

    RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL OPERADOR  H
! ---   APLICADO A UNA FUNCION DE BASE EN UN PUNTO "R,TETA,FI".
! ---   (CST ES EL COSENO DE TETA)
! -------------------------------------------------------------
    REAL*16 FUNCTION HBASE_GEN(NB,POL,CENT)
	USE ESTRUCT
	!USE GLOBAL
    IMPLICIT NONE
    TYPE(RCSTFI)::POL
	TYPE(XYZ)::CENT
    INTEGER*4 NB
	REAL*16 TBASE_GEN,VBASE_GEN

    HBASE_GEN=TBASE_GEN(NB,POL)+VBASE_GEN(NB,POL,CENT)
	
    RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL PRODUCTO
! ---   "X**Nx * Y**Ny * Z**Nz" POR UNA FUNCION DE BASE.
! ---   (CST ES EL COSENO DE TETA)
! ---    EL PUNTO (R,CST,FI) ENTRA YA DEFINIDO RESPECTO AL
! ---    ORIGEN DE LA FUNCION DE BASE IMPLICADA,  PERO LAS
! ---    COORDENADAS NUCLEARES TIENEN QUE SER TRASLADADAS.
! -------------------------------------------------------------
    REAL*16 FUNCTION XBASE_GEN(NB,POL,P)
    USE ESTRUCT
	!USE GLOBAL
	IMPLICIT NONE
	TYPE(XYZ)::P
	TYPE(RCSTFI)::POL
	INTEGER*4 NB
    REAL*16 FBASE_GEN
	
	XBASE_GEN=(P.X-P0.X)**NN.NX*(P.Y-P0.Y)**NN.NY*(P.Z-P0.Z)**NN.NZ
    XBASE_GEN=XBASE_GEN*FBASE_GEN(NB,POL)

    RETURN
    END


