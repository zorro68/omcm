! ******************************************************************
! ***  CALCULO DE LAS INTEGRALES POR LOS METODOS CUASIMONTECARLO
! ******************************************************************

! ------------------------------------------------------------------
! --- SUBRUTINA QUE CALCULA LAS INTEGRALES POR MONTECARLO
! ------------------------------------------------------------------
    SUBROUTINE INTCMC(FICHERO,MAT,NUMINT)
	USE ESTRUCT
	USE GLOBAL

	CHARACTER*(*) FICHERO
	CHARACTER*ILONG LEERVALOR
	INTEGER*4 MAT,NUMINT
	INTEGER*4 I
	REAL*16 CNOR,D

	!CERO=1.Q-24  
	!VALINF=1.Q15
	!PI=4.Q0*QATAN(1.Q0)

	IDIOMA=LEERVALOR('idioma.lng','Idioma','Idioma')
	
	CALL DEFINE_FICH(FICH.DAT,DIR.DAT,TRIM(FICHERO),'DAT')
	CALL LEEDAT() !LECTURA DEL FICHEO DE DATOS
    CALL DEFINE_FICH(FICH.INT,DIR.INT,TRIM(FICH.INT),'INT')
	CALL DEFINE_FICH(FICH.SCR,DIR.SCR,TRIM(FICHERO),'SCR')
	CALL DEFINE_FICH(FICH.AUX,DIR.AUX,TRIM(FICHERO),'AUX')
	

! ----CALCULA LOS COEFICIENTES DE LA CURVA RECORTADA
    IF (RECORT==1)THEN
		DO I=1,N
		    IF (FB(I).RECOR.TIPORECORT==0)THEN !(0,R1)
				D=FB(I).RECOR.D1
				FB(I).RECOR.COEF(1)=-3.Q0/D
				FB(I).RECOR.COEF(2)=-3.Q0/(D*D)
				FB(I).RECOR.COEF(3)=-1.Q0/(D*D*D)
			ELSEIF (FB(I).RECOR.TIPORECORT==1)THEN !(R0,INF)
				D=FB(I).RECOR.D0
				FB(I).RECOR.COEF(1)=3.Q0/D
				FB(I).RECOR.COEF(2)=-3.Q0/(D*D)
				FB(I).RECOR.COEF(3)=1.Q0/(D*D*D)
			ELSEIF (FB(I).RECOR.TIPORECORT==2)THEN !(R0,R1)
				D=FB(I).RECOR.D1
				FB(I).RECOR.COEF(1)=-3.Q0/D
				FB(I).RECOR.COEF(2)=-3.Q0/(D*D)
				FB(I).RECOR.COEF(3)=-1.Q0/(D*D*D)
				D=FB(I).RECOR.D0
				FB(I).RECOR.COEF(4)=3.Q0/D
				FB(I).RECOR.COEF(5)=-3.Q0/(D*D)
				FB(I).RECOR.COEF(6)=1.Q0/(D*D*D)
			ENDIF
		ENDDO
	ELSE IF (RECORT==2) THEN
		DO I=1,N
			IF (FB(I).RECOR.TIPORECORT==0)THEN !(0,R1)
				D=FB(I).RECOR.D1
				FB(I).RECOR.COEF(1)=-10.Q0/(D*D*D)
				FB(I).RECOR.COEF(2)=-15.Q0/(D*D*D*D)
				FB(I).RECOR.COEF(3)=-6.Q0/(D*D*D*D*D)
			ELSEIF (FB(I).RECOR.TIPORECORT==1)THEN !(R0,INF)
				D=FB(I).RECOR.D0
				FB(I).RECOR.COEF(1)=10.Q0/(D*D*D)
				FB(I).RECOR.COEF(2)=-15.Q0/(D*D*D*D)
				FB(I).RECOR.COEF(3)=6.Q0/(D*D*D*D*D)
			ELSEIF (FB(I).RECOR.TIPORECORT==2)THEN !(R0,R1)
				D=FB(I).RECOR.D1
				FB(I).RECOR.COEF(1)=-10.Q0/(D*D*D)
				FB(I).RECOR.COEF(2)=-15.Q0/(D*D*D*D)
				FB(I).RECOR.COEF(3)=-6.Q0/(D*D*D*D*D)
				D=FB(I).RECOR.D0
				FB(I).RECOR.COEF(4)=10.Q0/(D*D*D)
				FB(I).RECOR.COEF(5)=-15.Q0/(D*D*D*D)
				FB(I).RECOR.COEF(6)=6.Q0/(D*D*D*D*D)
			ENDIF
		ENDDO
    ENDIF

	!-----CODIFICA LAS FUNCIONES DE BASE PARA EL CALCULO
	IF (TIPOFB==0) THEN
        CALL INTCMC_GEN(MAT,NUMINT)
    ELSE
        IF(UNASOLA==1)THEN
		    CALL CALCULA_UNA
        ELSE
		    CALL CALCULA_TODAS(MAT,NUMINT)
	    ENDIF
    ENDIF
    
	RETURN
    END

! ------------------------------------------------------
!--------CALCULO DE UNA SOLA INTEGRAL-------------------
! ------------------------------------------------------
	SUBROUTINE CALCULA_UNA
	USE ESTRUCT
	USE GLOBAL
    IMPLICIT NONE
	REAL*16 VAL,VAL1,ER,CNOR
	CHARACTER*ILONG INTTOSTR,REALTOSTR,CADIDIOMA,LEERVALOR,CAD

	CADIDIOMA=LEERVALOR('idioma.lng',IDIOMA,'1210')
	CAD=' '
	CALL MENSAJES(CADIDIOMA,CAD,1.Q0)
	
	IF(SN1/=0)THEN
		FB(SN1).ANOR=CNOR(SN1)
	ENDIF
	IF (SN2/=0.AND.SN2/=SN1)THEN
		FB(SN2).ANOR=CNOR(SN2)
	ENDIF
	IF (SN3/=0.AND.(SN3/=SN2.AND.SN3/=SN1))THEN
		FB(SN3).ANOR=CNOR(SN3)
	ENDIF
	IF (SN4/=0.AND.(SN4/=SN3.AND.SN4/=SN2.AND.SN4/=SN1))THEN
		FB(SN4).ANOR=CNOR(SN4)
    ENDIF
	
	CADIDIOMA=LEERVALOR('idioma.lng',IDIOMA,'1211')
	IF(CLASINT=='J'.OR.CLASINT=='j')THEN
		WRITE(CAD,'(A1,2I2,A2,2I2,A1)')'(',SN1,SN2,' |',SN3,SN4,')'
	ELSEIF(CLASINT=='S'.OR.CLASINT=='s')THEN
		WRITE(CAD,'(A1,I2,A2,I2,A1)')'<',SN1,' |',SN2,'>'
	ELSE
		WRITE(CAD,'(A1,I2,A2,A,A1,I2,A1)')'<',SN1,' |',CLASINT,'|',SN2,'>'
	ENDIF	
	CALL MENSAJES(CADIDIOMA,CAD,50.Q0)
	
    CALL CALCULA(SN1,SN2,SN3,SN4,INTEGRAL,ERINTS)
	CALL ESCINT(0,0)

	CALL GUARDAVALOR(DIR.INT,'INTEGRALES','TipoInt',TRIM(CLASINT))
	CALL GUARDAVALOR(DIR.INT,'INTEGRALES','Indice1',INTTOSTR(SN1))
	CALL GUARDAVALOR(DIR.INT,'INTEGRALES','Indice2',INTTOSTR(SN2))
	CALL GUARDAVALOR(DIR.INT,'INTEGRALES','Indice3',INTTOSTR(SN3))
	CALL GUARDAVALOR(DIR.INT,'INTEGRALES','Indice4',INTTOSTR(SN4))
	CALL GUARDAVALOR(DIR.INT,'INTEGRALES','Integral',REALTOSTR(INTEGRAL))
	CALL GUARDAVALOR(DIR.INT,'INTEGRALES','Error',REALTOSTR(ERINTS))

	END 

! ------------------------------------------------------
! --------- SUBPROGRAMA PARA NORMALIZAR :
! ------------------------------------------------------
    REAL*16 FUNCTION CNOR(NB)
	USE ESTRUCT
	USE GLOBAL
	INTEGER*4 NB
    REAL*16 SS,ER
	CHARACTER*1 TIPO
    REAL*16 CNOR_HAM,CNOR_HAS,CNOR_HAL,CNOR_RND

	TIPO=CLASINT
	CLASINT='S'
    
    DO I=1,N  !NORMSFB==0 NO NORMALIZA LAS SUBFUNCIONES
        DO J=1,FB(I).NSFB
            FB(I).SFB(J).SCNOR=1.0Q0
        ENDDO
    ENDDO
    
    IF(CLASMON=='HAS')THEN
        IF (NORMSFB==0)THEN !NORMALIZA LAS SUBFUNCIONES
            DO I=1,N
                DO J=1,FB(I).NSFB
                    FB(I).SFB(J).SCNOR=CNOR_HAS(I,J)
                ENDDO
            ENDDO
        ENDIF
        CALL MONOHAS_SUM(NB,NB,SS,ER)
    ELSEIF(CLASMON=='HAL')THEN
        IF (NORMSFB==0)THEN !NORMALIZA LAS SUBFUNCIONES
            DO I=1,N
                DO J=1,FB(I).NSFB
                    FB(I).SFB(J).SCNOR=CNOR_HAL(I,J)
                ENDDO
            ENDDO
        ENDIF
        CALL MONOHAL_SUM(NB,NB,SS,ER) 
    ELSEIF(CLASMON=='HAM')THEN
        IF (NORMSFB==0)THEN !NORMALIZA LAS SUBFUNCIONES
            DO I=1,N
                DO J=1,FB(I).NSFB
                    FB(I).SFB(J).SCNOR=CNOR_HAM(I,J)
                ENDDO
            ENDDO
        ENDIF
        CALL MONOHAM_SUM(NB,NB,SS,ER) 
    ELSEIF(CLASMON=='RND')THEN
        IF (NORMSFB==0)THEN !NORMALIZA LAS SUBFUNCIONES
            DO I=1,N
                DO J=1,FB(I).NSFB
                    FB(I).SFB(J).SCNOR=CNOR_RND(I,J)
                ENDDO
            ENDDO
        ENDIF
        CALL MONORND_SUM(NB,NB,SS,ER)
    ENDIF

    CNOR=1.Q0/QSQRT(SS)
	CLASINT=TIPO
    
    RETURN
    END

! ---------------------------------------------------------------------
! --- SUBRUTINA QUE CALCULA LAS INTEGRALES POR MONTECARLO
! --- (TIENE EN CUENTA LAS CTES DE NORMALIZACION ANOR(I))
! ---------------------------------------------------------------------
	SUBROUTINE CALCULA(NB1,NB2,NB3,NB4,VALINT,ERINT)
    USE GLOBAL
	USE ESTRUCT
	IMPLICIT NONE
	INTEGER*4 NB1,NB2,NB3,NB4
    REAL*16 VAL,VAL1,ER,VALINT,ERINT
	
    
! ----------- CALCULO DE LAS INTEGRALES : -------------------------
	IF(CLASINT/='J')THEN
! ---  CALCULO HASELGROVE:       
		IF(CLASMON=='HAS')THEN
            CALL MONOHAS_SUM(NB1,NB2,VAL,ER)
		
! ---  CALCULO HALTON:
        ELSEIF(CLASMON=='HAL')THEN
            CALL MONOHAL_SUM(NB1,NB2,VAL,ER)
	   
! ---  CALCULO HAMMERSLEY:
		ELSEIF(CLASMON=='HAM')THEN
			CALL MONOHAM_SUM(NB1,NB2,VAL,ER)
			NMC=NMC/10
			CALL MONOHAM_SUM(NB1,NB2,VAL1,ER)
			NMC=NMC*10
			ER= 0.1Q0*QABS(VAL-VAL1)

! ---  CALCULO MONTECARLO ORDINARIO:
        ELSEIF(CLASMON=='RND')THEN
            CALL MONORND_SUM(NB1,NB2,VAL,ER)
        ENDIF

		VALINT=VAL*FB(NB1).ANOR*FB(NB2).ANOR
		ERINT=ER*FB(NB1).ANOR*FB(NB2).ANOR
	ENDIF

	IF(CLASINT=='J')THEN
! --- CALCULO HASELGROVE:
		IF(CLASMON=='HAS')THEN
            CALL BIELHAS_SUM(NB1,NB2,NB3,NB4,VAL,ER)

! ---  CALCULO HALTON:
        ELSEIF(CLASMON=='HAL')THEN
            CALL BIELHAL_SUM(NB1,NB2,NB3,NB4,VAL,ER)

! ---  CALCULO HAMMERSLEY Y ESTIMACION DEL ERROR:
		ELSEIF(CLASMON=='HAM')THEN
			CALL BIELHAM_SUM(NB1,NB2,NB3,NB4,VAL,ER)
			NMC=NMC/10
			CALL BIELHAM_SUM(NB1,NB2,NB3,NB4,VAL1,ER)
			NMC=NMC*10
			ER=0.1Q0*QABS(VAL-VAL1)

! --- CALCULO MONTECARLO ORDINARIO:
        ELSEIF(CLASMON=='RND')THEN 
            CALL BIELRND_SUM(NB1,NB2,NB3,NB4,VAL,ER)
        ENDIF

        VALINT=VAL*FB(NB1).ANOR*FB(NB2).ANOR*FB(NB3).ANOR*FB(NB4).ANOR
		ERINT=ER*FB(NB1).ANOR*FB(NB2).ANOR*FB(NB3).ANOR*FB(NB4).ANOR
    ENDIF
    RETURN
    END

! ---------------------------------------------------------------------
! --- SUBRUTINA QUE CALCULA TODAS LAS INTEGRALES POR MONTECARLO
! ---------------------------------------------------------------------
	SUBROUTINE CALCULA_TODAS(MAT,NUMINT)
	USE ESTRUCT
	USE GLOBAL
	INTEGER*4 MAT,NUMINT
	REAL*16 CNOR
	CHARACTER*ILONG CADIDIOMA,LEERVALOR,CAD

    IF(MAT==0)THEN
		CADIDIOMA=LEERVALOR('idioma.lng',IDIOMA,'1210')		
		CAD=' '
		CALL MENSAJES(CADIDIOMA,CAD,1.Q0)

		DO I=1,N
			FB(I).ANOR=CNOR(I)
        END DO
		CALL INTCMC_MONO(MAT)
    ELSEIF (MAT>0) THEN
		CALL LEEINT(MAT,NUMINT)
		CALL INTCMC_MONO(MAT)
    END IF

    IF(NEL>1.AND.MAT<=4)THEN
        CALL INTCMC_BI(MAT,NUMINT)
	ENDIF

	END

! ------------------------------------------------------------
! --------- SUBPROGRAMA PARA CALCULAR   S(p,q), H(p,q), X(p,q) 
! --------- Y(p,q) y Z(p,q) 
! ------------------------------------------------------------
	SUBROUTINE INTCMC_MONO(MAT)
	USE ESTRUCT
	USE GLOBAL
    IMPLICIT REAL*16(A-H,O-Z)
	CHARACTER*ILONG LEERVALOR,CADIDIOMA,CAD
	INTEGER*4 MAT
	
    TIEN=0.Q0
	TMONO=DBLE(7.Q0*N*(N+1)) !SON 7 TIPOS DE INTEGRALES MONO: S,T,V,H,X,Y,Z
	TBIEL=0.Q0
	IF (NEL>1)TBIEL=2.7Q0*DBLE(N_INT_BI) !CADA INTEGRAL BI TIENE UN PESO DE 2.7 VECES 2 MONO
	TTOTAL=TMONO+TBIEL
    
	CADIDIOMA=LEERVALOR('idioma.lng',IDIOMA,'1212')		
	
	IF(MAT<1)THEN
		CALL ESCINT(0,0)
	ENDIF
	
	IF(MAT<2)THEN
		ESMED=0.Q0
		ESMAX=0.Q0
		DENS=0.Q0  
		CLASINT='S'
		DO I=1,N
			DO J=I,N
				IF (I==J)THEN
					SS=1.0Q0
					ES=0.Q0
				ELSE
					CALL CALCULA(I,J,0,0,SS,ES)
				ENDIF
				S(INPQ_F(I,J))=SS
				IF(ES>ESMAX)ESMAX=ES
				DENS=DENS+1.Q0
				ESMED=ESMED + (ES-ESMED)/DENS
				TIEN=TIEN+2.0Q0
				PCTO=1.0Q2*TIEN/TTOTAL
				WRITE(CAD,'(A1,I2,A2,I2,A1,A,F5.1,A)')'<',I,' |',J,'>',' (',PCTO,'%)'
				CALL MENSAJES(CADIDIOMA,CAD,PCTO)
			ENDDO
		ENDDO
		!MAT=1
		CALL ESCINT(1,0)
	ENDIF
		
	IF(MAT<3)THEN
		ETMED=0.Q0
		ETMAX=0.Q0
		DENT=DFLOAT(N)
		CLASINT='T'
		DO I=1,N
			DO J=I,N
				CALL CALCULA(I,J,0,0,TT,ET)
				T(INPQ_F(I,J))=TT
				IF(ET>ETMAX)ETMAX=ET
				DENT=DENT+1.Q0
				ETMED=ETMED + (ET-ETMED)/DENT
				TIEN=TIEN+2.0Q0
				PCTO=1.0Q2*TIEN/TTOTAL
				WRITE(CAD,'(A1,I2,A2,A,A1,I2,A1,A,F5.1,A)')'<',I,' |',CLASINT,'|',J,'>',' (',PCTO,'%)'
				CALL MENSAJES(CADIDIOMA,CAD,PCTO)
			ENDDO
		ENDDO
		!MAT=2
		!CALL ESCINT(MAT,NUMINT)
		  
		EVMED=0.Q0
		EVMAX=0.Q0
		DENV=DFLOAT(N)
		CLASINT='V'
		DO I=1,N
			DO J=I,N
				CALL CALCULA(I,J,0,0,VV,EV)
				V(INPQ_F(I,J))=VV
				DENV=DENV+1.Q0
				EVMED=EVMED + (EV-EVMED)/DENV
				TIEN=TIEN+2.0Q0
				PCTO=1.0Q2*TIEN/TTOTAL
				WRITE(CAD,'(A1,I2,A2,A,A1,I2,A1,A,F5.1,A)')'<',I,' |',CLASINT,'|',J,'>',' (',PCTO,'%)'
				CALL MENSAJES(CADIDIOMA,CAD,PCTO)
			ENDDO
		ENDDO
		!MAT=2
		!CALL ESCINT(MAT,NUMINT)

		EHMED=0.Q0
		EHMAX=0.Q0
		DENH=DFLOAT(N)
		CLASINT='H'
		DO I=1,N
			DO J=I,N
				!CALL CALCULA(I,J,0,0,HH,EH)
				HH=T(INPQ_F(I,J))+V(INPQ_F(I,J))
				EH=ET+EV
				H(INPQ_F(I,J))=HH
				IF(EH>EHMAX)EHMAX=EH
				DENH=DENH+1.Q0
				EHMED=EHMED + (EH-EHMED)/DENH
				TIEN=TIEN+2.0Q0
				PCTO=1.0Q2*TIEN/TTOTAL
				WRITE(CAD,'(A1,I2,A2,A,A1,I2,A1,A,F5.1,A)')'<',I,' |',CLASINT,'|',J,'>',' (',PCTO,'%)'
				CALL MENSAJES(CADIDIOMA,CAD,PCTO)
			ENDDO
		ENDDO
		!MAT=2
		CALL ESCINT(2,0)
	ENDIF
	
	IF(MAT<4)THEN
		NN.NX=1
		NN.NY=0
		NN.NZ=0
		CLASINT='X'
		EXMED=0.Q0
		EXMAX=0.Q0
		DENX=DFLOAT(N)
		CLASINT='X'
		DO I=1,N
			DO J=I,N
				CALL CALCULA(I,J,0,0,XX,EX)
				!IF(ISNAN(XX))XX=0.Q0;EX=0.Q0 !PARA EVITAR QUE SE CUELGUE
				XMAT(INPQ_F(I,J))=XX
				IF(EX>EXMAX)EXMAX=EX
				DENX=DENX+1.Q0
				EXMED=EXMED + (EX-EXMED)/DENX
				IF(QABS(POT(1))>CERO)HH= HH - POT(1)*XX
				TIEN=TIEN+2.0Q0
				PCTO=1.0Q2*TIEN/TTOTAL
				WRITE(CAD,'(A1,I2,A2,A,A1,I2,A1,A,F5.1,A)')'<',I,' |',CLASINT,'|',J,'>',' (',PCTO,'%)'
				CALL MENSAJES(CADIDIOMA,CAD,PCTO)
			ENDDO
		ENDDO
		!MAT=3
		!CALL ESCINT(MAT,NUMINT)
			
		NN.NX=0
		NN.NY=1
		NN.NZ=0
		CLASINT='Y'
		EYMED=0.Q0
		EYMAX=0.Q0
		DENY=DFLOAT(N)
		CLASINT='Y'
		DO I=1,N
			DO J=I,N
				CALL CALCULA(I,J,0,0,YY,EY)
				!IF(ISNAN(YY))YY=0.Q0;EY=0.Q0 !PARA EVITAR QUE SE CUELGUE
				YMAT(INPQ_F(I,J))=YY
				IF(EY>EYMAX)EYMAX=EY
				DENY=DENY+1.Q0
				EYMED=EYMED + (EY-EYMED)/DENY
				IF(QABS(POT(2))>CERO)HH= HH - POT(2)*YY
				TIEN=TIEN+2.0Q0
				PCTO=1.0Q2*TIEN/TTOTAL
				WRITE(CAD,'(A1,I2,A2,A,A1,I2,A1,A,F5.1,A)')'<',I,' |',CLASINT,'|',J,'>',' (',PCTO,'%)'
				CALL MENSAJES(CADIDIOMA,CAD,PCTO)
			ENDDO
		ENDDO
		!MAT=3
		!CALL ESCINT(MAT,NUMINT)

		NN.NX=0
		NN.NY=0
		NN.NZ=1
		CLASINT='Z'
		EZMED=0.Q0
		EZMAX=0.Q0
		DENZ=DFLOAT(N)
		CLASINT='Z'
		DO I=1,N
			DO J=I,N
				CALL CALCULA(I,J,0,0,ZZ,EZ)
				!IF(ISNAN(ZZ))ZZ=0.Q0;EZ=0.Q0 !PARA EVITAR QUE SE CUELGUE
				ZMAT(INPQ_F(I,J))=ZZ
				IF(EZ>EZMAX)EZMAX=EZ
				DENZ=DENZ+1.Q0
				EZMED=EZMED + (EZ-EZMED)/DENZ
				IF(QABS(POT(3))>CERO)HH= HH - POT(3)*ZZ
				TIEN=TIEN+2.0Q0
				PCTO=1.0Q2*TIEN/TTOTAL
				WRITE(CAD,'(A1,I2,A2,A,A1,I2,A1,A,F5.1,A)')'<',I,' |',CLASINT,'|',J,'>',' (',PCTO,'%)'
				CALL MENSAJES(CADIDIOMA,CAD,PCTO)
			ENDDO
		ENDDO
		MAT=3
		CALL ESCINT(MAT,0)
	ENDIF
				
    RETURN
    END

! ---------------------------------------------------
! --------- SUBROGRAMA PARA CALCULAR (p,q|r,s) 
! --------- POR   M O N T E C A R L O.
! --------- (DESDE LA "NUMINT+1" HASTA LA "NN")
! ---------------------------------------------------
	SUBROUTINE INTCMC_BI(MAT,NUMINT)
	USE GLOBAL
	USE ESTRUCT
    IMPLICIT REAL*16(A-H,O-Z)    
	INTEGER*4 NUMINT,MAT,PASO,CONTPASO
	CHARACTER*ILONG LEERVALOR,CADIDIOMA,CAD
	
	CADIDIOMA=LEERVALOR('idioma.lng',IDIOMA,'1213')		
    
	ERMED=0.Q0
    ERMAX=0.Q0
    DEN=0.0Q0
    TMONO=DBLE(7.Q0*N*(N+1)) !SON 7 TIPOS DE INTEGRALES MONO: S,T,V,H,X,Y,Z
    TBIEL=0.Q0
	IF (NEL>1)TBIEL=2.7Q0*DBLE(N_INT_BI)
    TTOTAL=TMONO+TBIEL
    TIEN=TMONO
    NPQ=0
    K=0
    MAT=4
	PASO=N_INT_BI/N
	CONTPASO=0

    DO NQ=1,N
		DO NP=1,NQ
			NPQ=NPQ+1
			NRS=0
			DO NS=1,N
				DO NR=1,NS
					NRS=NRS+1
					IF(NRS>NPQ)GOTO 10
					K=K+1
					IF(K>NUMINT)THEN
						TIEN=TIEN+2.7Q0
						PCTO=1.Q02*TIEN/TTOTAL
						WRITE(CAD,'(A1,2I2,A2,2I2,A1,A,F5.1,A)')'(',NP,NQ,' |',NR,NS,')',' (',PCTO,'%)'
						CALL MENSAJES(CADIDIOMA,CAD,PCTO)

						CLASINT='J'
						CALL CALCULA(NP,NQ,NR,NS,RINT,ERINT)
						IF(ERINT>ERMAX)ERMAX=ERINT
						DEN=DEN+1.0Q0
						ERMED=ERMED+(ERINT-ERMED)/DEN
						R(K)=RINT

						NUMINT=K
						CONTPASO=CONTPASO+1
						IF(CONTPASO>PASO)THEN
							CONTPASO=0
							CALL ESCINT(MAT,NUMINT)
						ENDIF
					ENDIF
				ENDDO
			ENDDO
10		CONTINUE
		END DO
	END DO

	IF(CONTPASO>0)CALL ESCINT(MAT,NUMINT)

	RETURN 
    END

!****************************************************************************
!     FUNCIONES COMUNES A TODOS LOS MONTECARLOS
!****************************************************************************    
! ----------------------------------------------------------------------------
! SUBRUTINA QUE DEVUELVE ALGUNOS PARÁMETROS DEPENDIENDO SI ESTÁ RECORTADA O NO
! ----------------------------------------------------------------------------
	SUBROUTINE CONSTNORMRECORT(NB1,NB2,DISTCENTROS,Y0,Y1,Y2,Y3,EXPO,EXPO1)
	USE GLOBAL
	USE ESTRUCT
	INTEGER*4 NB1,NB2
	REAL*16 Y0,Y1,Y2,Y3,DISTCENTROS,EXPO,EXPO1

	IF (RECORT==0)THEN
		IF (DISTCENTROS==0.Q0) THEN !MONOCENTRICA
			Y0=1.Q0
			Y1=1.Q0
		ELSE !BICENTRICA
			Y0=QEXP(-EXPO)
			Y1=Y0
			Y2=QEXP(EXPO1)
			Y3=Y2-1.Q0/Y2
		ENDIF
	ELSEIF(RECORT==1.OR.RECORT==2) THEN !CASO DE RECORTADAS
		IF (FB(NB1).RECOR.TIPORECORT==0)THEN !SE SUPONE QUE TODAS TIENEN EL MISMO TIPO DE RECORTE
			IF(FB(NB1).RECOR.R1>=FB(NB2).RECOR.R1) THEN
				R1=FB(NB1).RECOR.R1
			ELSE
				R1=FB(NB2).RECOR.R1
			ENDIF
			IF (DISTCENTROS==0.Q0) THEN
				Y0=1.Q0
				Y1=1.Q0-QEXP(-EXPO*R1)
			ELSE
				Y0=QEXP(-EXPO)
				Y1=QEXP(-EXPO)-QEXP(-EXPO*R1)
			ENDIF
		ELSEIF (FB(NB1).RECOR.TIPORECORT==1)THEN
			IF(FB(NB1).RECOR.R0<=FB(NB2).RECOR.R0) THEN
				R0=FB(NB1).RECOR.R0
			ELSE
				R0=FB(NB2).RECOR.R0
			ENDIF
			Y0=QEXP(-EXPO*R0)
			Y1=Y0
		ELSEIF (FB(NB1).RECOR.TIPORECORT==2)THEN 
			IF(FB(NB1).RECOR.R0<=FB(NB2).RECOR.R0) THEN !EL MENOR DE LOS DOS R MENORES
				R0=FB(NB1).RECOR.R0
			ELSE
				R0=FB(NB2).RECOR.R0
			ENDIF
			IF(FB(NB1).RECOR.R1>=FB(NB2).RECOR.R1) THEN !EL MAYOR DE LOS DOS R MAYORES
				R1=FB(NB1).RECOR.R1
			ELSE
				R1=FB(NB2).RECOR.R1
			ENDIF
			!LO HACEMOS COMO EL CASO 0 => (0,R0)
			IF (DISTCENTROS==0.Q0) THEN
				Y0=1.Q0 
				Y1=1.Q0-QEXP(-EXPO*R1)
			ELSE
				Y0=QEXP(-EXPO)
				Y1=QEXP(-EXPO)-QEXP(-EXPO*R1)
			ENDIF
			!EL CASO GENERAL ES ESTE
			!Y0=QEXP(-EXPO*R0) 
			!Y1=QEXP(-EXPO*R0)-QEXP(-EXPO*R1)
		ENDIF
    ENDIF
	END


!--------------------------------------------------------------------
!  SUBROUTINE QUE CALCULA EL PRODUCTO F1*OP(F2)
!--------------------------------------------------------------------
    REAL*16 FUNCTION YFUNC(N1,NS1,N2,NS2,P,P1,P2)
    USE ESTRUCT
	USE GLOBAL
	INTEGER*4 N1,N2
    REAL*16 V1,V2,SFBASE,STBASE,SVBASE,SHBASE,SXBASE
	RECORD/RCSTFI/POLAR1,POLAR2
	RECORD/XYZ/P,PB1,PB2,P1,P2

! ---  CALCULO DE LAS COORDENADAS DEL ELECTRON
! ---  RESPECTO AL CENTRO DE  CADA FUNCION DE BASE:
    PB1.X=P.X-P1.X
    PB1.Y=P.Y-P1.Y
    PB1.Z=P.Z-P1.Z
    PB2.X=P.X-P2.X
    PB2.Y=P.Y-P2.Y
    PB2.Z=P.Z-P2.Z

! ---  PASO A POLARES:
    CALL CAR2POLAR(PB1,POLAR1)
	CALL CAR2POLAR(PB2,POLAR2)
		
! --- CALCULO DEL PRODUCTO P(1)*Q(1) (FALTA MULTIPLICAR POR EL ELEMENTO DE VOLUMEN/W)
	!V0=POLAR.R**2/W
	V1=SFBASE(N1,NS1,POLAR1)

	SELECT CASE (CLASINT)
		CASE ('S')
			V2=SFBASE(N2,NS2,POLAR2)
		CASE ('T')
			V2=STBASE(N2,NS2,POLAR2)
		CASE ('V')
			V2=SVBASE(N2,NS2,POLAR2,P2)
		CASE ('H')
			V2=SHBASE(N2,NS2,POLAR2,P2)
		CASE ('X','Y','Z')
			V2=SXBASE(N2,NS2,POLAR2,P)
		CASE ('J')
			V2=SFBASE(N2,NS2,POLAR2)
	END SELECT
	!IF(ISNAN(V2))V2=0.Q0 !PARA EVITAR QUE SE CUELGUE

	YFUNC=V1*V2

    END
    
    
    
!*********************************************************************
!****************** METODO MONTECARLO ********************************
!*********************************************************************

! --------------------------------------------------------------------
! ----- Cálculo por MONTECARLO de integrales monoelectronicas <p|A|q>
! ----- con  A= 1, T, V, o H=T+V  y FUNCIONES DE BASE SIN NORMALIZAR.
! ----- (NUMEROS PSEUDOALEATORIOS CONGRUENCIALES)
! ----- INCLUYE ESTIMACION DEL ERROR ( BASTANTE GROSERA)
! --------------------------------------------------------------------
	SUBROUTINE MONORND_SUM(NB1,NB2,SSMTOTAL,ERTOTAL)
    USE GLOBAL
	USE ESTRUCT
	IMPLICIT NONE
	TYPE(RCSTFI)::POLAR
	TYPE(XYZ)::P,P1,P2,P12
	TYPE(DAT_METODO)::MET
	REAL*16 SSM,SSMTOTAL,ER,ERTOTAL,DENOM,YFUNC,Y,RAN
	REAL*16 W,WR,GR,GT,GF,GGR
	REAL*16 SPAR(10)
	INTEGER*4 NB1,NB2,N10,IMAL,I,II,J,JJ,I10,IISEM
	REAL*16 DISTCENTROS,CONSTNORM,Y0,Y1,Y2,Y3

	P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z

! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		P12.X=P1.X
		P12.Y=P1.Y
		P12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		P12.X=(P1.X+P2.X)/2.Q0
		P12.Y=(P1.Y+P2.Y)/2.Q0
		P12.Z=(P1.Z+P2.Z)/2.Q0
    ENDIF


! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSMTOTAL=0.Q0
! -- PONE A CERO EL VALOR DEL ERROR DE LA INTEGRAL
    ERTOTAL=0.Q0

    DO II=1,FB(NB1).NSFB
        DO JJ=1,FB(NB2).NSFB
           
            ! -- CALCULO DE LA FUNCIÓN DE PESO
	        CALL FPESO(NB1,II,NB2,JJ,P1,P2,P12)

            ! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	        CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS,Y0,Y1,Y2,Y3,EXP0,EXP1)

! ---------CALCULO MONTE CARLO: --------------------------------
            IISEM=ISEM
	
            N10=NMC/10
	        IMAL=0
	        DENOM=0.Q0
            SSM=0.Q0
    
	        OUTER: DO I10=1,10
		        INNER: DO I=1,N10
			
			        GGR=RAN(IISEM)
			        IF(GGR<=0)THEN
				        IMAL=IMAL+1
				        CYCLE INNER
			        END IF
			        GR=-QLOG(Y0-GGR*Y1)/EXP0
			        W=EXP(-EXP0*GR)
			        CONSTNORM=Y1/EXP0
			        GT=RAN(IISEM)
	       	        IF(GT<=0.OR.GT>1.Q0)THEN
				        IMAL=IMAL+1
				        CYCLE INNER
			        END IF
			        GF=RAN(IISEM)
			        POLAR.R=GR
			        POLAR.CST=1.Q0-2.*GT
			        POLAR.FI=2.Q0*PI*GF
			
			        IF (DISTCENTROS==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				        CALL POLAR2CAR(POLAR,P)	!PASO DE POLARES A CARTESIANAS
					
				        P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
				        P.Y=P.Y+P12.Y
				        P.Z=P.Z+P12.Z

				        Y=YFUNC(NB1,II,NB2,JJ,P,P1,P2)*POLAR.R**2/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			        ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				        IF (EXP1/=0.Q0)THEN
					        POLAR.CST=-QLOG(Y2-GT*Y3)/EXP1
					        CONSTNORM=0.5Q0*CONSTNORM*Y3/EXP1 !EL 0.5 ES PORQUE DESPUES MULTIPLICAMOS POR 4PI Y EN ESTE CASO ES 2PI
					        W=W*EXP(-EXP1*POLAR.CST)
				        ENDIF
				        CALL SPHER2CAR(POLAR,DISTCENTROS,P)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				        P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
				        P.Y=P.Y+P12.Y
				        P.Z=P.Z+P12.Z
				
				        Y=YFUNC(NB1,II,NB2,JJ,P,P1,P2)*(POLAR.R**2-POLAR.CST**2)*(DISTCENTROS/2.Q0)**3/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			        ENDIF
			        DENOM=DENOM+1.Q0
			        SSM= SSM + (Y-SSM)/DENOM
                ENDDO INNER
		        SPAR(I10)=SSM
            END DO OUTER

            ER=0.Q0
            DO J=1,2
		        ER= ER + QABS(SPAR(J)-SSM)*DFLOAT(J)/1.0Q01
	        END DO
            ER=ER/2.0Q0
            
	        SSMTOTAL=SSMTOTAL+FB(NB1).SFB(II).SCNOR*FB(NB1).SFB(II).COEFICIENTE*FB(NB2).SFB(JJ).SCNOR*FB(NB2).SFB(JJ).COEFICIENTE*4.Q0*PI*SSM*CONSTNORM  !4*pi*constnorm es al cte normalización de la función densidad
            ERTOTAL=ERTOTAL+FB(NB1).SFB(II).SCNOR*FB(NB1).SFB(II).COEFICIENTE*FB(NB2).SFB(JJ).SCNOR*FB(NB2).SFB(JJ).COEFICIENTE*4.Q0*PI*ER*CONSTNORM
        ENDDO
    ENDDO
    
    RETURN
    END

! --------------------------------------------------------------------
! ----- Cálculo por MONTECARLO LAS CONSTANTES DE NORMALIZACION DE LAS SUBFUNCIONES
! ----- (NUMEROS PSEUDOALEATORIOS CONGRUENCIALES)
! ----- INCLUYE ESTIMACION DEL ERROR ( BASTANTE GROSERA)
! --------------------------------------------------------------------
	REAL*16 FUNCTION CNOR_RND(NB,NS)
    USE GLOBAL
	USE ESTRUCT
	IMPLICIT NONE
	TYPE(RCSTFI)::POLAR
	TYPE(XYZ)::P,P1,P2,P12
	TYPE(DAT_METODO)::MET
	REAL*16 SSM,DENOM,YFUNC,Y,RAN
	REAL*16 W,WR,GR,GT,GF,GGR
	INTEGER*4 NB,NS,N10,IMAL,I,II,J,JJ,I10,IISEM
	REAL*16 DISTCENTROS,CONSTNORM,Y0,Y1,Y2,Y3

	P1.X=FB(NB).X
	P1.Y=FB(NB).Y
	P1.Z=FB(NB).Z
	P2.X=FB(NB).X
	P2.Y=FB(NB).Y
	P2.Z=FB(NB).Z

    P12.X=P1.X
	P12.Y=P1.Y
	P12.Z=P1.Z
	
    ! -- CALCULO DE LA FUNCIÓN DE PESO
	CALL FPESO(NB,NS,NB,NS,P1,P2,P12)

    ! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	CALL CONSTNORMRECORT(NB,NB,DISTCENTROS,Y0,Y1,Y2,Y3,EXP0,EXP1)

! ---------CALCULO MONTE CARLO: --------------------------------
    IISEM=ISEM
	IMAL=0
	DENOM=0.Q0
    SSM=0.Q0
    
    DO I=1,NMC

        GGR=RAN(IISEM)
		IF(GGR<=0)THEN
			IMAL=IMAL+1
			CYCLE
		END IF
		GR=-QLOG(Y0-GGR*Y1)/EXP0
		W=EXP(-EXP0*GR)
		CONSTNORM=Y1/EXP0
		GT=RAN(IISEM)
	    IF(GT<=0.OR.GT>1.Q0)THEN
			IMAL=IMAL+1
			CYCLE
		END IF
		GF=RAN(IISEM)
		POLAR.R=GR
		POLAR.CST=1.Q0-2.*GT
		POLAR.FI=2.Q0*PI*GF
			
		CALL POLAR2CAR(POLAR,P)	!PASO DE POLARES A CARTESIANAS
					
		P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
		P.Y=P.Y+P12.Y
		P.Z=P.Z+P12.Z

		Y=YFUNC(NB,NS,NB,NS,P,P1,P2)*POLAR.R**2/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
		DENOM=DENOM+1.Q0
		SSM= SSM + (Y-SSM)/DENOM 
    END DO

    CNOR_RND=1.Q0/QSQRT(4.Q0*PI*SSM*CONSTNORM)
    
    RETURN
    END

    
! --------------------------------------------------------------------
! ----- Cálculo  por  MONTECARLO  de integrales (p q | r s).
! ----- FUNCIONES DE BASE SIN NORMALIZAR.
! ----- NUMEROS PSEUDOALEATORIOS TIPO "NUMERICAL RECIPES".
! ----- (EXPLICACIONES MAS COMPLETAS EN SUBROUTINE BIELHAS) 
! ----- INCLUYE ESTIMACION (GROSERA) DEL ERROR
! --------------------------------------------------------------------
	SUBROUTINE BIELRND_SUM(NB1,NB2,NB3,NB4,SSMTOTAL,ERTOTAL)
	USE GLOBAL
	USE ESTRUCT
    IMPLICIT NONE
    TYPE(DAT_METODO)::MET
	TYPE(RCSTFI)::POLAR12,POLAR34
	TYPE(XYZ)::P,P12,P34,P1,P2,P3,P4,PC12,PC34
    REAL*16 SPAR(10)
    REAL*16 SSM,ER,SSMTOTAL,ERTOTAL,DENOM,ANTOT,CONSTNORM,RAN
	REAL*16 DISTCENTROS12,DISTCENTROS34
    INTEGER*4 NB1,NB2,NB3,NB4,I,II,J,JJ,KK,LL,I10,N10,IMAL,IISEM
    REAL*16 B12,B34,C12,C34,Y012,Y112,Y212,Y312,Y034,Y134,Y234,Y334,Y1,Y2,Y,YFUNC
    REAL*16 GR1,GGR1,GR2,GGR2,W1,W2,GT1,GT2,GF1,GF2,RR

	P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z
	P3.X=FB(NB3).X
	P3.Y=FB(NB3).Y
	P3.Z=FB(NB3).Z
	P4.X=FB(NB4).X
	P4.Y=FB(NB4).Y
	P4.Z=FB(NB4).Z

! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS12=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS12==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC12.X=P1.X
		PC12.Y=P1.Y
		PC12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC12.X=(P1.X+P2.X)/2.Q0
		PC12.Y=(P1.Y+P2.Y)/2.Q0
		PC12.Z=(P1.Z+P2.Z)/2.Q0
	ENDIF
	DISTCENTROS34=QSQRT((P3.X-P4.X)**2+(P3.Y-P4.Y)**2+(P3.Z-P4.Z)**2)
	IF (DISTCENTROS34==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC34.X=P3.X
		PC34.Y=P3.Y
		PC34.Z=P3.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC34.X=(P3.X+P4.X)/2.Q0
		PC34.Y=(P3.Y+P4.Y)/2.Q0
		PC34.Z=(P3.Z+P4.Z)/2.Q0
    ENDIF

! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSMTOTAL=0.Q0
! -- PONE A CERO EL VALOR DEL ERROR DE LA INTEGRAL
    ERTOTAL=0.Q0

    DO II=1,FB(NB1).NSFB
        DO JJ=1,FB(NB2).NSFB
           DO KK=1,FB(NB3).NSFB
                DO LL=1,FB(NB4).NSFB
                    
                    ! -- CALCULO DE LA FUNCIÓN DE PESO
	                CALL FPESO(NB1,II,NB2,JJ,P1,P2,PC12)
                    B12=EXP0
	                C12=EXP1
	                CALL FPESO(NB3,KK,NB4,LL,P3,P4,PC34)
	                B34=EXP0
	                C34=EXP1

                    ! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	                CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS12,Y012,Y112,Y212,Y312,B12,C12)
	                CALL CONSTNORMRECORT(NB3,NB4,DISTCENTROS34,Y034,Y134,Y234,Y334,B34,C34)

                    ! ------- PARTE CENTRAL DEL CALCULO DE LA INTEGRAL ------------
                    N10=NMC/10
                    IMAL=0
	                IISEM=ISEM
	                DENOM=0.Q0
                    SSM=0.Q0
	                
                    OUTER: DO I10=1,10
		                INNER: DO I=1,N10
			                
				            GGR1=RAN(IISEM)
				            IF(GGR1<=0)THEN
					            IMAL=IMAL+1
					            CYCLE INNER
				            END IF
				            GGR2=RAN(IISEM)
				            IF(GGR2<=0)THEN
					            IMAL=IMAL+1
					            CYCLE INNER
				            END IF
				            GR1=-QLOG(Y012-GGR1*Y112)/B12
				            GR2=-QLOG(Y034-GGR2*Y134)/B34
				            W1=EXP(-B12*GR1)
				            W2=EXP(-B34*GR2)
				            CONSTNORM=(Y112*Y134)/(B12*B34)
				            GT1=RAN(IISEM)
				            IF(GT1<=0.OR.GT1>1.Q0)THEN
					            IMAL=IMAL+1
					            CYCLE INNER
				            END IF
				            GF1=RAN(IISEM)
				            GT2=RAN(IISEM)
				            IF(GT2<=0.OR.GT2>1.Q0)THEN
					            IMAL=IMAL+1
					            CYCLE INNER
				            END IF
				            GF2=RAN(IISEM)
				            POLAR12.R=GR1
				            POLAR12.CST=1.Q0-2.*GT1
				            POLAR12.FI=2.Q0*PI*GF1
				            POLAR34.R=GR2
				            POLAR34.CST=1.Q0-2.*GT2
				            POLAR34.FI=2.Q0*PI*GF2
			            
                            ! ---   LOS VALORES DE POLARES O ELIPSOIDALES GENERADOS LO SON RESPECTO A UN ORIGEN QUE
                            ! ---   PUEDE CAMBIARSE MEDIANTE LAS TRANSFORMACIONES QUE SIGUEN:

			                IF (DISTCENTROS12==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				                CALL POLAR2CAR(POLAR12,P12)	!PASO DE POLARES A CARTESIANAS
					
				                P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
				                P12.Y=P12.Y+PC12.Y
				                P12.Z=P12.Z+PC12.Z

				                Y1=YFUNC(NB1,II,NB2,JJ,P12,P1,P2)*POLAR12.R**2/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			                ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				                IF (C12/=0.Q0)THEN
					                POLAR12.CST=-QLOG(Y212-GT1*Y312)/C12
					                CONSTNORM=0.5Q0*CONSTNORM*Y112/B12 !EL 0.5 ES PORQUE DESPUES MULTIPLICAMOS POR 4PI Y EN ESTE CASO ES 2PI
					                W1=W1*EXP(-C12*POLAR12.CST)
				                ENDIF
				                CALL SPHER2CAR(POLAR12,DISTCENTROS12,P12)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				                P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
				                P12.Y=P12.Y+PC12.Y
				                P12.Z=P12.Z+PC12.Z
				
				                Y1=YFUNC(NB1,II,NB2,JJ,P12,P1,P2)*(POLAR12.R**2-POLAR12.CST**2)*(DISTCENTROS12/2.Q0)**3/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			                ENDIF
			                IF (DISTCENTROS34==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				                CALL POLAR2CAR(POLAR34,P34)	!PASO DE POLARES A CARTESIANAS
					
				                P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
				                P34.Y=P34.Y+PC34.Y
				                P34.Z=P34.Z+PC34.Z

				                Y2=YFUNC(NB3,KK,NB4,LL,P34,P3,P4)*POLAR34.R**2/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			                ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				                IF (C34/=0.Q0)THEN
					                POLAR34.CST=-QLOG(Y234-GT2*Y334)/C34
					                CONSTNORM=0.5Q0*CONSTNORM*Y134/B34 !EL 0.5 ES PORQUE DESPUES MULTIPLICAMOS POR 4PI Y EN ESTE CASO ES 2PI
					                W2=W2*EXP(-C34*POLAR34.CST)
				                ENDIF
				                CALL SPHER2CAR(POLAR34,DISTCENTROS34,P34)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				                P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
				                P34.Y=P34.Y+PC34.Y
				                P34.Z=P34.Z+PC34.Z
				
				                Y2=YFUNC(NB3,KK,NB4,LL,P34,P3,P4)*(POLAR34.R**2-POLAR34.CST**2)*(DISTCENTROS34/2.Q0)**3/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			                ENDIF

			                Y=Y1*Y2

                ! --- CALCULO DE LA DISTANCIA r12 :
			                P.X=P34.X-P12.X
			                P.Y=P34.Y-P12.Y
			                P.Z=P34.Z-P12.Z
			                RR=P.X*P.X+P.Y*P.Y+P.Z*P.Z
			                IF(RR<=CERO)THEN
				                IMAL=IMAL+1
				                CYCLE INNER
			                ENDIF
			                Y=Y/QSQRT(RR)
			                DENOM=DENOM+1.Q0
			                SSM=SSM+(Y-SSM)/DENOM
                		ENDDO INNER
		                SPAR(I10)=SSM
	                ENDDO	OUTER
	   
                    ER=0.Q0
                    DO J=1,2
		                ER= ER + QABS(SPAR(J)-SSM)*DFLOAT(J)/1.0Q01
	                END DO
                    ER=ER/2.0Q0
                    
                    SSMTOTAL=SSMTOTAL+FB(NB1).SFB(II).SCNOR*FB(NB1).SFB(II).COEFICIENTE*FB(NB2).SFB(JJ).SCNOR*FB(NB2).SFB(JJ).COEFICIENTE*FB(NB3).SFB(KK).SCNOR*FB(NB3).SFB(KK).COEFICIENTE*FB(NB4).SFB(LL).SCNOR*FB(NB4).SFB(LL).COEFICIENTE*SSM*CONSTNORM 
                    ERTOTAL=ERTOTAL+FB(NB1).SFB(II).SCNOR*FB(NB1).SFB(II).COEFICIENTE*FB(NB2).SFB(JJ).SCNOR*FB(NB2).SFB(JJ).COEFICIENTE*FB(NB3).SFB(KK).SCNOR*FB(NB3).SFB(KK).COEFICIENTE*FB(NB4).SFB(LL).SCNOR*FB(NB4).SFB(LL).COEFICIENTE*ER*CONSTNORM 
                ENDDO
           ENDDO
        ENDDO
    ENDDO

    ANTOT=1.6Q1*PI*PI
    SSMTOTAL=ANTOT*SSMTOTAL
    ERTOTAL=ANTOT*ERTOTAL
    
    RETURN
    END

!*********************************************************************
!****************** METODO DE HALTON *********************************
!*********************************************************************
! --------------------------------------------------------------------
! ----- Cálculo por MONTECARLO de integrales monoelectronicas <p|A|q>
! ----- con  A= 1,X,T,V, o H=T+V  y FUNCIONES DE BASE SIN NORMALIZAR.
! ----- (NUMEROS DE HALTON - NO ADMITEN SEMILLA VARIABLE)
! ----- INCLUYE ESTIMACION DEL ERROR ( BASTANTE GROSERA) 
! --------------------------------------------------------------------
	SUBROUTINE MONOHAL_SUM(NB1,NB2,SSMTOTAL,ERTOTAL)
	USE ESTRUCT
	USE GLOBAL
	IMPLICIT NONE
	TYPE(RCSTFI)::POLAR
	TYPE(XYZ)::P,P1,P2,P12
	TYPE(DAT_METODO)::MET,MET1,MET2
	REAL*16 SSM,SSMTOTAL,ER,ERTOTAL,DENOM,YFUNC,Y,HALTON
	REAL*16 W,GR,GT,GF,GGR
	REAL*16 SPAR(10)
	INTEGER*4 NB1,NB2,N10,IMAL,I,II,J,JJ,I10
    INTEGER*8 NRA2,NRA3,NRA5,NRB2,NRB3,NRB5
	REAL*16 DISTCENTROS,CONSTNORM,Y0,Y1,Y2,Y3
    
    P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z

! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		P12.X=P1.X
		P12.Y=P1.Y
		P12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		P12.X=(P1.X+P2.X)/2.Q0
		P12.Y=(P1.Y+P2.Y)/2.Q0
		P12.Z=(P1.Z+P2.Z)/2.Q0
    ENDIF

! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSMTOTAL=0.Q0
! -- PONE A CERO EL VALOR DEL ERROR DE LA INTEGRAL
    ERTOTAL=0.Q0
    
    DO II=1,FB(NB1).NSFB
        DO JJ=1,FB(NB2).NSFB
           
            ! -- CALCULO DE LA FUNCIÓN DE PESO
	        CALL FPESO(NB1,II,NB2,JJ,P1,P2,P12)
   
            ! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	        CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS,Y0,Y1,Y2,Y3,EXP0,EXP1)

            ! ---------CALCULO MONTE CARLO: --------------------------------
	        NRA2=0
            NRA3=0
            NRA5=0
            NRB2=1
            NRB3=1
            NRB5=1
            N10=NMC/10
            IMAL=0
            DENOM=0.Q0
            SSM=0.Q0

            MET.NUM=2
	        MET.NR1=NRA2
	        MET.NR2=NRB2
	        MET1.NUM=3
	        MET1.NR1=NRA3
	        MET1.NR2=NRB3
	        MET2.NUM=5
	        MET2.NR1=NRA5
	        MET2.NR2=NRB5
            
            OUTER: DO I10=1,10
		        INNER: DO I=1,N10
			        GGR=HALTON(2,NRA2,NRB2)
				    IF(GGR<=0)THEN
					    IMAL=IMAL+1
                        CYCLE INNER
				    END IF
				    GR=-QLOG(Y0-GGR*Y1)/EXP0
				    W=EXP(-EXP0*GR)
				    CONSTNORM=Y1/EXP0
				    GT=HALTON(3,NRA3,NRB3)  
				    IF(GT<=0.OR.GT>1.Q0)THEN
					    IMAL=IMAL+1
					    CYCLE INNER
				    END IF
				    GF=HALTON(5,NRA5,NRB5)
				    POLAR.R=GR
				    POLAR.CST=1.Q0-2.*GT
				    POLAR.FI=2.Q0*PI*GF
			        
			        IF (DISTCENTROS==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				        CALL POLAR2CAR(POLAR,P)	!PASO DE POLARES A CARTESIANAS
					
				        P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
				        P.Y=P.Y+P12.Y
				        P.Z=P.Z+P12.Z

				        Y=YFUNC(NB1,II,NB2,JJ,P,P1,P2)*POLAR.R**2/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			        ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				        CALL SPHER2CAR(POLAR,DISTCENTROS,P)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				        P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
				        P.Y=P.Y+P12.Y
				        P.Z=P.Z+P12.Z
				
				        Y=YFUNC(NB1,II,NB2,JJ,P,P1,P2)*(POLAR.R**2-POLAR.CST**2)*(DISTCENTROS/2.Q0)**3/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			        ENDIF

			        DENOM=DENOM+1.Q0
			        SSM= SSM + (Y-SSM)/DENOM
                ENDDO INNER
		        SPAR(I10)=SSM
	        ENDDO OUTER

            ER=0.Q0
            DO J=1,2
		        ER= ER + QABS(SPAR(J)-SSM)*DFLOAT(J)/1.0Q01
	        END DO
            ER=ER/2.0Q0

	        SSMTOTAL=SSMTOTAL+FB(NB1).SFB(II).SCNOR*FB(NB1).SFB(II).COEFICIENTE*FB(NB2).SFB(JJ).SCNOR*FB(NB2).SFB(JJ).COEFICIENTE*4.Q0*PI*SSM*CONSTNORM  !4*pi*constnorm es al cte normalización de la función densidad
            ERTOTAL=ERTOTAL+FB(NB1).SFB(II).SCNOR*FB(NB1).SFB(II).COEFICIENTE*FB(NB2).SFB(JJ).SCNOR*FB(NB2).SFB(JJ).COEFICIENTE*4.Q0*PI*ER*CONSTNORM
        ENDDO
    ENDDO
        
    RETURN
    END
    
! --------------------------------------------------------------------
! ----- Cálculo por MONTECARLO LAS CONSTANTES DE NORMALIZACION DE LAS SUBFUNCIONES
! ----- con  A= 1,X,T,V, o H=T+V  y FUNCIONES DE BASE SIN NORMALIZAR.
! ----- (NUMEROS DE HALTON - NO ADMITEN SEMILLA VARIABLE)
! ----- INCLUYE ESTIMACION DEL ERROR ( BASTANTE GROSERA) 
! --------------------------------------------------------------------
	REAL*16 FUNCTION CNOR_HAL(NB,NS)
	USE ESTRUCT
	USE GLOBAL
	IMPLICIT NONE
	TYPE(RCSTFI)::POLAR
	TYPE(XYZ)::P,P1,P2,P12
	TYPE(DAT_METODO)::MET,MET1,MET2
	REAL*16 SSM,DENOM,YFUNC,Y,HALTON
	REAL*16 W,GR,GT,GF,GGR
	INTEGER*4 NB,NS,IMAL,I,J
    INTEGER*8 NRA2,NRA3,NRA5,NRB2,NRB3,NRB5
	REAL*16 DISTCENTROS,CONSTNORM,Y0,Y1,Y2,Y3
    
    P1.X=FB(NB).X
	P1.Y=FB(NB).Y
	P1.Z=FB(NB).Z
	P2.X=FB(NB).X
	P2.Y=FB(NB).Y
	P2.Z=FB(NB).Z

	P12.X=P1.X
	P12.Y=P1.Y
	P12.Z=P1.Z

    ! -- CALCULO DE LA FUNCIÓN DE PESO
	CALL FPESO(NB,NS,NB,NS,P1,P2,P12)
   
    ! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	CALL CONSTNORMRECORT(NB,NB,DISTCENTROS,Y0,Y1,Y2,Y3,EXP0,EXP1)

    ! ---------CALCULO MONTE CARLO: --------------------------------
	NRA2=0
    NRA3=0
    NRA5=0
    NRB2=1
    NRB3=1
    NRB5=1
    IMAL=0
    DENOM=0.Q0
    SSM=0.Q0

    MET.NUM=2
	MET.NR1=NRA2
	MET.NR2=NRB2
	MET1.NUM=3
	MET1.NR1=NRA3
	MET1.NR2=NRB3
	MET2.NUM=5
	MET2.NR1=NRA5
	MET2.NR2=NRB5
            
            
	DO I=1,NMC
		GGR=HALTON(2,NRA2,NRB2)
		IF(GGR<=0)THEN
			IMAL=IMAL+1
            CYCLE 
		END IF
		GR=-QLOG(Y0-GGR*Y1)/EXP0
		W=EXP(-EXP0*GR)
		CONSTNORM=Y1/EXP0
		GT=HALTON(3,NRA3,NRB3)  
		IF(GT<=0.OR.GT>1.Q0)THEN
			IMAL=IMAL+1
			CYCLE 
		END IF
		GF=HALTON(5,NRA5,NRB5)
		POLAR.R=GR
		POLAR.CST=1.Q0-2.*GT
		POLAR.FI=2.Q0*PI*GF
			        
			       
		CALL POLAR2CAR(POLAR,P)	!PASO DE POLARES A CARTESIANAS
					
		P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
		P.Y=P.Y+P12.Y
		P.Z=P.Z+P12.Z

		Y=YFUNC(NB,NS,NB,NS,P,P1,P2)*POLAR.R**2/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			        
		DENOM=DENOM+1.Q0
		SSM= SSM + (Y-SSM)/DENOM
    ENDDO 

    CNOR_HAL=1.Q0/QSQRT(4.Q0*PI*SSM*CONSTNORM)
    
    RETURN
    END

! --------------------------------------------------------------------
! ----- Cálculo  por  MONTECARLO  de integrales (p q | r s).
! ----- (FUNCIONES DE BASE SIN NORMALIZAR)
! ----- (NUMEROS DE HALTON)
! ----- atencion:  Los numeros de Halton NO admiten semilla.
! ----- INCLUYE ESTIMACION DEL ERROR ( BASTANTE GROSERA) 
! ----- (EXPLICACIONES MAS COMPLETAS EN SUBROUTINE BIELHAS)
! --------------------------------------------------------------------
	SUBROUTINE BIELHAL_SUM(NB1,NB2,NB3,NB4,SSMTOTAL,ERTOTAL)
	USE GLOBAL
	USE ESTRUCT
    IMPLICIT NONE
	TYPE(DAT_METODO)::MET,MET1,MET2,MET3,MET4,MET5
	TYPE(RCSTFI)::POLAR12,POLAR34
	TYPE(XYZ)::P,P12,P34,P1,P2,P3,P4,PC12,PC34
    REAL*16 SPAR(10)
    REAL*16 SSM,SSMTOTAL,ER,ERTOTAL,DENOM,ANTOT,CONSTNORM,HALTON,AL,DELT
	INTEGER*4 NB1,NB2,NB3,NB4,I,II,J,JJ,KK,LL,I10,N10,IMAL
    INTEGER*8 NRA2,NRA3,NRA5,NRA7,NRA11,NRA13,NRB2,NRB3,NRB5,NRB7,NRB11,NRB13
    REAL*16 B12,B34,C12,C34,Y012,Y112,Y212,Y312,Y034,Y134,Y234,Y334,Y1,Y2,Y,YFUNC
    REAL*16 GR1,GGR1,GR2,GGR2,W1,W2,GT1,GT2,GF1,GF2,RR
    REAL*16 DISTCENTROS12,DISTCENTROS34
        
	P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z
	P3.X=FB(NB3).X
	P3.Y=FB(NB3).Y
	P3.Z=FB(NB3).Z
	P4.X=FB(NB4).X
	P4.Y=FB(NB4).Y
	P4.Z=FB(NB4).Z

! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS12=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS12==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC12.X=P1.X
		PC12.Y=P1.Y
		PC12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC12.X=(P1.X+P2.X)/2.Q0
		PC12.Y=(P1.Y+P2.Y)/2.Q0
		PC12.Z=(P1.Z+P2.Z)/2.Q0
	ENDIF
	DISTCENTROS34=QSQRT((P3.X-P4.X)**2+(P3.Y-P4.Y)**2+(P3.Z-P4.Z)**2)
	IF (DISTCENTROS34==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC34.X=P3.X
		PC34.Y=P3.Y
		PC34.Z=P3.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC34.X=(P3.X+P4.X)/2.Q0
		PC34.Y=(P3.Y+P4.Y)/2.Q0
		PC34.Z=(P3.Z+P4.Z)/2.Q0
	ENDIF

! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSMTOTAL=0.Q0
! -- PONE A CERO EL VALOR DEL ERROR DE LA INTEGRAL
    ERTOTAL=0.Q0

    DO II=1,FB(NB1).NSFB
        DO JJ=1,FB(NB2).NSFB
           DO KK=1,FB(NB3).NSFB
                DO LL=1,FB(NB4).NSFB

                ! -- CALCULO DE LA FUNCIÓN DE PESO	
                    CALL FPESO(NB1,II,NB2,JJ,P1,P2,PC12)
                    B12=EXP0
	                C12=EXP1
	                CALL FPESO(NB3,KK,NB4,LL,P3,P4,PC34)
	                B34=EXP0
	                C34=EXP1
	                
                ! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	                CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS12,Y012,Y112,Y212,Y312,B12,C12)
	                CALL CONSTNORMRECORT(NB3,NB4,DISTCENTROS34,Y034,Y134,Y234,Y334,B34,C34)

                ! ------- PARTE CENTRAL DEL CALCULO DE LA INTEGRAL ------------
                    NRA2=0
                    NRA3=0
                    NRA5=0
                    NRB2=1
                    NRB3=1
                    NRB5=1
                    NRA7=0
                    NRA11=0
                    NRA13=0
                    NRB7=1
                    NRB11=1
                    NRB13=1
                    N10=NMC/10
                    DENOM=0.Q0
                    IMAL=0
                    SSM=0.Q0

	                MET.NUM=2
	                MET.NR1=NRA2
	                MET.NR2=NRB2
	                MET1.NUM=3
	                MET1.NR1=NRA3
	                MET1.NR2=NRB3
	                MET2.NUM=5
	                MET2.NR1=NRA5
	                MET2.NR2=NRB5
	                MET3.NUM=7
	                MET3.NR1=NRA7
	                MET3.NR2=NRB7
	                MET4.NUM=11
	                MET4.NR1=NRA11
	                MET4.NR2=NRB11
	                MET5.NUM=13
	                MET5.NR1=NRA13
	                MET5.NR2=NRB13
    
	                OUTER: DO I10=1,10
		                INNER: DO I=1,N10
                            GGR1=HALTON(2,NRA2,NRB2)
				            IF(GGR1<=0)THEN
					            IMAL=IMAL+1
					            CYCLE INNER
				            END IF
				            GGR2=HALTON(3,NRA3,NRB3)
				            IF(GGR2<=0)THEN
					            IMAL=IMAL+1
					            CYCLE INNER
				            END IF
				            GR1=-QLOG(Y012-GGR1*Y112)/B12
				            GR2=-QLOG(Y034-GGR2*Y134)/B34
				            W1=EXP(-B12*GR1)
				            W2=EXP(-B34*GR2)
				            CONSTNORM=(Y112*Y134)/(B12*B34)
				            GT1=HALTON(5,NRA5,NRB5)
				            IF(GT1<=0.OR.GT1>1.Q0)THEN
					            IMAL=IMAL+1
					            CYCLE INNER
				            END IF
				            GF1=HALTON(7,NRA7,NRB7)
				            GT2=HALTON(11,NRA11,NRB11)
				            IF(GT2<=0.OR.GT2>1.Q0)THEN
					            IMAL=IMAL+1
					            CYCLE INNER
				            END IF
				            GF2=HALTON(13,NRA13,NRB13)
				            POLAR12.R=GR1
				            POLAR12.CST=1.Q0-2.*GT1
				            POLAR12.FI=2.Q0*PI*GF1
				            POLAR34.R=GR2
				            POLAR34.CST=1.Q0-2.*GT2
				            POLAR34.FI=2.Q0*PI*GF2
			                
                ! ---   LOS VALORES DE POLARES O ELIPSOIDALES GENERADOS LO SON RESPECTO A UN ORIGEN QUE
                ! ---   PUEDE CAMBIARSE MEDIANTE LAS TRANSFORMACIONES QUE SIGUEN:

			                IF (DISTCENTROS12==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				                CALL POLAR2CAR(POLAR12,P12)	!PASO DE POLARES A CARTESIANAS
					
				                P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
				                P12.Y=P12.Y+PC12.Y
				                P12.Z=P12.Z+PC12.Z

				                Y1=YFUNC(NB1,II,NB2,JJ,P12,P1,P2)*POLAR12.R**2/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			                ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				                CALL SPHER2CAR(POLAR12,DISTCENTROS12,P12)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				                P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
				                P12.Y=P12.Y+PC12.Y
				                P12.Z=P12.Z+PC12.Z
				
				                Y1=YFUNC(NB1,II,NB2,JJ,P12,P1,P2)*(POLAR12.R**2-POLAR12.CST**2)*(DISTCENTROS12/2.Q0)**3/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			                ENDIF
			                IF (DISTCENTROS34==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				                CALL POLAR2CAR(POLAR34,P34)	!PASO DE POLARES A CARTESIANAS
					
				                P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
				                P34.Y=P34.Y+PC34.Y
				                P34.Z=P34.Z+PC34.Z

				                Y2=YFUNC(NB3,KK,NB4,LL,P34,P3,P4)*POLAR34.R**2/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			                ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				                CALL SPHER2CAR(POLAR34,DISTCENTROS34,P34)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				                P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
				                P34.Y=P34.Y+PC34.Y
				                P34.Z=P34.Z+PC34.Z
				
				                Y2=YFUNC(NB3,KK,NB4,LL,P34,P3,P4)*(POLAR34.R**2-POLAR34.CST**2)*(DISTCENTROS34/2.Q0)**3/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			                ENDIF

			                Y=Y1*Y2

                ! --- CALCULO DE LA DISTANCIA r12 :
			                P.X=P34.X-P12.X
			                P.Y=P34.Y-P12.Y
			                P.Z=P34.Z-P12.Z
			                RR=P.X*P.X+P.Y*P.Y+P.Z*P.Z
			                IF(RR<=CERO)THEN
				                IMAL=IMAL+1
				                CYCLE INNER
			                ENDIF
			                Y=Y/QSQRT(RR)
			                DENOM=DENOM+1.Q0
			                SSM=SSM+(Y-SSM)/DENOM
                	    ENDDO INNER
                        SPAR(I10)=SSM
                    ENDDO	OUTER
		        
                    ER=0.Q0
                    DO J=1,2
		                ER= ER + QABS(SPAR(J)-SSM)*DFLOAT(J)/1.0Q01
	                END DO
	                ER=ER/2.0Q0
                    
                    SSMTOTAL=SSMTOTAL+FB(NB1).SFB(II).SCNOR*FB(NB1).SFB(II).COEFICIENTE*FB(NB2).SFB(JJ).SCNOR*FB(NB2).SFB(JJ).COEFICIENTE*FB(NB3).SFB(KK).SCNOR*FB(NB3).SFB(KK).COEFICIENTE*FB(NB4).SFB(LL).SCNOR*FB(NB4).SFB(LL).COEFICIENTE*SSM*CONSTNORM 
                    ERTOTAL=ERTOTAL+FB(NB1).SFB(II).SCNOR*FB(NB1).SFB(II).COEFICIENTE*FB(NB2).SFB(JJ).SCNOR*FB(NB2).SFB(JJ).COEFICIENTE*FB(NB3).SFB(KK).SCNOR*FB(NB3).SFB(KK).COEFICIENTE*FB(NB4).SFB(LL).SCNOR*FB(NB4).SFB(LL).COEFICIENTE*ER*CONSTNORM 
                ENDDO
           ENDDO
        ENDDO
    ENDDO
    
	ANTOT=1.6Q1*PI*PI
	SSMTOTAL=ANTOT*SSMTOTAL
    ERTOTAL=ANTOT*ERTOTAL
      
    RETURN
    END
       

!*********************************************************************
!****************** METODO DE HAMMERSLEY *****************************
!*********************************************************************

! --------------------------------------------------------------------
! ----- CAlculo por MONTECARLO de integrales monoelectronicas <p|A|q>
! ----- con  A= 1,X,T,V, o H=T+V  y FUNCIONES DE BASE SIN NORMALIZAR.
! ----- (NUMEROS DE HAMMERSLEY)
! --------------------------------------------------------------------
	SUBROUTINE MONOHAM_SUM(NB1,NB2,SSMTOTAL,ERTOTAL)
	USE ESTRUCT
	USE GLOBAL
	IMPLICIT NONE
	TYPE(RCSTFI)::POLAR
	TYPE(XYZ)::P,P1,P2,P12
	TYPE(DAT_METODO)::MET,MET1
	REAL*16 SSM,SSMTOTAL,ERTOTAL,DENOM,YFUNC,Y,HALTON,AL,DELT
    REAL*16 W,WR,GR,GT,GF,GGR
    INTEGER*4 NB1,NB2,IMAL,I,II,JJ
    INTEGER*8 NRA2,NRA3,NRB2,NRB3
	REAL*16 DISTCENTROS,CONSTNORM,Y0,Y1,Y2,Y3
    

	P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z

! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		P12.X=P1.X
		P12.Y=P1.Y
		P12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		P12.X=(P1.X+P2.X)/2.Q0
		P12.Y=(P1.Y+P2.Y)/2.Q0
		P12.Z=(P1.Z+P2.Z)/2.Q0
    ENDIF

! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSMTOTAL=0.Q0
! -- PONE A CERO EL VALOR DEL ERROR DE LA INTEGRAL
    ERTOTAL=0.Q0
    
    DO II=1,FB(NB1).NSFB
        DO JJ=1,FB(NB2).NSFB
           
            ! -- CALCULO DE LA FUNCIÓN DE PESO
	        CALL FPESO(NB1,II,NB2,JJ,P1,P2,P12)
    
            ! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	        CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS,Y0,Y1,Y2,Y3,EXP0,EXP1)
  
! ---------CALCULO MONTE CARLO: --------------------------------
            NRA2=0
            NRA3=0
            NRB2=1
            NRB3=1
            AL=CERO
            DELT=1.Q0/DFLOAT(NMC)
            IMAL=0
            DENOM=0.Q0
            SSM=0.Q0


            MET.NUM=2
	        MET.NR1=NRA2
	        MET.NR2=NRB2
	        MET1.NUM=3
	        MET1.NR1=NRA3
	        MET1.NR2=NRB3
	
           DO I=1,NMC-1
		        AL=AL+DELT
		        GGR=AL
			    GR=-QLOG(Y0-GGR*Y1)/EXP0
			    W=EXP(-EXP0*GR)
			    CONSTNORM=Y1/EXP0
			    GT=HALTON(2,NRA2,NRB2)
			    IF(GT<=0.OR.GT>1.Q0)THEN
				    IMAL=IMAL+1
				    CYCLE
			    END IF
			    GF=HALTON(3,NRA3,NRB3)
			    POLAR.R=GR
			    POLAR.CST=1.Q0-2.*GT
			    POLAR.FI=2.Q0*PI*GF
		        
		        IF (DISTCENTROS==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
			        CALL POLAR2CAR(POLAR,P)	!PASO DE POLARES A CARTESIANAS
				
			        P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
			        P.Y=P.Y+P12.Y
			        P.Z=P.Z+P12.Z

			        Y=YFUNC(NB1,II,NB2,JJ,P,P1,P2)*POLAR.R**2/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
		        ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
			        CALL SPHER2CAR(POLAR,DISTCENTROS,P)	!PASO DE ELIPSOIDALES A CARTESIANAS
			
			        P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
			        P.Y=P.Y+P12.Y
			        P.Z=P.Z+P12.Z
			
			        Y=YFUNC(NB1,II,NB2,JJ,P,P1,P2)*(POLAR.R**2-POLAR.CST**2)*(DISTCENTROS/2.Q0)**3/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
		        ENDIF

		        DENOM=DENOM+1.Q0
		        SSM= SSM + (Y-SSM)/DENOM
           ENDDO

           SSMTOTAL=SSMTOTAL+FB(NB1).SFB(II).SCNOR*FB(NB1).SFB(II).COEFICIENTE*FB(NB2).SFB(JJ).SCNOR*FB(NB2).SFB(JJ).COEFICIENTE*4.Q0*PI*SSM*CONSTNORM  !4*pi*constnorm es al cte normalización de la función densidad
        ENDDO
    ENDDO

	!NREC=NREC+1
	!IF (NREC==1) THEN
	!	NMC=NMC/10
	!	CALL MONOHAM(NB1,NB2,P1,P2,SSM1,ER)
	!	NMC=NMC*10		
	!	ER=0.1Q0*QABS(SSM-SSM1)
	!ELSE
	!	NREC=0
	!END IF

    RETURN
    END

    
! --------------------------------------------------------------------
! ----- CAlculo por MONTECARLO DE LAS CONSTANTES DE NORMALIZACIÓN DE LAS SUBFUNCIONES
! ----- (NUMEROS DE HAMMERSLEY)
! --------------------------------------------------------------------
	REAL*16 FUNCTION CNOR_HAM(NB,NS)
	USE ESTRUCT
	USE GLOBAL
	IMPLICIT NONE
	TYPE(RCSTFI)::POLAR
	TYPE(XYZ)::P,P1,P2,P12
	TYPE(DAT_METODO)::MET,MET1
	REAL*16 SSM,DENOM,YFUNC,Y,HALTON,AL,DELT
    REAL*16 W,WR,GR,GT,GF,GGR
    INTEGER*4 NB,NS,IMAL,I
    INTEGER*8 NRA2,NRA3,NRB2,NRB3
	REAL*16 DISTCENTROS,CONSTNORM,Y0,Y1,Y2,Y3
    

	P1.X=FB(NB).X
	P1.Y=FB(NB).Y
	P1.Z=FB(NB).Z
	P2.X=FB(NB).X
	P2.Y=FB(NB).Y
	P2.Z=FB(NB).Z
	P12.X=P1.X
	P12.Y=P1.Y
	P12.Z=P1.Z

    ! -- CALCULO DE LA FUNCIÓN DE PESO
	CALL FPESO(NB,NS,NB,NS,P1,P2,P12)
    
    ! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	CALL CONSTNORMRECORT(NB,NB,DISTCENTROS,Y0,Y1,Y2,Y3,EXP0,EXP1)
  
! ---------CALCULO MONTE CARLO: --------------------------------
    NRA2=0
    NRA3=0
    NRB2=1
    NRB3=1
    AL=CERO
    DELT=1.Q0/DFLOAT(NMC)
    IMAL=0
    DENOM=0.Q0
    SSM=0.Q0


    MET.NUM=2
	MET.NR1=NRA2
	MET.NR2=NRB2
	MET1.NUM=3
	MET1.NR1=NRA3
	MET1.NR2=NRB3
	
    DO I=1,NMC-1
		AL=AL+DELT
		GGR=AL
		GR=-QLOG(Y0-GGR*Y1)/EXP0
		W=EXP(-EXP0*GR)
		CONSTNORM=Y1/EXP0
		GT=HALTON(2,NRA2,NRB2)
		IF(GT<=0.OR.GT>1.Q0)THEN
			IMAL=IMAL+1
			CYCLE
		END IF
		GF=HALTON(3,NRA3,NRB3)
		POLAR.R=GR
		POLAR.CST=1.Q0-2.*GT
		POLAR.FI=2.Q0*PI*GF
		        
		CALL POLAR2CAR(POLAR,P)	!PASO DE POLARES A CARTESIANAS
				
		P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
		P.Y=P.Y+P12.Y
		P.Z=P.Z+P12.Z
        
        Y=YFUNC(NB,NS,NB,NS,P,P1,P2)*POLAR.R**2/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
		        
		DENOM=DENOM+1.Q0
		SSM= SSM + (Y-SSM)/DENOM
    ENDDO

    CNOR_HAM=1.Q0/QSQRT(4.Q0*PI*SSM*CONSTNORM)
            
    RETURN
    END
! --------------------------------------------------------------------
! ----- Cálculo  por  MONTECARLO  de integrales (p q | r s).
! ----- (FUNCIONES DE BASE SIN NORMALIZAR)
! ----- (NUMEROS DE HAMMERSLEY)
! ----- atencion:  Los numeros de Halton NO admiten semilla.
! --------------------------------------------------------------------
	SUBROUTINE BIELHAM_SUM(NB1,NB2,NB3,NB4,SSMTOTAL,ERTOTAL)
	USE GLOBAL
	USE ESTRUCT
    IMPLICIT NONE
	TYPE(DAT_METODO)::MET,MET1,MET2,MET3,MET4
	TYPE(RCSTFI)::POLAR12,POLAR34
	TYPE(XYZ)::P,P12,P34,P1,P2,P3,P4,PC12,PC34
    REAL*16 SSM,SSMTOTAL,ERTOTAL,DENOM,ANTOT,CONSTNORM,HALTON,AL,DELT
	INTEGER*4 NB1,NB2,NB3,NB4,I,II,J,JJ,KK,LL,I10,N10,IMAL
    INTEGER*8 NRA2,NRA3,NRA5,NRA7,NRA11,NRB2,NRB3,NRB5,NRB7,NRB11
    REAL*16 B12,B34,C12,C34,Y012,Y112,Y212,Y312,Y034,Y134,Y234,Y334,Y1,Y2,Y,YFUNC
    REAL*16 GR1,GGR1,GR2,GGR2,W1,W2,GT1,GT2,GF1,GF2,RR
    REAL*16 DISTCENTROS12,DISTCENTROS34
    

	P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z
	P3.X=FB(NB3).X
	P3.Y=FB(NB3).Y
	P3.Z=FB(NB3).Z
	P4.X=FB(NB4).X
	P4.Y=FB(NB4).Y
	P4.Z=FB(NB4).Z

! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS12=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS12==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC12.X=P1.X
		PC12.Y=P1.Y
		PC12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC12.X=(P1.X+P2.X)/2.Q0
		PC12.Y=(P1.Y+P2.Y)/2.Q0
		PC12.Z=(P1.Z+P2.Z)/2.Q0
	ENDIF
	DISTCENTROS34=QSQRT((P3.X-P4.X)**2+(P3.Y-P4.Y)**2+(P3.Z-P4.Z)**2)
	IF (DISTCENTROS34==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC34.X=P3.X
		PC34.Y=P3.Y
		PC34.Z=P3.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC34.X=(P3.X+P4.X)/2.Q0
		PC34.Y=(P3.Y+P4.Y)/2.Q0
		PC34.Z=(P3.Z+P4.Z)/2.Q0
	ENDIF

! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSMTOTAL=0.Q0

    DO II=1,FB(NB1).NSFB
        DO JJ=1,FB(NB2).NSFB
           DO KK=1,FB(NB3).NSFB
                DO LL=1,FB(NB4).NSFB
    
                    ! -- CALCULO DE LA FUNCIÓN DE PESO	
                    CALL FPESO(NB1,II,NB2,JJ,P1,P2,PC12)
                    B12=EXP0
                    CALL FPESO(NB3,KK,NB4,LL,P3,P4,PC34)
                    B34=EXP0

                    ! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
                    CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS12,Y012,Y112,Y212,Y312,B12,C12)
                    CALL CONSTNORMRECORT(NB3,NB4,DISTCENTROS34,Y034,Y134,Y234,Y334,B34,C34)

                    ! ------- PARTE CENTRAL DEL CALCULO DE LA INTEGRAL ------------
                    NRA2=0
                    NRA3=0
                    NRA5=0
                    NRB2=1
                    NRB3=1
                    NRB5=1
                    NRA7=0
                    NRA11=0
                    NRB7=1
                    NRB11=1
                    DELT=1.Q0/DFLOAT(NMC)
                    IMAL=0
                    DENOM=0.Q0
                    AL=0.Q0
                    SSM=0.Q0

	                MET.NUM=2
	                MET.NR1=NRA2
	                MET.NR2=NRB2
	                MET1.NUM=3
	                MET1.NR1=NRA3
	                MET1.NR2=NRB3
	                MET2.NUM=5
	                MET2.NR1=NRA5
	                MET2.NR2=NRB5
	                MET3.NUM=7
	                MET3.NR1=NRA7
	                MET3.NR2=NRB7
	                MET4.NUM=11
	                MET4.NR1=NRA11
	                MET4.NR2=NRB11
	
                    DO I=1,NMC-1
		                AL=AL+DELT
		            
			            GGR1=AL
			            GGR2=HALTON(2,NRA2,NRB2)
			            IF(GGR2<=0)THEN
				            IMAL=IMAL+1
				            CYCLE
			            END IF
			            GR1=-QLOG(Y012-GGR1*Y112)/B12
			            GR2=-QLOG(Y034-GGR2*Y134)/B34
			            W1=EXP(-B12*GR1)
			            W2=EXP(-B34*GR2)
			            CONSTNORM=(Y112*Y134)/(B12*B34)
			            GT1=HALTON(3,NRA3,NRB3)     
			            IF(GT1<=0.Q0.OR.GT1>1.Q0)THEN
				            IMAL=IMAL+1
				            CYCLE
			            END IF
			            GF1=HALTON(5,NRA5,NRB5)
			            GT2=HALTON(7,NRA7,NRB7)     
			            IF(GT2<=0.Q0.OR.GT2>1.Q0)THEN
				            IMAL=IMAL+1
				            CYCLE
			            END IF
			            GF2=HALTON(11,NRA11,NRB11)     
			            POLAR12.R=GR1
			            POLAR12.CST=1.Q0-2.*GT1
			            POLAR12.FI=2.Q0*PI*GF1
			            POLAR34.R=GR2
			            POLAR34.CST=1.Q0-2.*GT2
			            POLAR34.FI=2.Q0*PI*GF2
		            
                        ! ---   LOS VALORES DE POLARES O ELIPSOIDALES GENERADOS LO SON RESPECTO A UN ORIGEN QUE
                        ! ---   PUEDE CAMBIARSE MEDIANTE LAS TRANSFORMACIONES QUE SIGUEN:
		                IF (DISTCENTROS12==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
			                CALL POLAR2CAR(POLAR12,P12)	!PASO DE POLARES A CARTESIANAS
				
			                P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
			                P12.Y=P12.Y+PC12.Y
			                P12.Z=P12.Z+PC12.Z

			                Y1=YFUNC(NB1,II,NB2,JJ,P12,P1,P2)*POLAR12.R**2/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
		                ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
			                CALL SPHER2CAR(POLAR12,DISTCENTROS12,P12)	!PASO DE ELIPSOIDALES A CARTESIANAS
			
			                P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
			                P12.Y=P12.Y+PC12.Y
			                P12.Z=P12.Z+PC12.Z
			
			                Y1=YFUNC(NB1,II,NB2,JJ,P12,P1,P2)*(POLAR12.R**2-POLAR12.CST**2)*(DISTCENTROS12/2.Q0)**3/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
		                ENDIF
		                IF (DISTCENTROS34==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
			                CALL POLAR2CAR(POLAR34,P34)	!PASO DE POLARES A CARTESIANAS
				
			                P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
			                P34.Y=P34.Y+PC34.Y
			                P34.Z=P34.Z+PC34.Z

			                Y2=YFUNC(NB3,KK,NB4,LL,P34,P3,P4)*POLAR34.R**2/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
		                ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
			                CALL SPHER2CAR(POLAR34,DISTCENTROS34,P34)	!PASO DE ELIPSOIDALES A CARTESIANAS
			
			                P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
			                P34.Y=P34.Y+PC34.Y
			                P34.Z=P34.Z+PC34.Z
			
			                Y2=YFUNC(NB3,KK,NB4,LL,P34,P3,P4)*(POLAR34.R**2-POLAR34.CST**2)*(DISTCENTROS34/2.Q0)**3/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
		                ENDIF

		                Y=Y1*Y2

                        ! --- CALCULO DE LA DISTANCIA r12 :
		                P.X=P34.X-P12.X
		                P.Y=P34.Y-P12.Y
		                P.Z=P34.Z-P12.Z
		                RR=P.X*P.X+P.Y*P.Y+P.Z*P.Z
		                IF(RR<=CERO)THEN
			                IMAL=IMAL+1
			                CYCLE
		                ENDIF
		                Y=Y/QSQRT(RR)
		                DENOM=DENOM+1.Q0
		                SSM=SSM+(Y-SSM)/DENOM
                    ENDDO
                    SSMTOTAL=SSMTOTAL+FB(NB1).SFB(II).SCNOR*FB(NB1).SFB(II).COEFICIENTE*FB(NB2).SFB(JJ).SCNOR*FB(NB2).SFB(JJ).COEFICIENTE*FB(NB3).SFB(KK).SCNOR*FB(NB3).SFB(KK).COEFICIENTE*FB(NB4).SFB(LL).SCNOR*FB(NB4).SFB(LL).COEFICIENTE*SSM*CONSTNORM
                ENDDO
           ENDDO
        ENDDO
    ENDDO
	ANTOT=1.6Q1*PI*PI
	SSMTOTAL=ANTOT*SSMTOTAL

    RETURN
    END
                    

!*********************************************************************
!****************** METODO DE HASELGROVE *****************************
!*********************************************************************
! --------------------------------------------------------------------
! ----- Cálculo por MONTECARLO de integrales monoelectronicas <p|A|q>
! ----- A= 1, X, T ,V   ¢ H=T+V   (FUNCIONES DE BASE SIN NORMALIZAR)
! ----- (NUMEROS DE HASELGROVE)
! ----- INCLUYE ESTIMACION DEL ERROR (BASTANTE GROSERA)
! --------------------------------------------------------------------
    SUBROUTINE MONOHAS_SUM(NB1,NB2,SSMTOTAL,ERTOTAL)
	USE ESTRUCT
	USE GLOBAL
	IMPLICIT NONE
	TYPE(RCSTFI)::POLAR
	TYPE(XYZ)::P,P1,P2,P12
	TYPE(DAT_METODO)::MET
	REAL*16 SSM,SSMTOTAL,ER,ERTOTAL,DENOM,YFUNC,Y,HAS
	REAL*16 W,GR,GT,GF,GGR
	REAL*16 SPAR(10)
	INTEGER*4 NB1,NB2,N10,IMAL,I,II,J,JJ,I10,IISEM
	REAL*16 DISTCENTROS,CONSTNORM,Y0,Y1,Y2,Y3
    REAL*16 RAIZ2,RAIZ3,RAIZ5,DNUMERO
    
	RAIZ2=QSQRT(2.Q0)
    RAIZ3=QSQRT(3.Q0)
    RAIZ5=QSQRT(5.Q0)

	P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z
	
! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		P12.X=P1.X
		P12.Y=P1.Y
		P12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		P12.X=(P1.X+P2.X)/2.Q0
		P12.Y=(P1.Y+P2.Y)/2.Q0
		P12.Z=(P1.Z+P2.Z)/2.Q0
	ENDIF

! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSMTOTAL=0.Q0
! -- PONE A CERO EL VALOR DEL ERROR DE LA INTEGRAL
    ERTOTAL=0.Q0
    
    DO II=1,FB(NB1).NSFB
        DO JJ=1,FB(NB2).NSFB
           
            ! -- CALCULO DE LA FUNCIÓN DE PESO
	        CALL FPESO(NB1,II,NB2,JJ,P1,P2,P12)

            ! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	        CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS,Y0,Y1,Y2,Y3,EXP0,EXP1)

            ! ---------CALCULO MONTE CARLO: --------------------------------
	        IISEM=ISEM

            DNUMERO=DFLOAT((IISEM-1)*NMC)
            N10=NMC/10
            DENOM=0.Q0
            SSM=0.Q0

            OUTER: DO I10=1,10
		        INNER: DO I=1,N10
			        DNUMERO=DNUMERO+1.Q0
				    GGR=HAS(RAIZ2,DNUMERO)
				    IF(GGR<=0)THEN
					    IMAL=IMAL+1
                        CYCLE INNER
				    END IF
				    GR=-QLOG(Y0-GGR*Y1)/EXP0
				    W=EXP(-EXP0*GR)
				    CONSTNORM=Y1/EXP0
				    GT=HAS(RAIZ3,DNUMERO)
				    GF=HAS(RAIZ5,DNUMERO)
				    POLAR.R=GR
				    POLAR.CST=1.Q0-2.*GT
				    POLAR.FI=2.Q0*PI*GF
			
			        IF (DISTCENTROS==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				        CALL POLAR2CAR(POLAR,P)	!PASO DE POLARES A CARTESIANAS
					
				        P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
				        P.Y=P.Y+P12.Y
				        P.Z=P.Z+P12.Z

				        Y=YFUNC(NB1,II,NB2,JJ,P,P1,P2)*POLAR.R**2/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			        ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				        CALL SPHER2CAR(POLAR,DISTCENTROS,P)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				        P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
				        P.Y=P.Y+P12.Y
				        P.Z=P.Z+P12.Z
				
				        Y=YFUNC(NB1,II,NB2,JJ,P,P1,P2)*(POLAR.R**2-POLAR.CST**2)*(DISTCENTROS/2.Q0)**3/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			        ENDIF

			        DENOM=DENOM+1.Q0
			        SSM=SSM + (Y-SSM)/DENOM
                ENDDO INNER
		        SPAR(I10)=SSM
	        END DO OUTER

	        ER=0.Q0
            DO J=1,2
		        ER= ER + QABS(SPAR(J)-SSM)*DFLOAT(J)/1.0Q01
	        END DO
            ER=ER/2.0Q0
            
	        SSMTOTAL=SSMTOTAL+FB(NB1).SFB(II).SCNOR*FB(NB1).SFB(II).COEFICIENTE*FB(NB2).SFB(JJ).SCNOR*FB(NB2).SFB(JJ).COEFICIENTE*4.Q0*PI*SSM*CONSTNORM  !4*pi*constnorm es al cte normalización de la función densidad
            ERTOTAL=ERTOTAL+FB(NB1).SFB(II).SCNOR*FB(NB1).SFB(II).COEFICIENTE*FB(NB2).SFB(JJ).SCNOR*FB(NB2).SFB(JJ).COEFICIENTE*4.Q0*PI*ER*CONSTNORM
        ENDDO
    ENDDO

    RETURN
    END

! --------------------------------------------------------------------
! ----- Cálculo por MONTECARLO DE LAS CONSTANTES DE NORMALIZACION DE LAS SUBFUNCIONES
! ----- A= 1, X, T ,V   ¢ H=T+V   (FUNCIONES DE BASE SIN NORMALIZAR)
! ----- (NUMEROS DE HASELGROVE)
! ----- INCLUYE ESTIMACION DEL ERROR (BASTANTE GROSERA)
! --------------------------------------------------------------------
    REAL*16 FUNCTION CNOR_HAS(NB,NS)
	USE ESTRUCT
	USE GLOBAL
	IMPLICIT NONE
	TYPE(RCSTFI)::POLAR
	TYPE(XYZ)::P,P1,P2,P12
	TYPE(DAT_METODO)::MET
	REAL*16 SSM,DENOM,YFUNC,Y,HAS
	REAL*16 W,GR,GT,GF,GGR
	INTEGER*4 NB,NS,IMAL,I,J,IISEM
	REAL*16 DISTCENTROS,CONSTNORM,Y0,Y1,Y2,Y3
    REAL*16 RAIZ2,RAIZ3,RAIZ5,DNUMERO
    
	RAIZ2=QSQRT(2.Q0)
    RAIZ3=QSQRT(3.Q0)
    RAIZ5=QSQRT(5.Q0)

	P1.X=FB(NB).X
	P1.Y=FB(NB).Y
	P1.Z=FB(NB).Z
	P2.X=FB(NB).X
	P2.Y=FB(NB).Y
	P2.Z=FB(NB).Z
	P12.X=P1.X
	P12.Y=P1.Y
	P12.Z=P1.Z
           
    ! -- CALCULO DE LA FUNCIÓN DE PESO
	CALL FPESO(NB,NS,NB,NS,P1,P2,P12)

    ! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	CALL CONSTNORMRECORT(NB,NB,DISTCENTROS,Y0,Y1,Y2,Y3,EXP0,EXP1)

    ! ---------CALCULO MONTE CARLO: --------------------------------
	IISEM=ISEM

    DNUMERO=DFLOAT((IISEM-1)*NMC)
    DENOM=0.Q0
    SSM=0.Q0


	DO I=1,NMC
		DNUMERO=DNUMERO+1.Q0
		GGR=HAS(RAIZ2,DNUMERO)
		IF(GGR<=0)THEN
			IMAL=IMAL+1
            CYCLE
		END IF
		GR=-QLOG(Y0-GGR*Y1)/EXP0
		W=EXP(-EXP0*GR)
		CONSTNORM=Y1/EXP0
		GT=HAS(RAIZ3,DNUMERO)
		GF=HAS(RAIZ5,DNUMERO)
		POLAR.R=GR
		POLAR.CST=1.Q0-2.*GT
		POLAR.FI=2.Q0*PI*GF
			
			        
		CALL POLAR2CAR(POLAR,P)	!PASO DE POLARES A CARTESIANAS
					
		P.X=P.X+P12.X !COORDENADAS ABSOLUTAS
		P.Y=P.Y+P12.Y
		P.Z=P.Z+P12.Z

		Y=YFUNC(NB,NS,NB,NS,P,P1,P2)*POLAR.R**2/W !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			        
		DENOM=DENOM+1.Q0
		SSM=SSM + (Y-SSM)/DENOM
    END DO

    CNOR_HAS=1.Q0/QSQRT(4.Q0*PI*SSM*CONSTNORM)
    
    RETURN
    END
    

! --------------------------------------------------------------------
! ----- Cálculo  por  MONTECARLO  de integrales (p q | r s).
! ----- (FUNCIONES DE BASE SIN NORMALIZAR)
! ----- (NUMEROS DE HASELGROVE)
! ----- P1,P2,P3,P4= COORDENADAS DE LOS CENTROS DE LAS FS. DE BASE.
! ----- PC12,PC34= COORDENADAS DE LOS CENTROS DE LAS FUNCIONES DE PESO.
! ----- ESTIMA EL ERROR, A PARTIR DE UNA PROGRESION DE *2* RESULTADOS 
! ----- INTERMEDIOS.
! --------------------------------------------------------------------
	SUBROUTINE BIELHAS_SUM(NB1,NB2,NB3,NB4,SSMTOTAL,ERTOTAL)
	USE GLOBAL
	USE ESTRUCT
    IMPLICIT NONE
	TYPE(DAT_METODO)::MET
	TYPE(RCSTFI)::POLAR12,POLAR34
	TYPE(XYZ)::P,P12,P34,P1,P2,P3,P4,PC12,PC34
    REAL*16 SPAR(10)
    REAL*16 SSM,SSMTOTAL,ER,ERTOTAL,DENOM,ANTOT,CONSTNORM,HAS
	INTEGER*4 NB1,NB2,NB3,NB4,I,II,J,JJ,KK,LL,I10,N10,IMAL
    !INTEGER*8 NRA2,NRA3,NRA5,NRA7,NRA11,NRB2,NRB3,NRB5,NRB7,NRB11
    REAL*16 B12,C12,B34,C34,Y012,Y112,Y212,Y312,Y034,Y134,Y234,Y334,Y1,Y2,Y,YFUNC
    REAL*16 GR1,GGR1,GR2,GGR2,W1,W2,GT1,GT2,GF1,GF2,RR
    REAL*16 DISTCENTROS12,DISTCENTROS34
    REAL*16 RAIZ2,RAIZ3,RAIZ5,RAIZ7,RAIZ11,RAIZ13,DNUMERO
    
    RAIZ2=QSQRT(2.Q0)
    RAIZ3=QSQRT(3.Q0)
    RAIZ5=QSQRT(5.Q0)
    RAIZ7=QSQRT(7.Q0)
    RAIZ11=QSQRT(11.Q0)
    RAIZ13=QSQRT(1.3Q01)

	P1.X=FB(NB1).X
	P1.Y=FB(NB1).Y
	P1.Z=FB(NB1).Z
	P2.X=FB(NB2).X
	P2.Y=FB(NB2).Y
	P2.Z=FB(NB2).Z
	P3.X=FB(NB3).X
	P3.Y=FB(NB3).Y
	P3.Z=FB(NB3).Z
	P4.X=FB(NB4).X
	P4.Y=FB(NB4).Y
	P4.Z=FB(NB4).Z

! -- DECIDIMOS SI ES MONOCENTRICA O BICENTRICA
	DISTCENTROS12=QSQRT((P1.X-P2.X)**2+(P1.Y-P2.Y)**2+(P1.Z-P2.Z)**2)
	IF (DISTCENTROS12==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC12.X=P1.X
		PC12.Y=P1.Y
		PC12.Z=P1.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC12.X=(P1.X+P2.X)/2.Q0
		PC12.Y=(P1.Y+P2.Y)/2.Q0
		PC12.Z=(P1.Z+P2.Z)/2.Q0
	ENDIF
	DISTCENTROS34=QSQRT((P3.X-P4.X)**2+(P3.Y-P4.Y)**2+(P3.Z-P4.Z)**2)
	IF (DISTCENTROS34==0.Q0)THEN !MONOCENTRICA SE HACE EN POLARES
		PC34.X=P3.X
		PC34.Y=P3.Y
		PC34.Z=P3.Z
	ELSE	!BICENTICA SE HACE EN ELIPSOIDALES (PROLATE SPHEROIDALS)
		PC34.X=(P3.X+P4.X)/2.Q0
		PC34.Y=(P3.Y+P4.Y)/2.Q0
		PC34.Z=(P3.Z+P4.Z)/2.Q0
	ENDIF

! -- PONE A CERO EL VALOR DE LA INTEGRAL
	SSMTOTAL=0.Q0
! -- PONE A CERO EL VALOR DEL ERROR DE LA INTEGRAL
    ERTOTAL=0.Q0

    DO II=1,FB(NB1).NSFB
        DO JJ=1,FB(NB2).NSFB
           DO KK=1,FB(NB3).NSFB
                DO LL=1,FB(NB4).NSFB
                    ! -- CALCULO DE LA FUNCIÓN DE PESO
	                CALL FPESO(NB1,II,NB2,JJ,P1,P2,PC12)
                    B12=EXP0
	                CALL FPESO(NB3,KK,NB4,LL,P3,P4,PC34)
	                B34=EXP0

                    ! -- NORMALIZACION Y OTROS PARÁMETROS DE LA FUNCION DE PESO
	                CALL CONSTNORMRECORT(NB1,NB2,DISTCENTROS12,Y012,Y112,Y212,Y312,B12,C12)
	                CALL CONSTNORMRECORT(NB3,NB4,DISTCENTROS34,Y034,Y134,Y234,Y334,B34,C34)

                    ! ------- PARTE CENTRAL DEL CALCULO DE LA INTEGRAL ------------
	                DENOM=0.Q0
                    DNUMERO=DFLOAT((ISEM-1)*NMC)
                    N10=NMC/10
                    IMAL=0
                    SSM=0.Q0
	                
                    OUTER: DO I10=1,10
		                INNER: DO I=1,N10
				            DNUMERO=DNUMERO+1.Q0
				            GGR1=HAS(RAIZ2,DNUMERO)
				            IF(GGR1<=0)THEN
					            IMAL=IMAL+1
					            CYCLE INNER
				            END IF
				            GGR2=HAS(RAIZ3,DNUMERO)
				            IF(GGR2<=0)THEN
					            IMAL=IMAL+1
					            CYCLE INNER
				            END IF
				            GR1=-QLOG(Y012-GGR1*Y112)/B12
				            GR2=-QLOG(Y034-GGR2*Y134)/B34
				            W1=EXP(-B12*GR1)
				            W2=EXP(-B34*GR2)
				            CONSTNORM=(Y112*Y134)/(B12*B34)
				            GT1=HAS(RAIZ5,DNUMERO)
				            IF(GT1<=0.Q0.OR.GT1>1.Q0)THEN
					            IMAL=IMAL+1
					            CYCLE INNER
				            END IF
				            GF1=HAS(RAIZ7,DNUMERO)
				            GT2=HAS(RAIZ11,DNUMERO)
				            IF(GT2<=0.Q0.OR.GT2>1.Q0)THEN
					            IMAL=IMAL+1
					            CYCLE INNER
				            END IF     
				            GF2=HAS(RAIZ13,DNUMERO)     
				            POLAR12.R=GR1
				            POLAR12.CST=1.Q0-2.*GT1
				            POLAR12.FI=2.Q0*PI*GF1
				            POLAR34.R=GR2
				            POLAR34.CST=1.Q0-2.*GT2
				            POLAR34.FI=2.Q0*PI*GF2
			
                ! ---   LOS VALORES DE POLARES O ELIPSOIDALES GENERADOS LO SON RESPECTO A UN ORIGEN QUE
                ! ---   PUEDE CAMBIARSE MEDIANTE LAS TRANSFORMACIONES QUE SIGUEN:

			                IF (DISTCENTROS12==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				                CALL POLAR2CAR(POLAR12,P12)	!PASO DE POLARES A CARTESIANAS
					
				                P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
				                P12.Y=P12.Y+PC12.Y
				                P12.Z=P12.Z+PC12.Z

				                Y1=YFUNC(NB1,II,NB2,JJ,P12,P1,P2)*POLAR12.R**2/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			                ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				                CALL SPHER2CAR(POLAR12,DISTCENTROS12,P12)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				                P12.X=P12.X+PC12.X !COORDENADAS ABSOLUTAS
				                P12.Y=P12.Y+PC12.Y
				                P12.Z=P12.Z+PC12.Z
				
				                Y1=YFUNC(NB1,II,NB2,JJ,P12,P1,P2)*(POLAR12.R**2-POLAR12.CST**2)*(DISTCENTROS12/2.Q0)**3/W1 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			                ENDIF
			                IF (DISTCENTROS34==0.Q0)THEN !POLAR SON LAS COORDENADAS POLARES
				                CALL POLAR2CAR(POLAR34,P34)	!PASO DE POLARES A CARTESIANAS
					
				                P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
				                P34.Y=P34.Y+PC34.Y
				                P34.Z=P34.Z+PC34.Z

				                Y2=YFUNC(NB3,KK,NB4,LL,P34,P3,P4)*POLAR34.R**2/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			                ELSE	!POLAR SON LAS COORDENADAS ELIPSOIDALES (EN ESTE CASO)
				                CALL SPHER2CAR(POLAR34,DISTCENTROS34,P34)	!PASO DE ELIPSOIDALES A CARTESIANAS
				
				                P34.X=P34.X+PC34.X !COORDENADAS ABSOLUTAS
				                P34.Y=P34.Y+PC34.Y
				                P34.Z=P34.Z+PC34.Z
				
				                Y2=YFUNC(NB3,KK,NB4,LL,P34,P3,P4)*(POLAR34.R**2-POLAR34.CST**2)*(DISTCENTROS34/2.Q0)**3/W2 !PRODUCTO DE Xp OPERADOR Xq *ELEMENTO DE VOLUMEN/W
			                ENDIF

			                Y=Y1*Y2

                            ! --- CALCULO DE LA DISTANCIA r12 :
			                P.X=P34.X-P12.X
			                P.Y=P34.Y-P12.Y
			                P.Z=P34.Z-P12.Z
			                RR=P.X*P.X+P.Y*P.Y+P.Z*P.Z
			                IF(RR<=CERO)THEN
				                IMAL=IMAL+1
				                CYCLE INNER
			                ENDIF
			                Y=Y/QSQRT(RR)
			                DENOM=DENOM+1.Q0
			                SSM=SSM+(Y-SSM)/DENOM
                        ENDDO INNER
		                SPAR(I10)=SSM
	                ENDDO OUTER
		                
                    ER=0.Q0
                    DO J=1,2
		                ER= ER + QABS(SPAR(J)-SSM)*DFLOAT(J)/1.0Q01
	                END DO
	                ER=ER/2.0Q0
                    
                    SSMTOTAL=SSMTOTAL+FB(NB1).SFB(II).SCNOR*FB(NB1).SFB(II).COEFICIENTE*FB(NB2).SFB(JJ).SCNOR*FB(NB2).SFB(JJ).COEFICIENTE*FB(NB3).SFB(KK).SCNOR*FB(NB3).SFB(KK).COEFICIENTE*FB(NB4).SFB(LL).SCNOR*FB(NB4).SFB(LL).COEFICIENTE*SSM*CONSTNORM 
                    ERTOTAL=ERTOTAL+FB(NB1).SFB(II).SCNOR*FB(NB1).SFB(II).COEFICIENTE*FB(NB2).SFB(JJ).SCNOR*FB(NB2).SFB(JJ).COEFICIENTE*FB(NB3).SFB(KK).SCNOR*FB(NB3).SFB(KK).COEFICIENTE*FB(NB4).SFB(LL).SCNOR*FB(NB4).SFB(LL).COEFICIENTE*ER*CONSTNORM 
                ENDDO
           ENDDO
        ENDDO
    ENDDO
    
	ANTOT=1.6Q1*PI*PI
    SSMTOTAL=ANTOT*SSMTOTAL
    ERTOTAL=ANTOT*ERTOTAL

    RETURN
    END

    
!*********************************************************************
!******CALCULO DE LAS FUNCIONES UTILIZADAS EN EL PROGRAMA*************
!*********************************************************************
! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DE UNA
! ---   FUNCION DE BASE EN UN PUNTO "R,TETA,FI".
! ---   AQUI SE SUPONE DE TIPO: 
! ---	F(r) * Yreal(teta,fi) * SIGMA(r)
! ---   CST=cos(teta)
! ---   NTIPO da la clase de parte angular
! -------------------------------------------------------------
    REAL*16 FUNCTION SFBASE(NB,NS,POL)
	USE GLOBAL
	USE ESTRUCT
    INTEGER*4 NB,NS
	REAL*16 SIGMA,CALCFUNC,FACTANG

	TYPE (RCSTFI) :: POL

	IF (TIPOFB==1) THEN !EXPONENCIALES+GAUSSIANAS
		SFBASE=POL.R**FB(NB).SFB(NS).PARAMETRO1*QEXP(-FB(NB).SFB(NS).PARAMETRO2*POL.R-FB(NB).SFB(NS).PARAMETRO3*POL.R**2)*FACTANG(FB(NB).NTF,POL.CST,POL.FI)
    ELSEIF (TIPOFB==2)THEN !BOX
        IF(FB(NB).SFB(NS).PARAMETRO2<POL.R)THEN
		    SFBASE=0.Q0
	    ELSE
		    SFBASE=POL.R**FB(NB).SFB(NS).PARAMETRO1*(FB(NB).SFB(NS).PARAMETRO2-POL.R)**FB(NB).SFB(NS).PARAMETRO3*FACTANG(FB(NB).NTF,POL.CST,POL.FI)  !ESTO ES PARA LAS FUNCIONES R^N (R-ALFA)^BETA
        ENDIF
    ENDIF
    
    IF(RECORT==1.OR.RECORT==2) THEN
		SFBASE=SFBASE*SIGMA(NB,POL.R)
    ENDIF
    
    RETURN
    END

!--------------------------------------------------------------
!----   FUNCION DE CORTE PARA LAS FUNCIONES DE BASE
!--------------------------------------------------------------
    REAL*16 FUNCTION SIGMA(NB,RC)
	USE ESTRUCT
	USE GLOBAL, ONLY: RECORT
    IMPLICIT NONE
	INTEGER*4 NB
	REAL*16 RC,R

    SIGMA=0.Q0
    
	SELECT CASE (FB(NB).RECOR.TIPORECORT)
		CASE (0) !(0,R1)
			IF(RC>FB(NB).RECOR.R1.OR.FB(NB).RECOR.D1==0.Q0) RETURN
			IF(RC<(FB(NB).RECOR.R1-FB(NB).RECOR.D1))THEN
				SIGMA=1.Q0
			ELSE
				R=RC-FB(NB).RECOR.R1
				IF (RECORT==1) THEN
					SIGMA=(FB(NB).RECOR.COEF(1)+(FB(NB).RECOR.COEF(2)+FB(NB).RECOR.COEF(3)*R)*R)*R
				ELSEIF (RECORT==2) THEN
					SIGMA=(FB(NB).RECOR.COEF(1)+(FB(NB).RECOR.COEF(2)+FB(NB).RECOR.COEF(3)*R)*R)*R*R*R
				ENDIF
			ENDIF
		CASE (1) !(R0,INF)
			IF(RC<FB(NB).RECOR.R0.OR.FB(NB).RECOR.D0==0.Q0) RETURN
			IF(RC>(FB(NB).RECOR.R0+FB(NB).RECOR.D0))THEN
				SIGMA=1.Q0
			ELSE
				R=RC-FB(NB).RECOR.R0
				IF (RECORT==1) THEN
					SIGMA=(FB(NB).RECOR.COEF(1)+(FB(NB).RECOR.COEF(2)+FB(NB).RECOR.COEF(3)*R)*R)*R
				ELSEIF (RECORT==2) THEN
					SIGMA=(FB(NB).RECOR.COEF(1)+(FB(NB).RECOR.COEF(2)+FB(NB).RECOR.COEF(3)*R)*R)*R*R*R
				ENDIF
			ENDIF
		CASE (2) !(R0,R1)
			IF(RC<FB(NB).RECOR.R0.OR.RC>FB(NB).RECOR.R1.OR.FB(NB).RECOR.D0==0.Q0.OR.FB(NB).RECOR.D1==0.Q0)RETURN
			IF(RC>(FB(NB).RECOR.R0+FB(NB).RECOR.D0).AND.RC<(FB(NB).RECOR.R1-FB(NB).RECOR.D1))THEN
				SIGMA=1.Q0
			ELSEIF(RC<(FB(NB).RECOR.R0+FB(NB).RECOR.D0))THEN
				R=RC-FB(NB).RECOR.R0
				IF (RECORT==1) THEN
					SIGMA=(FB(NB).RECOR.COEF(4)+(FB(NB).RECOR.COEF(5)+FB(NB).RECOR.COEF(6)*R)*R)*R
				ELSEIF (RECORT==2) THEN
					SIGMA=(FB(NB).RECOR.COEF(4)+(FB(NB).RECOR.COEF(5)+FB(NB).RECOR.COEF(6)*R)*R)*R*R*R
				ENDIF
			ELSEIF(RC>(FB(NB).RECOR.R1-FB(NB).RECOR.D1))THEN
				R=RC-FB(NB).RECOR.R1
				IF (RECORT==1) THEN
					SIGMA=(FB(NB).RECOR.COEF(1)+(FB(NB).RECOR.COEF(2)+FB(NB).RECOR.COEF(3)*R)*R)*R
				ELSEIF (RECORT==2) THEN
					SIGMA=(FB(NB).RECOR.COEF(1)+(FB(NB).RECOR.COEF(2)+FB(NB).RECOR.COEF(3)*R)*R)*R*R*R
				ENDIF
			ENDIF
	ENDSELECT

    RETURN

    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL OPERADOR  T
! ---   APLICADO A UNA FUNCION DE BASE EN UN PUNTO "R,TETA,FI".
! ---   (CST ES EL COSENO DE TETA)
! -------------------------------------------------------------
    REAL*16 FUNCTION STBASE(NB,NS,POL)
	USE GLOBAL
	USE ESTRUCT
	IMPLICIT NONE
	TYPE(RCSTFI)::POL
	INTEGER*4 NB, NS, L
    REAL*16 PRIMERAD,SEGUNDAD,SFBASE

    L=0
    IF(FB(NB).NTF>=1)L=1
    IF(FB(NB).NTF>=4)L=2
    IF(FB(NB).NTF>=9)L=3
    
	CALL DERIVA2(NB,NS,POL,PRIMERAD,SEGUNDAD)

	STBASE=SEGUNDAD+PRIMERAD*2.Q0/POL.R
    STBASE=STBASE-DFLOAT(L*(L+1))*SFBASE(NB,NS,POL)/POL.R**2
    STBASE=-0.5Q0*STBASE

	RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DE LA DERIVADA PRIMERA Y SEGUNDA
! ---   RESPECTO A R DE UNA FUNCION DE BASE EN UN PUNTO "R,TETA,FI".
! ---   CST=cos(teta)  
! ---   NTIPO da la clase de parte angular
! -------------------------------------------------------------
    SUBROUTINE DERIVA2(NB,NS,P,DT1,DT2)
	USE GLOBAL
	USE ESTRUCT
	IMPLICIT NONE
	TYPE(RCSTFI)::P,P1,P2
	REAL*16 D1,D2,DFR1,DFR2,DT1,DT2,RR
    REAL*16 F0,F1,F2,SFBASE,SIGMA
	INTEGER*4 NB,NS
    REAL*16 DELTA
    
    DELTA=1.Q-5
        
    P1.R=P.R+DELTA
	P1.CST=P.CST
	P1.FI=P.FI

    P2.R=P.R-DELTA
	P2.CST=P.CST
	P2.FI=P.FI

	IF (RECORT==0)THEN
		F0=SFBASE(NB,NS,P)
		F1=SFBASE(NB,NS,P1)
		F2=SFBASE(NB,NS,P2)
		DT1=(F1-F2)/(2.Q0*DELTA)
		DT2=(F1+F2-2.Q0*F0)/DELTA**2
	ELSEIF (RECORT==1) THEN
		RECORT=0  !ESTO SE HACE PARA QUE NO MULTIPLIQUE POR LA F. SIGMA
		F0=SFBASE(NB,NS,P)
		F1=SFBASE(NB,NS,P1)
		F2=SFBASE(NB,NS,P2)
		RECORT=1
		D1=(F1-F2)/(2.Q0*DELTA)
		D2=(F1+F2-2.Q0*F0)/DELTA**2
		DFR1=0.Q0
		DFR2=0.Q0
		IF(FB(NB).RECOR.TIPORECORT==0)THEN
			IF (P.R<FB(NB).RECOR.R1.AND.P.R>FB(NB).RECOR.R1-FB(NB).RECOR.D1) THEN
				RR=P.R-FB(NB).RECOR.R1
				DFR1=FB(NB).RECOR.COEF(1)+2.Q0*FB(NB).RECOR.COEF(2)*RR+3.Q0*FB(NB).RECOR.COEF(3)*RR*RR
				DFR2=2.Q0*FB(NB).RECOR.COEF(2)+6.Q0*FB(NB).RECOR.COEF(3)*RR
			ENDIF
		ELSEIF(FB(NB).RECOR.TIPORECORT==1)THEN
			IF (P.R>FB(NB).RECOR.R0.AND.P.R<FB(NB).RECOR.R0+FB(NB).RECOR.D0) THEN
				RR=P.R-FB(NB).RECOR.R0
				DFR1=FB(NB).RECOR.COEF(1)+2.Q0*FB(NB).RECOR.COEF(2)*RR+3.Q0*FB(NB).RECOR.COEF(3)*RR*RR
				DFR2=2.Q0*FB(NB).RECOR.COEF(2)+6.Q0*FB(NB).RECOR.COEF(3)*RR
			ENDIF
		ELSEIF(FB(NB).RECOR.TIPORECORT==2)THEN
			IF (P.R>FB(NB).RECOR.R0.AND.P.R<FB(NB).RECOR.R0+FB(NB).RECOR.D0) THEN
				RR=P.R-FB(NB).RECOR.R0
				DFR1=FB(NB).RECOR.COEF(1)+2.Q0*FB(NB).RECOR.COEF(2)*RR+3.Q0*FB(NB).RECOR.COEF(3)*RR*RR
				DFR2=2.Q0*FB(NB).RECOR.COEF(2)+6.Q0*FB(NB).RECOR.COEF(3)*RR
			ELSEIF (P.R<FB(NB).RECOR.R1.AND.P.R>FB(NB).RECOR.R1-FB(NB).RECOR.D1) THEN
				RR=P.R-FB(NB).RECOR.R1
				DFR1=FB(NB).RECOR.COEF(4)+2.Q0*FB(NB).RECOR.COEF(5)*RR+3.Q0*FB(NB).RECOR.COEF(6)*RR*RR
				DFR2=2.Q0*FB(NB).RECOR.COEF(5)+6.Q0*FB(NB).RECOR.COEF(6)*RR
			ENDIF
		ENDIF
		DT1=SIGMA(NB,P.R)*D1+F0*DFR1
		DT2=SIGMA(NB,P.R)*D2+F0*DFR2+2.Q0*D1*DFR1
	ELSEIF (RECORT==2) THEN
		RECORT=0	!ESTO SE HACE PARA QUE NO MULTIPLIQUE POR LA F. SIGMA
		F0=SFBASE(NB,NS,P)
		F1=SFBASE(NB,NS,P1)
		F2=SFBASE(NB,NS,P2)
		RECORT=2
		D1=(F1-F2)/(2.Q0*DELTA)
		D2=(F1+F2-2.Q0*F0)/DELTA**2
		DFR1=0.Q0
		DFR2=0.Q0
		IF(FB(NB).RECOR.TIPORECORT==0)THEN
			IF (P.R<FB(NB).RECOR.R1.AND.P.R>FB(NB).RECOR.R1-FB(NB).RECOR.D1) THEN
				RR=P.R-FB(NB).RECOR.R1
				DFR1=3.Q0*FB(NB).RECOR.COEF(1)*RR*RR+4.Q0*FB(NB).RECOR.COEF(2)*RR*RR*RR+5.Q0*FB(NB).RECOR.COEF(3)*RR*RR*RR*RR
				DFR2=6.Q0*FB(NB).RECOR.COEF(1)*RR+12.Q0*FB(NB).RECOR.COEF(2)*RR*RR+20.Q0*FB(NB).RECOR.COEF(3)*RR*RR*RR
			ENDIF
		ELSEIF(FB(NB).RECOR.TIPORECORT==1)THEN
			IF (P.R>FB(NB).RECOR.R0.AND.P.R<FB(NB).RECOR.R0+FB(NB).RECOR.D0) THEN
				RR=P.R-FB(NB).RECOR.R0
				DFR1=3.Q0*FB(NB).RECOR.COEF(1)*RR*RR+4.Q0*FB(NB).RECOR.COEF(2)*RR*RR*RR+5.Q0*FB(NB).RECOR.COEF(3)*RR*RR*RR*RR
				DFR2=6.Q0*FB(NB).RECOR.COEF(1)*RR+12.Q0*FB(NB).RECOR.COEF(2)*RR*RR+20.Q0*FB(NB).RECOR.COEF(3)*RR*RR*RR
			ENDIF
		ELSEIF(FB(NB).RECOR.TIPORECORT==2)THEN
			IF (P.R>FB(NB).RECOR.R0.AND.P.R<FB(NB).RECOR.R0+FB(NB).RECOR.D0) THEN
				RR=P.R-FB(NB).RECOR.R0
				DFR1=3.Q0*FB(NB).RECOR.COEF(1)*RR*RR+4.Q0*FB(NB).RECOR.COEF(2)*RR*RR*RR+5.Q0*FB(NB).RECOR.COEF(3)*RR*RR*RR*RR
				DFR2=6.Q0*FB(NB).RECOR.COEF(1)*RR+12.Q0*FB(NB).RECOR.COEF(2)*RR*RR+20.Q0*FB(NB).RECOR.COEF(3)*RR*RR*RR
			ELSEIF (P.R<FB(NB).RECOR.R1.AND.P.R>FB(NB).RECOR.R1-FB(NB).RECOR.D1) THEN
				RR=P.R-FB(NB).RECOR.R1
				DFR1=3.Q0*FB(NB).RECOR.COEF(4)*RR*RR+4.Q0*FB(NB).RECOR.COEF(5)*RR*RR*RR+5.Q0*FB(NB).RECOR.COEF(6)*RR*RR*RR*RR
				DFR2=6.Q0*FB(NB).RECOR.COEF(4)*RR+12.Q0*FB(NB).RECOR.COEF(5)*RR*RR+20.Q0*FB(NB).RECOR.COEF(6)*RR*RR*RR
			ENDIF
		ENDIF
		DT1=SIGMA(NB,P.R)*D1+F0*DFR1
		DT2=SIGMA(NB,P.R)*D2+F0*DFR2+2.Q0*D1*DFR1
	ENDIF

    RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL PRODUCTO
! ---   "V" POR UNA FUNCION DE BASE.
! ---   (CST ES EL COSENO DE TETA)
! ---    EL PUNTO (R,CST,FI) ENTRA YA DEFINIDO RESPECTO AL
! ---    ORIGEN DE LA FUNCION DE BASE IMPLICADA,  PERO LAS
! ---    COORDENADAS NUCLEARES (entran respecto al origen)
! ---    SON TRASLADADAS POR EL SUBPROGRAMA.
! -------------------------------------------------------------
	REAL*16 FUNCTION SVBASE(NB,NS,POL,CENT)
	USE ESTRUCT
	USE GLOBAL
	IMPLICIT REAL*16(A-H,O-Z)
    RECORD/RCSTFI/POL
	RECORD/XYZ/P,CENT,PP0
	INTEGER*4 NB,NS
	  
	CALL POLAR2CAR(POL,P)
	
    SVBASE=0.Q0
! --- CALCULO DE LAS COORDENADAS DE CADA NUCLEO RESPECTO AL 
! --- CENTRO DE LA SEGUNDA FUNCION DE BASE:
    IF(NUC==0)RETURN
	DO K=1,NUC
		PP0.X=NUCLEOS(K).X-CENT.X
		PP0.Y=NUCLEOS(K).Y-CENT.Y	!CENT ES EL CENTRO DEL POTENCIAL
		PP0.Z=NUCLEOS(K).Z-CENT.Z	
		X0=P.X-PP0.X
		Y0=P.Y-PP0.Y
		Z0=P.Z-PP0.Z 
		R0=QSQRT(X0*X0+Y0*Y0+Z0*Z0)   
		IF(R0<CERO)R0=CERO
		SVBASE=SVBASE-NUCLEOS(K).CARGA/R0
	END DO

    SVBASE=SVBASE*SFBASE(NB,NS,POL)

    RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL OPERADOR  H
! ---   APLICADO A UNA FUNCION DE BASE EN UN PUNTO "R,TETA,FI".
! ---   (CST ES EL COSENO DE TETA)
! -------------------------------------------------------------
    REAL*16 FUNCTION SHBASE(NB,NS,POL,CENT)
	USE ESTRUCT
	!USE GLOBAL
    RECORD/RCSTFI/POL
	RECORD/XYZ/CENT
	REAL*16 STBASE,SVBASE

    SHBASE=STBASE(NB,NS,POL)+SVBASE(NB,NS,POL,CENT)
	
    RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL PRODUCTO
! ---   "X**Nx * Y**Ny * Z**Nz" POR UNA FUNCION DE BASE.
! ---   (CST ES EL COSENO DE TETA)
! ---    EL PUNTO (R,CST,FI) ENTRA YA DEFINIDO RESPECTO AL
! ---    ORIGEN DE LA FUNCION DE BASE IMPLICADA,  PERO LAS
! ---    COORDENADAS NUCLEARES TIENEN QUE SER TRASLADADAS.
! -------------------------------------------------------------
    REAL*16 FUNCTION SXBASE(NB,NS,POL,P)
    USE ESTRUCT
	!USE GLOBAL
	IMPLICIT REAL*16(A-H,O-Z)
	RECORD/XYZ/P
	RECORD/RCSTFI/POL
	INTEGER*4 NB,NS
	
	SXBASE=(P.X-P0.X)**NN.NX*(P.Y-P0.Y)**NN.NY*(P.Z-P0.Z)**NN.NZ
    SXBASE=SXBASE*SFBASE(NB,NS,POL)

    RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DE PARTES ANGULARES
! ---   EVALUA LA PARTE ANGULAR DE UNA FUNCION DE BASE
! ---   EN UN PUNTO CON   TETA=ARC COS(CST) ; FI=FI
! ---   LA FUNCION DE BASE ES DE CLASE:
! ---   s   SI N=0 ------------------1
! ---   P(x)  SI N=1 ----------------SNT*QCOS(FI)
! ---   P(y)  SI N=2 ----------------SNT*QSIN(FI)
! ---   P(z)  SI N=3 ----------------CST
! ---   d(3z2-r2) SI N=8 ------------3.Q0*CST*CST-1.Q0
! ---   d(xz) SI N=6 ----------------SNT*CST*QCOS(FI)
! ---   d(yz) SI N=7 ----------------SNT*CST*QSIN(FI)
! ---   d(xy) SI N=5 ----------------SNT*QSIN(2.Q0*FI)
! ---   d(X2-Y2) SI N=4 -------------SNT*QCOS(2.Q0*FI) 
! ---   f(5z3-3z) SI N=15 ------------5.Q0*CST**3-3.Q0*CST
! ---   f(5z2y-y) SI N=14 -----------SNT*(5.Q0*CST*CST-1.Q0)*QSIN(FI)
! ---   f(5z2x-x) SI N=13 -----------SNT*(5.Q0*CST*CST-1.Q0)*QCOS(FI)
! ---   f(xyz) SI N=12 --------------SNT**2*CST*QSIN(2.Q0*FI)
! ---   f((x2-y2)z) SI N=11 ---------SNT**2*CST*QCOS(2.Q0*FI)
! ---   f(y3-3x2y) SI N=10 ----------SNT**3*QSIN(3.Q0*FI)
! ---   f(x3-3y2x) SI N=9 -----------SNT**3*QCOS(3.Q0*FI)
! -------------------------------------------------------------
	REAL*16 FUNCTION FACTANG(N,CST,FI)
    INTEGER*4 N
	REAL*16 CST,FI,FACTANG_CST,FACTANG_FI
    
	FACTANG=FACTANG_CST(N,CST)*FACTANG_FI(N,FI)

    END

! -------------------------------------------------------------
!	CALCULO DE LA PARTE ANGULAR PARA COSENO DE THETA
! -------------------------------------------------------------

	REAL*16 FUNCTION FACTANG_CST(N,CST)
    USE ESTRUCT, ONLY:ILONG,DIR
	USE GLOBAL, ONLY:IDIOMA
	INTEGER*4 N
	REAL*16 CST,SNT
    CHARACTER*ILONG CADIDIOMA,LEERVALOR,CAD

    
	SNT=QSQRT(1.Q0-CST*CST)

	SELECT CASE (N)
		CASE (0)
			FACTANG_CST=1.Q0
			RETURN
		CASE (1,2,4,5)
			FACTANG_CST=SNT
			RETURN
		CASE (3)
			FACTANG_CST=CST
			RETURN
		CASE (6,7)
			FACTANG_CST=SNT*CST
			RETURN
		CASE (8)
			FACTANG_CST=3.Q0*CST*CST-1.Q0
			RETURN
		CASE(9,10)
			FACTANG_CST=SNT**3
			RETURN
		CASE(11,12)
			FACTANG_CST=SNT**2*CST
			RETURN
		CASE(13,14)
			FACTANG_CST=SNT*(5.Q0*CST*CST-1.Q0)
			RETURN
		CASE (15)
			FACTANG_CST=5.Q0*CST**3-3.Q0*CST
			RETURN
		CASE DEFAULT
			CADIDIOMA=LEERVALOR('idioma.lng',IDIOMA,'1215')		
			CAD=' '
			CALL MENSAJES(CADIDIOMA,CAD,0.Q0)
		    STOP		
	END SELECT
    
    END

! -------------------------------------------------------------
!	CALCULO DE LA PARTE ANGULAR PARA FI
! -------------------------------------------------------------
	REAL*16 FUNCTION FACTANG_FI(N,FI)
    USE ESTRUCT, ONLY:ILONG,DIR
	USE GLOBAL, ONLY:IDIOMA
	IMPLICIT REAL*16(A-H,O-Z)
	INTEGER*4 N
	CHARACTER*ILONG CADIDIOMA,LEERVALOR,CAD

	SELECT CASE (N)
		CASE (0,3,8,15)
			FACTANG_FI=1.Q0
			RETURN
		CASE (1,6,13)
			FACTANG_FI=QCOS(FI)
			RETURN
		CASE (2,7,14)
			FACTANG_FI=QSIN(FI)    
			RETURN
		CASE (5,12)
			FACTANG_FI=QSIN(2.Q0*FI)
			RETURN
		CASE (4,11)
			FACTANG_FI=QCOS(2.Q0*FI)   
			RETURN
		CASE (10)
			FACTANG_FI=QSIN(3.Q0*FI)
			RETURN
		CASE (9)
			FACTANG_FI=QCOS(3.Q0*FI)
			RETURN
		CASE DEFAULT
			CADIDIOMA=LEERVALOR('idioma.lng',IDIOMA,'1215')		
			CAD=' '
			CALL MENSAJES(CADIDIOMA,CAD,0.Q0)
		    STOP		
	END SELECT
		 
    END    


