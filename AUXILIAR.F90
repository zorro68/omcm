!**********************************************************************
!**** SUBRUTINAS Y FUNCIONES PARA LA LECTURA DE DATOS               ***
!**********************************************************************
! -------------------------------------------------------------------      
! --- SUBPROGRAMA PARA LEER LOS DATOS:
! -------------------------------------------------------------------
	SUBROUTINE LEEDAT()
	USE GLOBAL
	USE ESTRUCT
	CHARACTER*ILONG LEERVALOR,INTTOSTR,CADENA,CADENA1
	INTEGER*4 LEERVALOR_INT,NELA,NELB
	REAL*16 LEERVALOR_REAL
	INTEGER*4 I,J,NATOM 
    LOGICAL ISINT
	
    IDIOMA=LEERVALOR('idioma.lng','idioma','idioma')
    
	CALL DEFINE_ESTRUCTURAS

! --- LECTURA DE LOS CENTROS DE LOS NUCLEOS Y FUNCIONES DE BASE
	DO I=1,NCENTROS
		CENTROS(I).X=LEERVALOR_REAL(DIR.DAT,'CENTROS','Centro('//TRIM(INTTOSTR(I))//',X)')
		CENTROS(I).Y=LEERVALOR_REAL(DIR.DAT,'CENTROS','Centro('//TRIM(INTTOSTR(I))//',Y)')
		CENTROS(I).Z=LEERVALOR_REAL(DIR.DAT,'CENTROS','Centro('//TRIM(INTTOSTR(I))//',Z)')
	ENDDO
	
! --- LECTURA DE LOS DATOS DE LOS NÚCLEOS
	DO I=1,NUC
		NUCLEOS(I).NC=LEERVALOR_REAL(DIR.DAT,'NUCLEOS','Atomo('//TRIM(INTTOSTR(I))//',Centro)')
		NUCLEOS(I).X=CENTROS(NUCLEOS(I).NC).X
		NUCLEOS(I).Y=CENTROS(NUCLEOS(I).NC).Y
		NUCLEOS(I).Z=CENTROS(NUCLEOS(I).NC).Z
		NUCLEOS(I).CARGA=LEERVALOR_REAL(DIR.DAT,'NUCLEOS','Atomo('//TRIM(INTTOSTR(I))//',Znuc)')
		NATOM=999
        IF(ISINT(NUCLEOS(I).CARGA)) NATOM=NATOM+IQINT(NUCLEOS(I).CARGA)
        CADENA=INTTOSTR(NATOM)
        CADENA1=LEERVALOR("idioma.lng",IDIOMA,TRIM(CADENA))
        NUCLEOS(I).NOMBRE=TRIM(CADENA1)
	ENDDO

! --- LECTURA DE LOS DATOS DE LAS FUNCIONES DE BASE
	TIPOFB=LEERVALOR_INT(DIR.DAT,'FBASE','TipoFB')
	RECORT=LEERVALOR_INT(DIR.DAT,'FBASE','Recortadas')
    BIELEC=LEERVALOR_INT(DIR.DAT,'FBASE','Bielec')
    NORMSFB=LEERVALOR_INT(DIR.DAT,'FBASE','NORMSFB')
        
    DO I=1,N
		FB(I).N_FBASE=I
		FB(I).NC=LEERVALOR_INT(DIR.DAT,'FBASE','FBase('//TRIM(INTTOSTR(I))//',Centro)')
		FB(I).X=CENTROS(FB(I).NC).X
		FB(I).Y=CENTROS(FB(I).NC).Y
		FB(I).Z=CENTROS(FB(I).NC).Z
		FB(I).NTF=LEERVALOR_INT(DIR.DAT,'FBASE','FBase('//TRIM(INTTOSTR(I))//',ParteAngular)')
        
        FB(I).NSFB=LEERVALOR_INT(DIR.DAT,'FBASE','FBase('//TRIM(INTTOSTR(I))//',NumSFB)')
        DO J=1,FB(I).NSFB
            FB(I).SFB(J).COEFICIENTE=LEERVALOR_REAL(DIR.DAT,'FBASE','FBase('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//',coeficiente)')
            FB(I).SFB(J).PARAMETRO1=LEERVALOR_REAL(DIR.DAT,'FBASE','FBase('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//',Parametro1)')
		    FB(I).SFB(J).PARAMETRO2=LEERVALOR_REAL(DIR.DAT,'FBASE','FBase('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//',Parametro2)')
		    FB(I).SFB(J).PARAMETRO3=LEERVALOR_REAL(DIR.DAT,'FBASE','FBase('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//',Parametro3)')
        ENDDO
        FB(I).RECOR.R0=LEERVALOR_REAL(DIR.DAT,'FBASE','FBase('//TRIM(INTTOSTR(I))//',RadioCorte0)')
		FB(I).RECOR.D0=LEERVALOR_REAL(DIR.DAT,'FBASE','FBase('//TRIM(INTTOSTR(I))//',AnchuraCorte0)')
		FB(I).RECOR.R1=LEERVALOR_REAL(DIR.DAT,'FBASE','FBase('//TRIM(INTTOSTR(I))//',RadioCorte1)')
		FB(I).RECOR.D1=LEERVALOR_REAL(DIR.DAT,'FBASE','FBase('//TRIM(INTTOSTR(I))//',AnchuraCorte1)')
		FB(I).RECOR.TIPORECORT=LEERVALOR_INT(DIR.DAT,'FBASE','FBase('//TRIM(INTTOSTR(I))//',TipoIntCorte)')
		FB(I).NOMBRE=LEERVALOR(DIR.DAT,'FBASE','FBase('//TRIM(INTTOSTR(I))//',Formula)')
    ENDDO

! --- LECTURA DE LOS DATOS DE LAS INTEGRALES
	CLASMON=LEERVALOR(DIR.DAT,'METODOINTEGRACION','Metodo')
	ISEM=LEERVALOR_INT(DIR.DAT,'METODOINTEGRACION','Semilla')
    NMC=LEERVALOR_REAL(DIR.DAT,'METODOINTEGRACION','NumPuntos')
	
	FICH.INT=LEERVALOR(DIR.DAT,'INTEGRALES','FicheroInt')
	LD=LEN_TRIM(DIRE)+9
	L=LEN_TRIM(FICH.INT)
	DIR.INT(LD:LD+L)=FICH.INT
	UNASOLA=LEERVALOR_INT(DIR.DAT,'INTEGRALES','Integrales')
	CLASINT=LEERVALOR(DIR.DAT,'INTEGRALES','TipoInt')
	SN1=LEERVALOR_INT(DIR.DAT,'INTEGRALES','Indice1')
	SN2=LEERVALOR_INT(DIR.DAT,'INTEGRALES','Indice2')
	SN3=LEERVALOR_INT(DIR.DAT,'INTEGRALES','Indice3')
	SN4=LEERVALOR_INT(DIR.DAT,'INTEGRALES','Indice4')
	
	IF (TIPOFB==0) THEN  !FUNCIONES DEFINIDAS POR EL USUARIO
		NPOLIG=LEERVALOR_INT(DIR.DAT,'INTEGRALES','FPeso(NPolig)')
		INIR=LEERVALOR_REAL(DIR.DAT,'INTEGRALES','FPeso(Inicio)')
		FINR=LEERVALOR_REAL(DIR.DAT,'INTEGRALES','FPeso(Fin)')
		INCREMENT=LEERVALOR_INT(DIR.DAT,'INTEGRALES','FPeso(Incremento)')
		INCREMENT=INCREMENT-1	!DIVISIONES DEL INTERVALO PARA LA FUNCION DE PESO
	ELSE
		NPOLIG=0
	ENDIF
	

! --- LECTURA DE LOS DATOS DEL CALCULO SCF
	SCF=LEERVALOR(DIR.DAT,'METODOCALCULO','Metodo')
	DI.ITMET=LEERVALOR_INT(DIR.DAT,'METODOCALCULO','ControlConvergencia')
	DI.MAXITER=LEERVALOR_INT(DIR.DAT,'METODOCALCULO','NmaxIter')
	DI.CONV=LEERVALOR_REAL(DIR.DAT,'METODOCALCULO','Tolerancia')
	DI.F_CONV=LEERVALOR_REAL(DIR.DAT,'METODOCALCULO','FactorAmortiguacion')
	DI.NIT_CONV=LEERVALOR_INT(DIR.DAT,'METODOCALCULO','IteracionComienzoAmortiguacion')

	
! --- LECTURA DE LOS DATOS DE LOS NUMEROS DE OCUPACION Y COEFICIENTES
	DI.THF='RHF'
	NELA=0
	DO I=1,N
		NOCA(I)=LEERVALOR_INT(DIR.DAT,'ESTADOELECTRONICO','NumOcupAlfa('//TRIM(INTTOSTR(I))//')')
		NELA=NELA+NOCA(I)
	ENDDO
	NELB=0
	DO I=1,N
		NOCB(I)=LEERVALOR_INT(DIR.DAT,'ESTADOELECTRONICO','NumOcupBeta('//TRIM(INTTOSTR(I))//')')
		NELB=NELB+NOCB(I)
	ENDDO
	NEL=NELA+NELB
	DO I=1,N
		IF(NOCB(I)/=NOCA(I))DI.THF='UHF'
    END DO
	IF(NELA>0)THEN
		DO I=1,N
			DO J=1,N
				C0A(I,J)=LEERVALOR_REAL(DIR.DAT,'ESTADOELECTRONICO','CoefOcupAlfa('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')')
			ENDDO
		END DO
    ENDIF
	IF(NELB>0)THEN
		DO I=1,N
			DO J=1,N
				C0B(I,J)=LEERVALOR_REAL(DIR.DAT,'ESTADOELECTRONICO','CoefOcupBeta('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')')
			ENDDO
		END DO
    ENDIF

! --- LECTURA DE LOS DATOS DEL POTENCIAL EXTERNO
	POT(1)=LEERVALOR_REAL(DIR.DAT,'POTENCIALEXT','Potencial(X)')
	POT(2)=LEERVALOR_REAL(DIR.DAT,'POTENCIALEXT','Potencial(Y)')
	POT(3)=LEERVALOR_REAL(DIR.DAT,'POTENCIALEXT','Potencial(Z)')

! --- LECTURA DE LAS PROPIEDADES QUE VA A CALCULAR
	MOMENTODIPOLAR=LEERVALOR_INT(DIR.DAT,'PROPIEDADES','MomentoDipolar')
	POBLACIONES=LEERVALOR_INT(DIR.DAT,'PROPIEDADES','Poblaciones')

! --- LECTURA DE LAS VARIABLES PARA LA ESCRITURA DE RESULTADOS
	DO I=0,13
		ESCRITURA(I)=LEERVALOR_INT(DIR.DAT,'RESULTADOS','Escritura('//TRIM(INTTOSTR(I))//')')
	ENDDO
	

    RETURN
    END

! -------------------------------------------------------------------      
! --- SUBPROGRAMA PARA DEFINIR LAS ESTRUCTURAS DE DATOS
! -------------------------------------------------------------------
	SUBROUTINE DEFINE_ESTRUCTURAS()
	USE GLOBAL
	USE ESTRUCT
	INTEGER*4 ERROR   ! NOS DA LOS ERRORES DEL ALMACENAMIENTO EN MEMORIA
	INTEGER*4 I,J
	INTEGER*4 LEERVALOR_INT
    CHARACTER*ILONG LEERVALOR,INTTOSTR
    	
	NCENTROS=LEERVALOR_INT(DIR.DAT,'CENTROS','NumCentros')
	NUC=LEERVALOR_INT(DIR.DAT,'NUCLEOS','Nucleos')
	N=LEERVALOR_INT(DIR.DAT,'FBASE','NumFB')
    
! --- ESTRUCTURA DE LOS CENTROS
	DEALLOCATE(CENTROS,STAT=ERROR)
	ALLOCATE (CENTROS(1:NCENTROS),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:NCENTROS) CENTROS(I).NC=I
	FORALL(I=1:NCENTROS) CENTROS(I).X=0.Q0
	FORALL(I=1:NCENTROS) CENTROS(I).Y=0.Q0
	FORALL(I=1:NCENTROS) CENTROS(I).Z=0.Q0
	
! --- ESTRUCTURA DE LOS DATOS DE LOS NÚCLEOS
	DEALLOCATE(NUCLEOS,STAT=ERROR)
	ALLOCATE (NUCLEOS(1:NUC),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:NUC) NUCLEOS(I).N_NUC=I
	FORALL(I=1:NUC) NUCLEOS(I).X=0.Q0
	FORALL(I=1:NUC) NUCLEOS(I).Y=0.Q0
	FORALL(I=1:NUC) NUCLEOS(I).Z=0.Q0
	FORALL(I=1:NUC) NUCLEOS(I).NC=0
	FORALL(I=1:NUC) NUCLEOS(I).CARGA=0.Q0
	
! --- ESTRUCTURA DE LOS DATOS DE LAS FUNCIONES DE BASE
	DEALLOCATE(FB,STAT=ERROR)
	ALLOCATE (FB(0:N),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	
    DO I=1,N
        FB(I).NSFB=LEERVALOR_INT(DIR.DAT,'FBASE','FBase('//TRIM(INTTOSTR(I))//',NumSFB)')
        ALLOCATE (FB(I).SFB(1:FB(I).NSFB),STAT=ERROR)
        IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
    ENDDO
    DO I=0,N !PONE A CERO TODAS LAS VARIABLES DE LAS ESTRUCTURAS
		CALL INI_FB(I)
	END DO
	
    
    DEALLOCATE(CFUNC,STAT=ERROR)
	ALLOCATE (CFUNC(0:N),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	DO I=0,N !PONE A CERO TODAS LAS VARIABLES DE LAS ESTRUCTURAS
		CALL INI_FB(I)
		CALL INI_FBG(CFUNC(I))
	END DO
	
! --- DEFINICION DE ESTRUCTURAS PARA GAUSSIANAS (SE HARÁ EN LA SUBRUTINA DE GAUSSIANAS)
!	DEALLOCATE(GAUSS,STAT=ERROR)
!	ALLOCATE (GAUSS(1:N,1:NGAUSS),STAT=ERROR)
!	IF (ERROR.NE.0) STOP 'NO HAY MEMORIA SUFICIENTE'

! --- ESTRUCTURAS DE LOS DATOS DE LAS INTEGRALES
	N_INT=(N**2-N)/2	!ELEMENTOS DE LAS MATRICES DE INTEGRALES SIMETRICAS SIN LA DIAGONAL PRINCIPAL
	N_INT_D=N_INT+N		!ELEMENTOS DE LAS MATRICES DE INTEGRALES SIMETRICAS CON LA DIAGONAL PRINCIPAL
	N_INT_BI=(N**4+2*N**3+3*N**2+2*N)/8	!NUMERO DE INTEGRALES BIELECTRONICAS DIFERENTES

	DEALLOCATE(S,STAT=ERROR)
	DEALLOCATE(H,STAT=ERROR)
	DEALLOCATE(T,STAT=ERROR)
	DEALLOCATE(V,STAT=ERROR)
	DEALLOCATE(R,STAT=ERROR)
	DEALLOCATE(XMAT,STAT=ERROR)
	DEALLOCATE(YMAT,STAT=ERROR)
	DEALLOCATE(ZMAT,STAT=ERROR)

	ALLOCATE (S(1:N_INT_D),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N_INT_D) S(I)=0.Q0
	ALLOCATE (H(1:N_INT_D),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N_INT_D) H(I)=0.Q0
	ALLOCATE (T(1:N_INT_D),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N_INT_D) T(I)=0.Q0
	ALLOCATE (V(1:N_INT_D),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N_INT_D) V(I)=0.Q0
	ALLOCATE (R(1:N_INT_BI),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N_INT_BI) R(I)=0.Q0
	ALLOCATE (XMAT(1:N_INT_D),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N_INT_D) XMAT(I)=0.Q0
	ALLOCATE (YMAT(1:N_INT_D),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N_INT_D) YMAT(I)=0.Q0
	ALLOCATE (ZMAT(1:N_INT_D),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N_INT_D) ZMAT(I)=0.Q0

	
! --- ESTRUCTURAS DE LOS DATOS DE LOS NUMEROS DE OCUPACION Y COEFICIENTES
	DEALLOCATE(EORA,STAT=ERROR)
	DEALLOCATE(EORB,STAT=ERROR)
	DEALLOCATE(NOC,STAT=ERROR)
	DEALLOCATE(NOCA,STAT=ERROR)
	DEALLOCATE(NOCB,STAT=ERROR)
	DEALLOCATE(CA,STAT=ERROR)
	DEALLOCATE(CB,STAT=ERROR)
	DEALLOCATE(C0A,STAT=ERROR)
	DEALLOCATE(C0B,STAT=ERROR)
	DEALLOCATE(PA,STAT=ERROR)
	DEALLOCATE(PB,STAT=ERROR)
	ALLOCATE (EORA(1:N),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N) EORA(I)=0.Q0
	ALLOCATE (EORB(1:N),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N) EORB(I)=0.Q0
	ALLOCATE (NOC(1:N),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N) NOC(I)=0
	ALLOCATE (NOCA(1:N),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N) NOCA(I)=0
	ALLOCATE (NOCB(1:N),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N) NOCB(I)=0
	ALLOCATE (CA(1:N,1:N),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N,J=1:N) CA(I,J)=0.Q0
	ALLOCATE (CB(1:N,1:N),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N,J=1:N) CB(I,J)=0.Q0
	ALLOCATE (C0A(1:N,1:N),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N,J=1:N) C0A(I,J)=0.Q0
	ALLOCATE (C0B(1:N,1:N),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N,J=1:N) C0B(I,J)=0.Q0
	ALLOCATE (PA(1:N,1:N),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N,J=1:N) PA(I,J)=0.Q0
	ALLOCATE (PB(1:N,1:N),STAT=ERROR)
	IF (ERROR/=0) STOP 'NO HAY MEMORIA SUFICIENTE'
	FORALL(I=1:N,J=1:N) PB(I,J)=0.Q0

    RETURN
    END

! ------------------------------------------------------------------
!	SUBRUTINA QUE PONE A CERO TODAS LAS VARIABLES DE LAS ESTRUCTURAS
!   PARA UNA FUNCION DE BASE
! ------------------------------------------------------------------
	SUBROUTINE INI_FB(IND)
		USE ESTRUCT
		INTEGER*4 IND,I

		FB(IND).NOMBRE=""
		FB(IND).N_FBASE=0
		FB(IND).NTF=0
		FB(IND).ANOR=0.Q0
		FB(IND).NC=0
		FB(IND).X=0.Q0
		FB(IND).Y=0.Q0
		FB(IND).Z=0.Q0
		FB(IND).NSFB=0
        
        DO I=1,FB(IND).NSFB
            FB(IND).SFB(I).NOMBRE=''
            FB(IND).SFB(I).N_SFBASE=I
            FB(IND).SFB(I).COEFICIENTE=0.Q0
            FB(IND).SFB(I).PARAMETRO1=0.Q0
            FB(IND).SFB(I).PARAMETRO2=0.Q0
            FB(IND).SFB(I).PARAMETRO3=0.Q0
            FB(IND).SFB(I).SCNOR=1.Q0
        ENDDO
            
        FB(IND).RECOR.R0=0.Q0
		FB(IND).RECOR.D0=0.Q0
		FB(IND).RECOR.R1=0.Q0
		FB(IND).RECOR.D1=0.Q0
		FB(IND).RECOR.TIPORECORT=0
		FB(IND).RECOR.COEF(1)=0.Q0
		FB(IND).RECOR.COEF(2)=0.Q0
		FB(IND).RECOR.COEF(3)=0.Q0
        FB(IND).RECOR.COEF(4)=0.Q0
		FB(IND).RECOR.COEF(5)=0.Q0
		FB(IND).RECOR.COEF(6)=0.Q0

	END

! ------------------------------------------------------------------
!	SUBRUTINA QUE PONE A CERO TODAS LAS VARIABLES DE LAS ESTRUCTURAS
!   PARA UNA FUNCION DE BASE GENERICA
! ------------------------------------------------------------------
	SUBROUTINE INI_FBG(ARRAY)
		USE ESTRUCT

		RECORD /CF/ARRAY

		ARRAY.NUM=0
		ARRAY.F=""
		ARRAY.ORD=0
		ARRAY.NVI=0
		ARRAY.NM=0
		ARRAY.NP=0
		ARRAY.NF=0
		DO J=1,30
			ARRAY.M(J)=0
			ARRAY.P(J)=0
			ARRAY.FU(J)=0
		END DO
		DO J=1,90
			ARRAY.VI(J)=0.Q0
		END DO
	
	END 

! ------------------------------------------------------------------
!	SUBRUTINA QUE PONE A CERO TODAS LAS VARIABLES DE LAS ESTRUCTURAS
!    DE LAS GAUSSIANAS
! ------------------------------------------------------------------
	SUBROUTINE INIGAUSS(ARRAY)
	USE ESTRUCT

	RECORD /FGAUSS/ARRAY

	ARRAY.GNOR=0.Q0
	ARRAY.GEXP=0.Q0
	ARRAY.GCOEF=0.Q0
	ARRAY.GNX=0
	ARRAY.GNY=0
	ARRAY.GNZ=0

	END 

! --------------------------------------------------------------------
! --- SUBRUTINA QUE LEE LAS INTEGRALES EN EL FICHERO DE INTEGRALES ---
! --------------------------------------------------------------------
	SUBROUTINE LEEINT(MAT,NUMINT)
    USE GLOBAL
	USE ESTRUCT
	INTEGER*4 MAT,NUMINT
	CHARACTER*ILONG LEERVALOR,INTTOSTR
	INTEGER*4 LEERVALOR_INT
	REAL*16 LEERVALOR_REAL
	INTEGER*4 INPQ_F

	MAT=LEERVALOR_INT(DIR.INT,'DATOS','Matrices')
	NUMINT=LEERVALOR_INT(DIR.INT,'DATOS','NumeroIntegrales')
	
	IF (MAT==0)RETURN

	DO I=1,N
		FB(I).ANOR=LEERVALOR_REAL(DIR.INT,'NORMALIZACIONTotal','N('//TRIM(INTTOSTR(I))//')')
	ENDDO
	
	DO I=1,N
		DO J=1,N
			S(INPQ_F(I,J))=LEERVALOR_REAL(DIR.INT,'SOLAPAMIENTO','S('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')')
		ENDDO
	ENDDO
	ESMED=LEERVALOR_REAL(DIR.INT,'SOLAPAMIENTO','ERRORMED')
	ESMAX=LEERVALOR_REAL(DIR.INT,'SOLAPAMIENTO','ERRORMAX')
	
	IF(MAT==1)RETURN

	DO I=1,N
		DO J=1,N
			T(INPQ_F(I,J))=LEERVALOR_REAL(DIR.INT,'CINETICA','T('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')')
			V(INPQ_F(I,J))=LEERVALOR_REAL(DIR.INT,'POTENCIAL','V('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')')
			H(INPQ_F(I,J))=LEERVALOR_REAL(DIR.INT,'ENERGIA','H('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')')
		ENDDO
	ENDDO
	ETMED=LEERVALOR_REAL(DIR.INT,'CINETICA','ERRORMED')
	ETMAX=LEERVALOR_REAL(DIR.INT,'CINETICA','ERRORMAX')
	EVMED=LEERVALOR_REAL(DIR.INT,'POTENCIAL','ERRORMED')
	EVMAX=LEERVALOR_REAL(DIR.INT,'POTENCIAL','ERRORMAX')
	EHMED=LEERVALOR_REAL(DIR.INT,'ENERGIA','ERRORMED')
	EHMAX=LEERVALOR_REAL(DIR.INT,'ENERGIA','ERRORMAX')

    IF(MAT==2)RETURN 

	DO I=1,N
		DO J=1,N
			XMAT(INPQ_F(I,J))=LEERVALOR_REAL(DIR.INT,'MOMENTOX','X('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')')
			YMAT(INPQ_F(I,J))=LEERVALOR_REAL(DIR.INT,'MOMENTOY','Y('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')')
			ZMAT(INPQ_F(I,J))=LEERVALOR_REAL(DIR.INT,'MOMENTOZ','Z('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')')
		ENDDO
	ENDDO
	EXMED=LEERVALOR_REAL(DIR.INT,'MOMENTOX','ERRORMED')
	EXMAX=LEERVALOR_REAL(DIR.INT,'MOMENTOX','ERRORMAX')
	EYMED=LEERVALOR_REAL(DIR.INT,'MOMENTOY','ERRORMED')
	EYMAX=LEERVALOR_REAL(DIR.INT,'MOMENTOY','ERRORMAX')
	EZMED=LEERVALOR_REAL(DIR.INT,'MOMENTOZ','ERRORMED')
	EZMAX=LEERVALOR_REAL(DIR.INT,'MOMENTOZ','ERRORMAX')
	
    IF(MAT==3)RETURN

! ------- LECTURA DE LAS INTEGRALES BIELECTRONICAS: ------
    
	DO K=1,NUMINT	
		CALL IND_PQRS(K,IP,IQ,IR,IS)
		R(K)=LEERVALOR_REAL(DIR.INT,'BIELECTRONICA','R('//TRIM(INTTOSTR(IP))//','//TRIM(INTTOSTR(IQ))//','//TRIM(INTTOSTR(IR))//','//TRIM(INTTOSTR(IS))//')')
	ENDDO
    ERMED=LEERVALOR_REAL(DIR.INT,'BIELECTRONICA','ERRORMED')
	ERMAX=LEERVALOR_REAL(DIR.INT,'BIELECTRONICA','ERRORMAX')
	
	RETURN 
    END

! --------------------------------------------------------------------
! --- SUBRUTINA QUE LEE LAS INTEGRALES EN EL FICHERO DE INTEGRALES ---
! --------------------------------------------------------------------
	SUBROUTINE LEETOQASINT()
    USE GLOBAL
	USE ESTRUCT
	INTEGER*4 NUMINT
	CHARACTER*ILONG LEERVALOR,INTTOSTR
	INTEGER*4 LEERVALOR_INT
	REAL*16 LEERVALOR_REAL
	INTEGER*4 INPQ_F
    
    OPEN(1,FILE=DIR.AUX,STATUS='UNKNOWN')

    DO I=1,N
		READ(1,*)FB(I).ANOR
	ENDDO
	
	DO I=1,N
		DO J=1,N
			READ(1,*)S(INPQ_F(I,J))
		ENDDO
	ENDDO
	READ(1,*)ESMED
	READ(1,*)ESMAX

	DO I=1,N
		DO J=1,N
			READ(1,*)T(INPQ_F(I,J))
		ENDDO
	ENDDO
	READ(1,*)ETMED
	READ(1,*)ETMAX
	DO I=1,N
		DO J=1,N
			READ(1,*)V(INPQ_F(I,J))
		ENDDO
	ENDDO
	READ(1,*)EVMED
	READ(1,*)EVMAX
	DO I=1,N
		DO J=1,N
			READ(1,*)H(INPQ_F(I,J))
		ENDDO
	ENDDO
	READ(1,*)EHMED
	READ(1,*)EHMAX

	DO I=1,N
		DO J=1,N
			READ(1,*)XMAT(INPQ_F(I,J))
		ENDDO
	ENDDO
	READ(1,*)EXMED
	READ(1,*)EXMAX
	DO I=1,N
		DO J=1,N
			READ(1,*)YMAT(INPQ_F(I,J))
		ENDDO
	ENDDO
	READ(1,*)EYMED
	READ(1,*)EYMAX
	DO I=1,N
		DO J=1,N
			READ(1,*)ZMAT(INPQ_F(I,J))
		ENDDO
	ENDDO
	READ(1,*)EZMED
	READ(1,*)EZMAX

	IF (NEL>1)THEN
		NUMINT=LEERVALOR_INT(DIR.INT,'DATOS','NumeroIntegrales')
		!NUMINT=(N**4+2*N**3+3*N**2+2*N)/8
		DO K=1,NUMINT
			CALL IND_PQRS(K,IP,IQ,IR,IS)
			READ(1,*)R(K)
		ENDDO
		READ(1,*)ERMED
		READ(1,*)ERMAX
	ENDIF

	CLOSE(1)
	RETURN 
    END

! -----------------------------------------------------------------------
! --- SUBRUTINA PARA ESCRIBIR LAS INTEGRALES EN UN FICHERO:
! -----------------------------------------------------------------------
	SUBROUTINE ESCINT(MAT,NUMINT)
	USE GLOBAL
	USE ESTRUCT
	CHARACTER*ILONG INTTOSTR
	CHARACTER*ILONG REALTOSTR
	INTEGER*4 MAT,NUMINT
	
	OPEN(1,FILE=DIR.INT,STATUS='UNKNOWN')
	
	WRITE(1,'(A)')'[DATOS]'
	WRITE(1,'(A,A)')'Matrices=',TRIM(INTTOSTR(MAT))
	WRITE(1,'(A,A)')'NumeroIntegrales=',TRIM(INTTOSTR(NUMINT))
	WRITE(1,*)
	
	WRITE(1,'(A)')'[CENTROS]'
	WRITE(1,'(A,A)')'NumCentros=',TRIM(INTTOSTR(NCENTROS))
	DO I=1,NCENTROS
		WRITE(1,'(A,A)')'Centro('//TRIM(INTTOSTR(I))//',X)=',TRIM(REALTOSTR(CENTROS(I).X))
		WRITE(1,'(A,A)')'Centro('//TRIM(INTTOSTR(I))//',Y)=',TRIM(REALTOSTR(CENTROS(I).Y))
		WRITE(1,'(A,A)')'Centro('//TRIM(INTTOSTR(I))//',Z)=',TRIM(REALTOSTR(CENTROS(I).Z))
	ENDDO
	WRITE(1,*)
	
	WRITE(1,'(A)')'[NUCLEOS]'
	WRITE(1,'(A,A)')'NUCLEOS=',TRIM(INTTOSTR(NUC))
	DO I=1,NUC
		WRITE(1,'(A,A)')'Atomo('//TRIM(INTTOSTR(I))//',Centro)=',TRIM(INTTOSTR(NUCLEOS(I).NC))
		WRITE(1,'(A,A)')'Atomo('//TRIM(INTTOSTR(I))//',Znuc)=',TRIM(REALTOSTR(NUCLEOS(I).CARGA))
	ENDDO
	WRITE(1,*)
	
	WRITE(1,'(A)')'[FBASE]'
	WRITE(1,'(A,A)')'NumFB=',TRIM(INTTOSTR(N))
	WRITE(1,'(A,A)')'TipoFB=',TRIM(INTTOSTR(TIPOFB))
	WRITE(1,'(A,A)')'Recortadas=',TRIM(INTTOSTR(RECORT))
	WRITE(1,'(A,A)')'NumGauss=',TRIM(INTTOSTR(NGAUSS))
	DO I=1,N
		WRITE(1,'(A,A)')'FBase('//TRIM(INTTOSTR(I))//',Centro)=',TRIM(INTTOSTR(FB(I).NC))
		WRITE(1,'(A,A)')'FBase('//TRIM(INTTOSTR(I))//',ParteAngular)=',TRIM(INTTOSTR(FB(I).NTF))
        DO J=1,FB(I).NSFB
            WRITE(1,'(A,A)')'FBase('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//',coeficiente)=',TRIM(REALTOSTR(FB(I).SFB(J).COEFICIENTE))
            WRITE(1,'(A,A)')'FBase('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//',normalizacion)=',TRIM(REALTOSTR(FB(I).SFB(J).SCNOR))
            WRITE(1,'(A,A)')'FBase('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//',Parametro1)=',TRIM(REALTOSTR(FB(I).SFB(J).PARAMETRO1))
            WRITE(1,'(A,A)')'FBase('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//',Parametro2)=',TRIM(REALTOSTR(FB(I).SFB(J).PARAMETRO2))
            WRITE(1,'(A,A)')'FBase('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//',Parametro3)=',TRIM(REALTOSTR(FB(I).SFB(J).PARAMETRO3))
		ENDDO
        WRITE(1,'(A,A)')'FBase('//TRIM(INTTOSTR(I))//',RadioCorte0)=',TRIM(REALTOSTR(FB(I).RECOR.R0))
		WRITE(1,'(A,A)')'FBase('//TRIM(INTTOSTR(I))//',AnchuraCorte0)=',TRIM(REALTOSTR(FB(I).RECOR.D0))
		WRITE(1,'(A,A)')'FBase('//TRIM(INTTOSTR(I))//',RadioCorte1)=',TRIM(REALTOSTR(FB(I).RECOR.R1))
		WRITE(1,'(A,A)')'FBase('//TRIM(INTTOSTR(I))//',AnchuraCorte1)=',TRIM(REALTOSTR(FB(I).RECOR.D1))
		WRITE(1,'(A,A)')'FBase('//TRIM(INTTOSTR(I))//',TipoIntCorte)=',TRIM(REALTOSTR(FB(I).RECOR.TIPORECORT))
        WRITE(1,'(A,A)')'FBase('//TRIM(INTTOSTR(I))//',Formula)=',TRIM(FB(I).NOMBRE)
	ENDDO
	WRITE(1,*)
	
	WRITE(1,'(A)')'[METODOINTEGRACION]'	
	WRITE(1,'(A,A)')'Metodo=',CLASMON
	WRITE(1,'(A,A)')'NumeroPuntos=',TRIM(INTTOSTR(NMC))
	WRITE(1,'(A,A)')'Semilla=',TRIM(INTTOSTR(ISEM))
	WRITE(1,'(A,A)')'FPeso(NPolig)=',TRIM(INTTOSTR(NPOLIG))
	WRITE(1,'(A,A)')'FPeso(Inicio)=',TRIM(REALTOSTR(INIR))
	WRITE(1,'(A,A)')'FPeso(Fin)=',TRIM(REALTOSTR(FINR))
	WRITE(1,'(A,A)')'FPeso(Incremento)=',TRIM(INTTOSTR(INCREMENT+1))
	WRITE(1,*)

	WRITE(1,'(A)')'[POTENCIALEXT]'
	WRITE(1,'(A,A)')'Potencial(X)=',TRIM(REALTOSTR(POT(1)))
	WRITE(1,'(A,A)')'Potencial(Y)=',TRIM(REALTOSTR(POT(2)))
	WRITE(1,'(A,A)')'Potencial(Z)=',TRIM(REALTOSTR(POT(3)))
	WRITE(1,*)
	
	IF (MAT==0) THEN
		CLOSE(1)
		RETURN
	ENDIF
	
	OPEN(2,FILE=DIR.AUX,STATUS='REPLACE')
	CLOSE(2)
	OPEN(2,FILE=DIR.AUX,POSITION='APPEND',STATUS='UNKNOWN') !FICHERO AUXILIAR PARA GUARDAR INTEGRALES
	
	WRITE(1,'(A)')'[NORMALIZACIONTOTAL]'
	DO I=1,N
		WRITE(1,'(A,A)')'N('//TRIM(INTTOSTR(I))//')=',TRIM(REALTOSTR(FB(I).ANOR))
		WRITE(2,*)FB(I).ANOR
	ENDDO
	WRITE(1,*)

	WRITE(1,'(A)')'[SOLAPAMIENTO]'
	DO I=1,N
		DO J=1,N
			WRITE(1,'(A,A)')'S('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')=',TRIM(REALTOSTR(S(INPQ_F(I,J))))
			WRITE(2,*)S(INPQ_F(I,J))
		ENDDO
	ENDDO
	WRITE(1,'(A,A)')'ERRORMED=',TRIM(REALTOSTR(ESMED))
	WRITE(1,'(A,A)')'ERRORMAX=',TRIM(REALTOSTR(ESMAX))
	WRITE(1,*)
	WRITE(2,*)ESMED
	WRITE(2,*)ESMAX

	IF (MAT==1) THEN
		CLOSE(1)
		CLOSE(2)
		RETURN
	ENDIF
	
	WRITE(1,'(A)')'[CINETICA]'
	DO I=1,N
		DO J=1,N
			WRITE(1,'(A,A)')'T('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')=',TRIM(REALTOSTR(T(INPQ_F(I,J))))
			WRITE(2,*)T(INPQ_F(I,J))
		ENDDO
	ENDDO
	WRITE(1,'(A,A)')'ERRORMED=',TRIM(REALTOSTR(ETMED))
	WRITE(1,'(A,A)')'ERRORMAX=',TRIM(REALTOSTR(ETMAX))
	WRITE(1,*)
	WRITE(2,*)ETMED
	WRITE(2,*)ETMAX

	WRITE(1,'(A)')'[POTENCIAL]'
	DO I=1,N
		DO J=1,N
			WRITE(1,'(A,A)')'V('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')=',TRIM(REALTOSTR(V(INPQ_F(I,J))))
			WRITE(2,*)V(INPQ_F(I,J))
		ENDDO
	ENDDO
	WRITE(1,'(A,A)')'ERRORMED=',TRIM(REALTOSTR(EVMED))
	WRITE(1,'(A,A)')'ERRORMAX=',TRIM(REALTOSTR(EVMAX))
	WRITE(1,*)
	WRITE(2,*)EVMED
	WRITE(2,*)EVMAX

	WRITE(1,'(A)')'[ENERGIA]'
	DO I=1,N
		DO J=1,N
			WRITE(1,'(A,A)')'H('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')=',TRIM(REALTOSTR(H(INPQ_F(I,J))))
			WRITE(2,*)H(INPQ_F(I,J))
		ENDDO
	ENDDO
	WRITE(1,'(A,A)')'ERRORMED=',TRIM(REALTOSTR(EHMED))
	WRITE(1,'(A,A)')'ERRORMAX=',TRIM(REALTOSTR(EHMAX))
	WRITE(1,*)
	WRITE(2,*)EHMED
	WRITE(2,*)EHMAX
	
	IF (MAT==2) THEN
		CLOSE(1)
		CLOSE(2)
		RETURN
	ENDIF
	
	WRITE(1,'(A)')'[MOMENTOX]'
	DO I=1,N
		DO J=1,N
			WRITE(1,'(A,A)')'X('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')=',TRIM(REALTOSTR(XMAT(INPQ_F(I,J))))
			WRITE(2,*)XMAT(INPQ_F(I,J))
		ENDDO
	ENDDO
	WRITE(1,'(A,A)')'ERRORMED=',TRIM(REALTOSTR(EXMED))
	WRITE(1,'(A,A)')'ERRORMAX=',TRIM(REALTOSTR(EXMAX))
	WRITE(1,*)
	WRITE(2,*)EXMED
	WRITE(2,*)EXMAX
	
	WRITE(1,'(A)')'[MOMENTOY]'
	DO I=1,N
		DO J=1,N
			WRITE(1,'(A,A)')'Y('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')=',TRIM(REALTOSTR(YMAT(INPQ_F(I,J))))
			WRITE(2,*)YMAT(INPQ_F(I,J))
		ENDDO
	ENDDO
	WRITE(1,'(A,A)')'ERRORMED=',TRIM(REALTOSTR(EYMED))
	WRITE(1,'(A,A)')'ERRORMAX=',TRIM(REALTOSTR(EYMAX))
	WRITE(1,*)
	WRITE(2,*)EYMED
	WRITE(2,*)EYMAX
	
	WRITE(1,'(A)')'[MOMENTOZ]'
	DO I=1,N
		DO J=1,N
			WRITE(1,'(A,A)')'Z('//TRIM(INTTOSTR(I))//','//TRIM(INTTOSTR(J))//')=',TRIM(REALTOSTR(ZMAT(INPQ_F(I,J))))
			WRITE(2,*)ZMAT(INPQ_F(I,J))
		ENDDO
	ENDDO
	WRITE(1,'(A,A)')'ERRORMED=',TRIM(REALTOSTR(EZMED))
	WRITE(1,'(A,A)')'ERRORMAX=',TRIM(REALTOSTR(EZMAX))
	WRITE(1,*)
	WRITE(2,*)EZMED
	WRITE(2,*)EZMAX
		
	IF (MAT==3) THEN
		CLOSE(1)
		CLOSE(2)
		RETURN
	ENDIF

	WRITE(1,'(A)')'[BIELECTRONICA]'
	DO K=1,NUMINT	
		CALL IND_PQRS(K,IP,IQ,IR,IS)
		WRITE(1,'(A,A)')'R('//TRIM(INTTOSTR(IP))//','//TRIM(INTTOSTR(IQ))//','//TRIM(INTTOSTR(IR))//','//TRIM(INTTOSTR(IS))//')=',TRIM(REALTOSTR(R(K)))
		WRITE(2,*)R(K)
	ENDDO
	WRITE(1,'(A,A)')'ERRORMED=',TRIM(REALTOSTR(ERMED))
	WRITE(1,'(A,A)')'ERRORMAX=',TRIM(REALTOSTR(ERMAX))
	WRITE(1,*)
	WRITE(2,*)ERMED
	WRITE(2,*)ERMAX
	 
	CLOSE(1)
	CLOSE(2)
	RETURN
	
    END

!**********************************************************************
!**** SUBRUTINAS Y FUNCIONES PARA MEJORAR LA ESCRITURA DE DATOS     ***
!**********************************************************************
!----------------------------------------------      
!--- RUTINA PARA INTRODUCIR N LINEAS EN BLANCO:                     
!----------------------------------------------
	SUBROUTINE LINEA(N,NUNIT)
	INTEGER*4 N,NUNIT

	IF(NUNIT.EQ.0)THEN
		DO I=1,N
			WRITE(*,*)'  '
		ENDDO
	ELSE
		DO I=1,N
			WRITE(NUNIT,*)'  '
		ENDDO
	ENDIF
	RETURN
	END

!----------------------------------------------      
!--- SEPARADOR
!----------------------------------------------
	SUBROUTINE SEPARADOR(NCAR,CAR,NLINEAS,ARCHIVO)
	INTEGER*4 NLINEAS,NCAR,CAR,ARCHIVO
	
	CALL LINEA(NLINEAS,ARCHIVO)
	CALL CARACTER(NCAR,ARCHIVO,CAR)
	CALL LINEA(NLINEAS,ARCHIVO)
	END

!---------------------------------------------------------
!--- RUTINA QUE INTRODUCE UNA LINEA CON N GUIONES:
!---------------------------------------------------------
	SUBROUTINE CARACTER(N,NUNIT,J)
	INTEGER*4 N,J,NUNIT
	DIMENSION M(80)
	CHARACTER M*1
	DO I=1,80
		IF(J.EQ.1)M(I)='-'
		IF(J.EQ.2)M(I)='='
		IF(J.EQ.3)M(I)='*' 
		IF(J.EQ.4)M(I)='+'    
		IF(J.EQ.5)M(I)='.'
	ENDDO
	IF(J.EQ.6)THEN
		DO I=1,N/2
			M(I)='<'
		ENDDO
		DO I=N/2+1,N
			M(I)='>'
		ENDDO
	ENDIF
	IF(NUNIT.EQ.0)THEN
!		WRITE(*,*)(M(I),I=1,N)
	ELSE 
		WRITE(NUNIT,*)(M(I),I=1,N)
	ENDIF
	RETURN

	END


!**********************************************************************
!**** SUBRUTINAS Y FUNCIONES PARA EL MANEJO DE MATRICES             ***
!**********************************************************************
!----------------------------------------------------------------------
	SUBROUTINE MATOUT(N,M,MATRIZ,C,F)
!   Sirve para imprimir una matriz de forma ordenada:
!----------------------------------------------------------------------     
	INTEGER*4 N,M,N1,N2,K,KK,J,C,F
	REAL*16 MATRIZ(N,N)

	    N1=1
	    N2=C
		NNN=1+N/C
		IF(N==C*(N/C))NNN=NNN-1
		DO K=1,NNN
	      !WRITE(F,'(A1)')
		  IF(N<N2)N2=N
	      WRITE(F,'(/,12X,9(I7,2X),/)')(I,I=N1,N2)
		  DO KK=1,M
		    IF(KK.LT.10)&
		     WRITE(F,'(8X,I1,2X,9F9.4)')KK,(MATRIZ(KK,J),J=N1,N2)
		    IF((KK.GE.10).AND.(KK.LT.100))&
		     WRITE(F,'(7X,I2,2X,9F9.4)')KK,(MATRIZ(KK,J),J=N1,N2)
		    IF((KK.GE.100).AND.(KK.LT.1000))&
		     WRITE(F,'(6X,I3,2X,9F9.4)')KK,(MATRIZ(KK,J),J=N1,N2)
		    IF(KK.GE.1000)&
		     WRITE(F,'(5X,I4,2X,9F9.4)')KK,(MATRIZ(KK,J),J=N1,N2)
		  ENDDO
	      N1=N1+C
	      N2=N2+C	
	    ENDDO

		WRITE(F,'(A1)')
		RETURN
		
	END

!----------------------------------------------------------------------
	SUBROUTINE MATOUTL(NL,N,MATRIZ,C,F)
!   Sirve para imprimir una matriz lineal de forma ordenada:
!----------------------------------------------------------------------
	INTEGER*4 N,N1,N2,K,C,F
	INTEGER*4 KK,J
	REAL*16 MATRIZ(NL)

	    N1=1
	    N2=C
		NNN=1+N/C
		IF(N==C*(N/C))NNN=NNN-1
		DO K=1,NNN
	      !WRITE(F,'(A1)')
		  IF(N<N2)N2=N
	      WRITE(F,'(/,12X,9(I7,3X),/)')(I,I=N1,N2)
		  DO KK=1,N
		    IF(KK.LT.10)&
		     WRITE(F,'(8X,I1,2X,9F10.4)')KK,(MATRIZ(INPQ_F(KK,J)),J=N1,N2)
		    IF((KK.GE.10).AND.(KK.LT.100))&
		     WRITE(F,'(7X,I2,2X,9F10.4)')KK,(MATRIZ(INPQ_F(KK,J)),J=N1,N2)
		    IF((KK.GE.100).AND.(KK.LT.1000))&
		     WRITE(F,'(6X,I3,2X,9F10.4)')KK,(MATRIZ(INPQ_F(KK,J)),J=N1,N2)
		    IF(KK.GE.1000)&
		     WRITE(F,'(5X,I4,2X,9F10.4)')KK,(MATRIZ(INPQ_F(KK,J)),J=N1,N2)
		  ENDDO
	      N1=N1+C
	      N2=N2+C	
	    ENDDO
		
		!WRITE(F,'(A1)')
		RETURN
		END

! -------------------------------------------------------------------
!          SUBRUTINA PARA DIAGONALIZAR MATRICES SIMETRICAS
! -------------------------------------------------------------------
	SUBROUTINE JACOBI(N,A,T,SORT)
    IMPLICIT REAL*16(A-H,O-Z)
	INTEGER*4 N
    REAL*16 A(1:N,1:N),T(1:N,1:N)
	LOGICAL SORT
    PARAMETER CERO=1.Q-20
   
   	FORALL (I=1:N,J=1:N)T(I,J)=0.Q0
	FORALL (I=1:N)T(I,I)=1.Q0
	
    L=N*N*25
    DO IM=1,L
		AMAX=0.Q0
		DO I=2,N
			DO J=1,(I-1)
				IF(AMAX<QABS(A(I,J)))THEN
					AMAX=QABS(A(I,J))
					I2=I
					J2=J
				ENDIF
			ENDDO
		ENDDO
		IF (AMAX<CERO)EXIT
		AS=.5Q0*(A(I2,I2)+A(J2,J2))
		AD=.5Q0*(A(I2,I2)-A(J2,J2))
		A2=A(I2,J2)
		RR=QSQRT(AD*AD+A2*A2)
		C2=QABS(AD)/RR
		S2=A2/RR
		IF(A(J2,J2)<=A(I2,I2)) S2=-S2
		C1=QSQRT((1.Q0+C2)/2.Q0)
		S1=.5Q0*S2/C1
		DO K=1,N
			Z1=A(K,I2)
			Z2=A(K,J2)
			A(K,I2)=Z1*C1-Z2*S1
			A(I2,K)=A(K,I2)
			A(K,J2)=Z1*S1+Z2*C1
			A(J2,K)=A(K,J2)
		END DO
		A(I2,I2)=AS+AD*C2-A2*S2
		A(J2,J2)=AS-AD*C2+A2*S2
		A(I2,J2)=0.Q0
		A(J2,I2)=0.Q0
		DO K=1,N
			T1=T(K,I2)
			T2=T(K,J2)
			T(K,I2)=C1*T1-S1*T2
			T(K,J2)=S1*T1+C1*T2
		END DO
	END DO
!    WRITE(6,100) IM,AMAX
!100 FORMAT(1X,'TRAS ',I4,'ITERACIONES NO SE HA LOGRADO PRECISION ','REQUERIDA AMAX= ',F10.7)

! ----- ORDENACION DE VECTORES PROPIOS Y VALORES PROPIOS: --------
    IF (SORT==.TRUE.)THEN
		DO I=1,N-1
			DO J=I+1,N
				IF(A(I,I)>A(J,J)) THEN
					AUXI=A(I,I)
					A(I,I)=A(J,J)
					A(J,J)=AUXI
					DO K=1,N
						AUXI=T(K,I)
						T(K,I)=T(K,J)
						T(K,J)=AUXI
					END DO
				ENDIF
			END DO
		END DO
	ENDIF
    T=TRANSPOSE(T) !PARA QUE LOS AUTOVECTORES ESTÉN ORDENADOS POR FILA
	A=TRANSPOSE(A) 
	END


!**********************************************************************
!**** SUBRUTINAS Y FUNCIONES PARA EL CALCULO DE FACTORIALES         ***
!**********************************************************************
! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DE FACTORIALES ()!
! -------------------------------------------------------------
    REAL*16 FUNCTION FACT(NUM)
    INTEGER*4 NUM,J
    FACT=1.0Q0
    IF(NUM==0)RETURN
	DO J=1,NUM
		FACT=FACT*J
	END DO
    RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DE FACTORIALES IMPARES  ()!!
! ---   !!SOLO ES VÁLIDO PARA NÚMEROS IMPARES!!
! -------------------------------------------------------------
    REAL*16 FUNCTION FACT1(NUM)
    INTEGER*4 NUM,J
    FACT1=1.0Q0
    IF(NUM<=0)RETURN
	DO J=1,NUM,2
		FACT1=FACT1*J
	END DO
    RETURN
    END

! -------------------------------------------------
! --  SUBPROGRAMA PARA EL CALCULO DE FACTORIALES:
! --  (ENTEROS)
! -------------------------------------------------
	INTEGER*4 FUNCTION NFAC(NUM)
	INTEGER*4 NUM
	
	NFAC=1
	IF(NUM==0)RETURN
	DO J=1,NUM
		NFAC=NFAC*J
	END DO
	RETURN
	END

!**********************************************************************
!**** SUBRUTINAS Y FUNCIONES PARA CALCULAR EL TIEMPO                ***
!**********************************************************************
! ----------------------------------------------------------
! ----  SUBPROGRAMA PARA DETERMINAR EL TIEMPO EMPLEADO  ----
! ----------------------------------------------------------
	SUBROUTINE TIEMPO(SS,D,H,M,S,T)
	REAL*8 SS,S,AUX,AUX1
	INTEGER*4 D,H,M
	CHARACTER*(*) T
	CHARACTER*250 INTTOSTR,REALTOSTR
	
	AUX=INT(SS/60.D0)
	S=MOD(SS,60.D0)
	AUX1=INT(AUX/60.D0)
	M=MOD(AUX,60.D0)
	D=INT(AUX1/24.D0)
	H=MOD(AUX1,24.D0)

	T=''
	IF (D/=0)T=TRIM(INTTOSTR(D))//' D'
	IF (H/=0)T=TRIM(T)//'  '//TRIM(INTTOSTR(H))//' H'
	IF (M/=0)T=TRIM(T)//'  '//TRIM(INTTOSTR(M))//' ´'
	T=TRIM(T)//'  '//TRIM(INTTOSTR(IDNINT(S)))//' ´´'

	RETURN
    END

!***************************************************************************
!**** SUBRUTINAS PARA CONVERSION DE COORDENADAS ENTRE CARTESIANAS Y POLARES*
!***************************************************************************
! ---------------------------------------------------------------------
! SUBRUTINA QUE PASA DE COORDENADAS CARTESIANAS A POLARES
!   TOMA UNA ESTRUCTURA DE DATOS X,Y,Z Y DEVUELVE OTRA R,COS(THETA),FI
! ---------------------------------------------------------------------
	SUBROUTINE CAR2POLAR(P,PP)
	USE ESTRUCT
	USE GLOBAL
	IMPLICIT NONE
	TYPE(XYZ)P
	TYPE(RCSTFI)PP

	PP.R=QSQRT(P.X*P.X+P.Y*P.Y+P.Z*P.Z)
	IF (PP.R==0.Q0)THEN
		PP.CST=0.Q0
		PP.FI=0.Q0
	ELSE
		PP.CST=P.Z/PP.R
	END IF
	PP.FI=QSIGN(1.Q0,P.Y)*PI/2.Q0
    IF(P.X*P.X>CERO)PP.FI=QATAN2(P.Y,P.X)

	END 

! ---------------------------------------------------------------------
! SUBRUTINA QUE PASA DE COORDENADAS POLARES A CARTESIANAS
!   TOMA UNA ESTRUCTURA DE DATOS R,COS(THETA),FI Y DEVUELVE OTRA X,Y,Z
! ---------------------------------------------------------------------
	SUBROUTINE POLAR2CAR(PP,P)
	USE ESTRUCT
	IMPLICIT NONE
	TYPE(XYZ)P
	TYPE(RCSTFI)PP
	REAL*16 AUX

	AUX=PP.R*QSQRT(1.Q0-PP.CST**2)
	P.X=AUX*QCOS(PP.FI)
	P.Y=AUX*QSIN(PP.FI)
	P.Z=PP.R*PP.CST

	END 

! ---------------------------------------------------------------------
!   SUBRUTINA QUE PASA DE COORDENADAS ELIPSOIDALES A CARTESIANAS
!   TOMA UNA ESTRUCTURA DE DATOS R=LANDA,COS(THETA)=MU,FI=FI Y DEVUELVE OTRA X,Y,Z
! ---------------------------------------------------------------------
	SUBROUTINE SPHER2CAR(PP,DISTCENTROS,P)
	USE ESTRUCT
	IMPLICIT NONE
	TYPE(XYZ)P
	TYPE(RCSTFI)PP
	REAL*16 AUX,DISTCENTROS

	AUX=DISTCENTROS*QSQRT((PP.R**2-1.Q0)*(1.Q0-PP.CST**2))/2.Q0
	P.X=AUX*QCOS(PP.FI)
	P.Y=AUX*QSIN(PP.FI)
	P.Z=DISTCENTROS*PP.R*PP.CST/2.Q0

	END 

! -------------------------------------------------------------------------
!	SUBRUTINA QUE DEFINE LOS NOMBRES DE LOS FICHEROS DE DATOS Y RESULTADOS
! -------------------------------------------------------------------------
	SUBROUTINE DEFINE_FICH(VARFICH,VARDIR,FICHD,EXTENSION)
	USE GLOBAL
	USE ESTRUCT
	CHARACTER*(*) VARFICH,VARDIR,FICHD,EXTENSION
	INTEGER*4 ERR
	
	ERR=GETCWD(DIRE)

	VARFICH=TRIM(FICHD)//'.'//TRIM(EXTENSION)
	
	IF (EXTENSION=='DAT')THEN
		VARDIR=TRIM(DIRE)//'\DATOS\'//TRIM(VARFICH)
	ELSE
		VARDIR=TRIM(DIRE)//'\RESULT\'//TRIM(VARFICH)
	ENDIF
	
	END 

!--------------------------------------------------------------------
!   FUNCION QUE DADOS LOS INDICES IP E IQ, INDICES DE LOS ELEMENTOS
!   DE UNA MATRIZ SIMETRICA, DEVUELVE EL INDICE INPQ PARA PODER
!   ALMACENARLOS EN UN ARRAY LINEAL
!--------------------------------------------------------------------
    INTEGER*4 FUNCTION INPQ_F(IP,IQ)
	INTEGER*4 IP,IQ

    IF(IP>IQ) THEN
		INPQ_F=(IP*(IP-1))/2+IQ
	    RETURN
    ELSE
		INPQ_F=(IQ*(IQ-1))/2+IP
	    RETURN
    ENDIF
    END

!--------------------------------------------------------------------
!    SUBPROGRAMA PARA ALMACENAR LOS ARRAYS BIDIMENSIONALES SIMETRICOS
!    EN ARRAYS MONODIMENSIONALES APROBECHANDO SU SIMETRIA
!--------------------------------------------------------------------
    SUBROUTINE CONVERT(SMATRIZ,N,S)
    REAL*16 SMATRIZ(N,N),S((N*(N-1)/2)+N)

    DO I=1,N
		DO J=I,N
			S(INPQ_F(I,J))=SMATRIZ(I,J)
		END DO
    END DO

    END

!--------------------------------------------------------------------
!--SUBRUTINA PARA CALCULAR LOS INDICES IP E IQ CONOCIDO EL INDICE
!   INPQ
!--------------------------------------------------------------------
    SUBROUTINE INDPQ(INPQ,IP,IQ)
	INTEGER*4 IP,IQ,INPQ

    IP=1
    IQ=1
    IF(INPQ==1) RETURN
    IQ=2
10  INDICE=IQ*(IQ-1)/2
    IF((INDICE/INPQ)<1) THEN
		IQ=IQ+1
	    GOTO 10
    ENDIF
    IQ=IQ-1
    IP=INPQ-(IQ*(IQ-1)/2)
    RETURN
    END

!--------------------------------------------------------------------
!    FUNCION QUE DADOS LOS INDICES P,Q,R Y S, INDICES DE LOS ELEMENTOS
!    DE UNA MATRIZ <PQ|RS>, DEVUELVE EL INDICE K PARA PODER
!    IDENTIFICARLOS
!--------------------------------------------------------------------
    INTEGER*4 FUNCTION INDK(IP,IQ,IR,IS)
	INTEGER*4 IP,IQ,IR,IS

    INPQ=INPQ_F(IP,IQ)
    INRS=INPQ_F(IR,IS)
    INDK=INPQ_F(INPQ,INRS)

    RETURN

    END

!--------------------------------------------------------------------
!    SUBRUTINA DONDE DADO EL INDICE K DE LAS INTEGRALES BIELECTRONICAS
!    <PQ|RS>, DEVUELVE LOS INDICES IP,IQ,IR,IS
!--------------------------------------------------------------------
    SUBROUTINE IND_PQRS(K,IP,IQ,IR,IS)
	INTEGER*4 K
	INTEGER*4 IP,IQ,IR,IS

	CALL INDPQ(K,IPQ,IRS)
	CALL INDPQ(IPQ,IP,IQ)
	CALL INDPQ(IRS,IR,IS)

    END

!***************************************************************************
!**** SUBRUTINAS PARA COMUNICACION CON VISUAL BASIC*
!***************************************************************************
	SUBROUTINE MENSAJES(MEN0,MEN1,PORC)
	USE ESTRUCT, ONLY:ILONG,DIR
	CHARACTER*(ILONG) MEN0,MEN1
	REAL*16 PORC

	OPEN(20,FILE=DIR.SCR) !FICHERO SCRATCH PARA COMUNICAR FORTRAN CON VBASIC
	
	WRITE(20,'(A)')TRIM(MEN0)
	WRITE(20,'(A)')TRIM(MEN1)
	WRITE(20,'(F5.1)')PORC
	CLOSE(20)
    END

    
!***************************************************************************************
! SUBRUTINAS DE CONVERSION DE DATOS (NUMEROS A CADENAS Y CADENAS A NUMEROS)
!***************************************************************************************

!------------------------------------------------------------------------------------
! SUBRUTINA QUE DEVUELVE UN REAL*16 DE UNA CADENA DE CARACTERES 
!------------------------------------------------------------------------------------
REAL*16 FUNCTION STRTODBLE(STR)
    CHARACTER(LEN=*) STR

    READ(STR,*)STRTODBLE
END FUNCTION
!------------------------------------------------------------------------------------
!
! SUBRUTINA QUE DEVUELVE UN ENTERO DE UNA CADENA DE CARACTERES
!
!------------------------------------------------------------------------------------
INTEGER*4 FUNCTION STRTOINT(STR)
    CHARACTER(LEN=*) STR

    READ(STR,*)STRTOINT
END FUNCTION
!------------------------------------------------------------------------------------
!
! SUBRUTINA QUE DEVUELVE VERDADERO SI LA CADENA ES UN NUMERO
!
!------------------------------------------------------------------------------------
LOGICAL FUNCTION ISNUMBER(STR)

	CHARACTER*(*),INTENT(IN) :: STR
	INTEGER*2 I

	ISNUMBER=.TRUE.
	DO I=1,LEN_TRIM(STR)
		IF((STR(I:I)<'0'.OR.STR(I:I)>'9').AND.STR(I:I)/='.'.AND.STR(I:I)/='-'.AND.STR(I:I)/='+')THEN
			ISNUMBER=.FALSE.
			RETURN
      	ENDIF
	ENDDO

    RETURN
END

! ----------------------------------------------------------------------------
!     FUNCION QUE NOS DICE SI UN NÚMERO ES PAR O IMPAR
! ----------------------------------------------------------------------------
LOGICAL FUNCTION ISPAR(N)
	INTEGER*4 N

	ISPAR=.TRUE.
	IF(MOD(N,2) /= 0)ISPAR=.FALSE.
	RETURN
END

! --------------------------------------------------------------------
! ---   FUNCION QUE DEVUELVE TRUE SI ES UN ENTERO Y FALSE SI NO LO ES
! --------------------------------------------------------------------
LOGICAL FUNCTION ISINT(NUMI)
	REAL*16 NUMI,NUM

	NUM=ABS(NUMI)
	IF(NUM-INT(NUM)>0.Q0)THEN
		ISINT=.FALSE.
	ELSE
		ISINT=.TRUE.
	ENDIF
END

!***************************************************************************************
! SUBRUTINAS PARA EL TRATAMIENTO DE CADENAS DE CARACTERES
!***************************************************************************************

!------------------------------------------------------------------------------------
!
! SUBRUTINA QUE LEE UNA CADENA DE CARACTERES Y LA DIVIDE EN UN ARRAY DE PALABRAS
! DEPENDIENDO DEL SEPARADOR ENTRE PALABRAS
!
!------------------------------------------------------------------------------------
SUBROUTINE SPLIT(CADENA,SEPARADOR,SUBCADENA,NSUB)
	CHARACTER*(*) CADENA
	CHARACTER*1 SEPARADOR,CAD
	INTEGER*2 L,I,NSUB,FLAG,INI(1:50),FIN(1:50)
	CHARACTER*(*) SUBCADENA(1:50)
	CHARACTER*300 CADENA1
	
	CADENA1=ADJUSTL(CADENA)  !QUITA LOS ESPACIOS EN BLANCO DEL PRINCIPIO Y LOS PONE AL FINAL

	FLAG=0 !NOS DICE SI ESTA LEYENDO CARACTERES EN BLANCO
	NSUB=1
	INI(1)=1
	L=LEN_TRIM(CADENA1)
	DO I=1,L
		CAD=CADENA1(I:I)
		IF (CAD==SEPARADOR) THEN
			IF(FLAG==0)THEN
				FLAG=1
				FIN(NSUB)=I-1
				NSUB=NSUB+1
				INI(NSUB)=I+1
			ELSE
				INI(NSUB)=INI(NSUB)+1
			ENDIF
		ELSE
			FLAG=0
		ENDIF
	ENDDO
	FIN(NSUB)=L
	
	DO I=1,NSUB
		SUBCADENA(I)=CADENA1(INI(I):FIN(I))
	ENDDO
	DO I=1,NSUB
		SUBCADENA(I)=ADJUSTL(SUBCADENA(I))
	ENDDO
END SUBROUTINE
    
    
! -------------------------------------------------------------------
! SUBRUTINA QUE LEE UNA CADENA DE CARACTERES Y LA DIVIDE EN UN ARRAY DE CADENAS
! DEPENDIENDO DEL SEPARADOR ENTRE PALABRAS Y DEVUELVE EL ELEMENTO NUMERO NUM
! -------------------------------------------------------------------
INTEGER*4 FUNCTION SPLIT_INT(CADENA,SEPARADOR,NUM)
    CHARACTER*(*) CADENA
	CHARACTER*4 SUBCADENA(1:50)
    CHARACTER*1 SEPARADOR
	INTEGER*2 I,NSUB
    INTEGER*4 STRTOINT
    	    
    CALL SPLIT(CADENA,SEPARADOR,SUBCADENA,NSUB)
    
    IF (NSUB>=NUM) THEN
        SPLIT_INT=STRTOINT(SUBCADENA(NUM))
    ELSE
        SPLIT_INT=0
    ENDIF
    END FUNCTION

!**********************************************************************************
! FUNCIONES PARA GENERAR NUMEROS ALEATORIOS
!**********************************************************************************
! -------------------------------------------------------------
! --- FUNCION RAN      
! --- CALCULA UN NUMERO ALEATORIO COMPRENDIDO ENTRE 0 Y 1 
! --- IDUM = SEMILLA DE CUATRO CIFRAS  
! --- TOMADA DE LA PAG 1142 DE *NUMERICAL RECIPES FORTRAN 90* 
! -------------------------------------------------------------
    FUNCTION RAN(idum)
        IMPLICIT NONE
        INTEGER, PARAMETER :: K4B=selected_int_kind(9)
        INTEGER(K4B), INTENT(INOUT) :: idum
        REAL :: ran
        INTEGER(K4B), PARAMETER :: IA=16807,IM=2147483647,IQ=127773,IR=2836
        REAL, SAVE :: am
        INTEGER(K4B), SAVE :: ix=-1,iy=-1,k
        
        if (idum <= 0 .or. iy < 0) then 
            am=nearest(1.0,-1.0)/IM
            iy=ior(ieor(888889999,abs(idum)),1)
            ix=ieor(777755555,abs(idum))
            idum=abs(idum)+1
        end if
        ix=ieor(ix,ishft(ix,13))
        ix=ieor(ix,ishft(ix,-17))
        ix=ieor(ix,ishft(ix,5))
        k=iy/IQ
        iy=IA*(iy-k*IQ)-IR*k
        if (iy < 0) iy=iy+IM
        ran=am*ior(iand(IM,ieor(ix,iy)),1)
    END
    
! -------------------------------------------------------------
! ---  SUBPROGRAMA  HALTON
! ---  CALCULA UN NUMERO ALEATORIO COMPRENDIDO ENTRE 0 Y 1 
! ---  POR EL METODO DE HALTON CON BASE "n1"
! ---  Berblinger, M. y Schlier, C. 
! ---  Comp. Phys. Com. <66>, 157-166, (1991)
! ---  (Genera bien hasta unos 2*10**8 puntos)
! -------------------------------------------------------------
    REAL*16 FUNCTION HALTON(N1,NRA1,NRB1)
    IMPLICIT NONE
    INTEGER*8 NRA1,NRB1,NXA1,NXB1
    INTEGER*4 N1
    
    NXA1=NRB1-NRA1
! --- CASO INICIAL:
    IF(NXA1==1)THEN
		NRA1=1
		NRB1=NRB1*N1
    ELSE
    ! --- CASO GENERAL:
        NXB1=NRB1/N1
        DO WHILE (NXA1<=NXB1)
            NXB1=NXB1/N1
        ENDDO
        NRA1=(1+N1)*NXB1-NXA1
    ENDIF
    HALTON=DFLOAT(NRA1)/DFLOAT(NRB1)
    RETURN
    END

! -------------------------------------------------------------
! ---  SUBPROGRAMA  HAS
! ---  CALCULA UN NUMERO ALEATORIO COMPRENDIDO ENTRE 0 Y 1 
! ---  POR EL METODO DE HASELGROVE CON BASE "bas"
! ---  "n" ES EL NUMERO DE ORDEN DEL PUNTO CALCULADO.
! -------------------------------------------------------------
    REAL*16 FUNCTION HAS(BAS,DN)
    IMPLICIT NONE
	REAL*16 BAS,DN,RN,AUX
    
    AUX=DN*BAS
    HAS=AUX-QINT(AUX)
    RETURN
    END