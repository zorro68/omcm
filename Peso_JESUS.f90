!---------------------------------------------------------------------
!  SUBROUTINE QUE CALCULA LA FUNCION DE PESO Y SU CENTRO
!---------------------------------------------------------------------
	SUBROUTINE PESO_CENTRO_EXP(NB1,NB2,P1,P2,P12,ARPR,ATOTR,ARPT,ARPF,PPOLIGR,PPOLIGT,PPOLIGF,STRPOLIGR,STRPOLIGT,STRPOLIGF,EXPO)!EXPOx,EXPOy,EXPOz)
	USE ESTRUCT
	USE GLOBAL
	RECORD/XYZ/P1,P2,P12	!COORDENADAS CARTESIANAS DEL CENTRO DE LAS 
							!FUNCIONES DE BASE Y DEL CENTRO
	RECORD/XY/PPOLIGR(1:INCREMENT+1),PPOLIGT(1:INCREMENT+1),PPOLIGF(1:INCREMENT+1)
	REAL*8 STRPOLIGR(INCREMENT),STRPOLIGT(INCREMENT),STRPOLIGF(INCREMENT)
	REAL*8 RG1,RG2,DENO,EXPO
	CHARACTER*1 CI
	REAL*8 AREXPR,ATOTR,ARPR,ARPT,ARPF
	REAL*8 EXPOx,EXPOy,EXPOz,EXPOx_OLD,EXPOy_OLD,EXPOz_OLD
	REAL*8 AUX1,AUX2,BETA1,BETA2,BETA3
	INTEGER*4 POTx1,POTy1,POTz1,POTx2,POTy2,POTz2,i,NB1,NB2


	IF (EXGEN==1) THEN  !SI SON GENÉRICAS LAS CENTRAMOS EN EL CENTRO
		SELECT CASE (NPOLIG)
			CASE (1)
				CALL POLI_R(NB1,NB2,ARPR,AREXPR,ATOTR,PPOLIGR,STRPOLIGR,P1,P2,P12)
			CASE (2)
				CALL POLI_R(NB1,NB2,ARPR,AREXPR,ATOTR,PPOLIGR,STRPOLIGR,P1,P2,P12)
				CALL POLI_ANG(NB1,NB2,ARPT,PPOLIGT,STRPOLIGT,'T',P1,P2,P12)
			CASE (3)
				CALL POLI_R(NB1,NB2,ARPR,AREXPR,ATOTR,PPOLIGR,STRPOLIGR,P1,P2,P12)
				CALL POLI_ANG(NB1,NB2,ARPT,PPOLIGT,STRPOLIGT,'T',P1,P2,P12)
				CALL POLI_ANG(NB1,NB2,ARPF,PPOLIGF,STRPOLIGF,'F',P1,P2,P12)
		END SELECT
	ELSE

	!SELECCION DEL EXPONENTE DE LA FUNCION DE PESO

		IF (UNASOLA==1)THEN
			IF(CLASINT=='S'.OR.CLASINT=='s')THEN
				CI=CLASINT	
			ELSE
				CI=STIPO
			ENDIF
		ELSE
			CI=CLASINT
		ENDIF
		
		IF((CI=='S').OR.(CI=='J'))THEN
!       CALCULOS NECESARIOS PARA ESTIMAR EL CENTRO Y LOS EXPONENTES:
  
!		CENTRADO DE LA FUNCION DE PESO:

		  AUX1=FB(NB1).N
		  AUX2=FB(NB2).N
		  !ALPHA1=FB(NB1).ALFA
		  !ALPHA2=FB(NB2).ALFA
		  IF(((FB(NB1).N-INT(FB(NB1).N))<1.0D-8).AND.((FB(NB2).N-INT(FB(NB2).N))==0))THEN

			IF(FB(NB1).ALFA>1E-10)THEN	
				BETA1=BETA_1G(NB1,1,AUX1,FB(NB1).ALFA)+FB(NB1).BETA
			  ELSE !EL EXPONENTE DEL STO ES CERO
				BETA1=BETA_1G(NB1,2,AUX1,FB(NB1).BETA)
			END IF

			IF(FB(NB2).BETA>1E-10)THEN
				BETA2=BETA_1G(NB2,1,AUX2,FB(NB2).ALFA)+FB(NB2).BETA
			  ELSE !EL EXPONENTE DEL STO ES CERO
				BETA2=BETA_1G(NB2,2,AUX2,FB(NB2).BETA)
			END IF

		    P12.X=(BETA1*P1.X + BETA2*P2.X)/(BETA1+BETA2)
		    P12.Y=(BETA1*P1.Y + BETA2*P2.Y)/(BETA1+BETA2)
		    P12.Z=(BETA1*P1.Z + BETA2*P2.Z)/(BETA1+BETA2)
		  ELSE !EL EXP. DE LA PARTE POL. NO ES ENTERO
		    !BETA1=BETA_1G(NB1,3,AUX1,FB(NB1).ALFA)
			BETA1=BETA_1G(NB1,3,FB(NB1).N,FB(NB1).ALFA)
		    BETA2=BETA_1G(NB2,3,AUX2,FB(NB2).ALFA)
		    P12.X=(BETA1*P1.X + BETA2*P2.X)/(BETA1+BETA2)
		    P12.Y=(BETA1*P1.Y + BETA2*P2.Y)/(BETA1+BETA2)
		    P12.Z=(BETA1*P1.Z + BETA2*P2.Z)/(BETA1+BETA2)          
          END IF
!       ESTIMACION DE LOS EXPONENTES DE LA FUNCION DE PESO:

		  AUX1=0.0D0
		  AUX2=0.0D0
		  EXPO=4.0D0*(BETA1+BETA2)/7.0D0
		  EXPO=DSQRT(EXPO/0.270949809063431D0)
		  IF((CLASMON.EQ.'HAM').OR.(CLASMON.EQ.'HAS').OR.(CLASMON.EQ.'HAL').OR.(CLASMON.EQ.'RND'))THEN
			CALL CORREC_PESO(NB1,NB2,CI,EXPO)
		  ELSE
			CALL CORREC_PESO_MIXT(NB1,NB2,CI,EXPO)
		  END IF
		  CONTINUE
		END IF

		IF(CI=='T')THEN

!       CALCULOS NECESARIOS PARA ESTIMAR EL CENTRO Y LOS EXPONENTES:
!		CENTRADO DE LA FUNCION DE PESO:

		  AUX1=FB(NB1).N
		  AUX2=FB(NB2).N
		  !ALPHA1=FB(NB1).ALFA
		  !ALPHA2=FB(NB2).ALFA
		  IF(((FB(NB1).N-INT(FB(NB1).N))<1.0D-8).AND.((FB(NB2).N-INT(FB(NB2).N))==0))THEN

			IF(FB(NB1).ALFA>1E-10)THEN	
				BETA1=BETA_1G(NB1,1,AUX1,FB(NB1).ALFA)+FB(NB1).BETA
			  ELSE !EL EXPONENTE DEL STO ES CERO
				BETA1=BETA_1G(NB1,2,AUX1,FB(NB1).BETA)
			END IF

			IF(FB(NB2).ALFA>1E-10)THEN
				!BETA2=BETA_1G(NB2,4,AUX2,FB(NB2).ALFA)+FB(NB2).BETA
			  BETA2=BETA_1G(NB2,1,AUX2,FB(NB2).ALFA)+FB(NB2).BETA
			  !ELSE !EL EXPONENTE DEL STO ES CERO
				!BETA2=BETA_1G(NB2,2,AUX2,FB(NB2).BETA)
			END IF

		    P12.X=(BETA1*P1.X + BETA2*P2.X)/(BETA1+BETA2)
		    P12.Y=(BETA1*P1.Y + BETA2*P2.Y)/(BETA1+BETA2)
		    P12.Z=(BETA1*P1.Z + BETA2*P2.Z)/(BETA1+BETA2)
		  ELSE !EL EXP. DE LA PARTE POL. NO ES ENTERO
		    !BETA1=BETA_1G(NB1,3,AUX1,FB(NB1).ALFA)
			BETA1=BETA_1G(NB1,3,FB(NB1).N,FB(NB1).ALFA)
		    !BETA2=BETA_1G(NB2,4,AUX2,FB(NB2).ALFA)
			BETA2=BETA_1G(NB2,3,AUX2,FB(NB2).ALFA)
		    P12.X=(BETA1*P1.X + BETA2*P2.X)/(BETA1+BETA2)
		    P12.Y=(BETA1*P1.Y + BETA2*P2.Y)/(BETA1+BETA2)
		    P12.Z=(BETA1*P1.Z + BETA2*P2.Z)/(BETA1+BETA2)          
          END IF
!       ESTIMACION DE LOS EXPONENTES DE LA FUNCION DE PESO:

		  AUX1=0.0D0
		  AUX2=0.0D0
		 !EXPO=4.0D0*(BETA1+BETA2)/7.0D0
		  EXPO=(BETA1+BETA2)/2.0D0
		  EXPO=DSQRT(EXPO/0.270949809063431D0)
		  CALL CORREC_PESO(NB1,NB2,CI,EXPO)

		 !EXPO=0.5357142855D0*(BETA1+BETA2) !VALOR INTERMEDIO ENTRE "S" y "V"
		END IF

		IF(CI=='V')THEN

!       CALCULOS NECESARIOS PARA ESTIMAR EL CENTRO Y LOS EXPONENTES:  
!		CENTRADO DE LA FUNCION DE PESO:
		  !BETA3=0.02342774D0
		  !BETA3=0.046D0
		  BETA3=0.0D0
		  AUX1=FB(NB1).N
		  AUX2=FB(NB2).N
		  !ALPHA1=FB(NB1).ALFA
		  !ALPHA2=FB(NB2).ALFA
		  IF(((FB(NB1).N-INT(FB(NB1).N))<1.0D-8).AND.((FB(NB2).N-INT(FB(NB2).N))==0))THEN

			IF(FB(NB1).ALFA>1E-10)THEN	
				BETA1=BETA_1G(NB1,1,AUX1,FB(NB1).ALFA)+FB(NB1).BETA
			  ELSE !EL EXPONENTE DEL STO ES CERO
				BETA1=BETA_1G(NB1,2,AUX1,FB(NB1).BETA)
			END IF

			IF(FB(NB2).ALFA>1E-10)THEN
				BETA2=BETA_1G(NB2,1,AUX2,FB(NB2).ALFA)+FB(NB2).BETA+BETA3
			  ELSE !EL EXPONENTE DEL STO ES CERO
				BETA2=BETA_1G(NB2,2,AUX2,FB(NB2).BETA)+BETA3
			END IF

		    P12.X=(BETA1*P1.X + BETA2*P2.X)/(BETA1+BETA2)
		    P12.Y=(BETA1*P1.Y + BETA2*P2.Y)/(BETA1+BETA2)
		    P12.Z=(BETA1*P1.Z + BETA2*P2.Z)/(BETA1+BETA2)
		  ELSE !EL EXP. DE LA PARTE POL. NO ES ENTERO
		    !BETA1=BETA_1G(NB1,3,AUX1,FB(NB1).ALFA)
			BETA1=BETA_1G(NB1,3,FB(NB1).N,FB(NB1).ALFA)
		    BETA2=BETA_1G(NB2,3,AUX2,FB(NB2).ALFA)+BETA3
		    P12.X=(BETA1*P1.X + BETA2*P2.X)/(BETA1+BETA2)
		    P12.Y=(BETA1*P1.Y + BETA2*P2.Y)/(BETA1+BETA2)
		    P12.Z=(BETA1*P1.Z + BETA2*P2.Z)/(BETA1+BETA2)          
          END IF
!       ESTIMACION DE LOS EXPONENTES DE LA FUNCION DE PESO:

		  AUX1=0.0D0
		  AUX2=0.0D0
         !EXPO=4.0D0*(BETA1+BETA2)/7.0D0
		  EXPO=(BETA1+BETA2)/2.0D0
		  EXPO=DSQRT(EXPO/0.270949809063431D0)
		  CALL CORREC_PESO(NB1,NB2,CI,EXPO)
		END IF

		IF(CI=='H')THEN
		  DENO= FB(NB1).N+FB(NB2).N+2.5D0
	      RG1=DSQRT(FB(NB1).BETA)
		  RG2=DSQRT(FB(NB2).BETA)
		  EXPO= (FB(NB1).ALFA+FB(NB2).ALFA+RG1+RG2)/DENO
		END IF
		IF(CI=='X')THEN
		  DENO= FB(NB1).N+FB(NB2).N+4.0D0
		  RG1=DSQRT(FB(NB1).BETA)
		  RG2=DSQRT(FB(NB2).BETA)
		  EXPO= (FB(NB1).ALFA+FB(NB2).ALFA+RG1+RG2)/DENO
		  CALL CORREC_PESO(NB1,NB2,CI,EXPO)
		END IF
		IF(CI=='Y')THEN
		  DENO= FB(NB1).N+FB(NB2).N+4.0D0
		  RG1=DSQRT(FB(NB1).BETA)
		  RG2=DSQRT(FB(NB2).BETA)
		  EXPO= (FB(NB1).ALFA+FB(NB2).ALFA+RG1+RG2)/DENO
		  CALL CORREC_PESO(NB1,NB2,CI,EXPO)
		END IF
		IF(CI=='Z')THEN
		  DENO= FB(NB1).N+FB(NB2).N+4.0D0
		  RG1=DSQRT(FB(NB1).BETA)
		  RG2=DSQRT(FB(NB2).BETA)
		  EXPO= (FB(NB1).ALFA+FB(NB2).ALFA+RG1+RG2)/DENO
		  CALL CORREC_PESO(NB1,NB2,CI,EXPO)
		END IF
		 
	END IF	
	
	
	RETURN
	END SUBROUTINE


!--------------------------------------------------------------------------
!    SUBRUTINA QUE CALCULA EL EXPONENTE DE LA GAUSSIANA AJUSTADA 
!                        A UNA FUNCION
!--------------------------------------------------------------------------
!	EXISTEN VARIOS TIPOS DE AJUSTES:
!    1 - UNA FUNCION TIPO STO(nS) ---> GTO(1S) (n=0,1,2,3,...):   TIPO=1
!    2 - UNA FUNCION TIPO GTO(nS) ---> GTO(1S) (n=1,2,3,4,...):   TIPO=2
!    3 - UNA FUNCION TIPO STO(nS) ---> GTO(1S) (AJUSTE NUMERICO): TIPO=3
!        CON POT. DE "R" NO ENTERAS
!    4 -     UNA FUNCION TIPO:    ---> GTO(1S) (AJUSTE NUMERICO): TIPO=4
!            OPERADOR(T)*R(r)
!    X - UNA FUNCION DE OTRO TIPO ---> GTO(1S) (AJUSTE NUMERICO): TIPO=X
!
!	 EXPR y ALPHA - SE DEFINEN EN: (R**EXPR)*DEXP(-ALPHA*(R ó R**2)
!--------------------------------------------------------------------------

	REAL*8 FUNCTION BETA_1G(NB,TIPO,EXPR,ALPHA)
	USE ESTRUCT
	USE GLOBAL
	REAL*8 EXPR,EXPR1,ALPHA
	INTEGER*4 NB,TIPO
	REAL*8 a,b,hAB,SUMA1,SUMA2,SUMA11,SUMA22,INTEGR1,INTEGR2,valor
	REAL*8 BETA,BETA_OLD,BETAi,BETAf,VALORi,VALORf,BETAm,VALORm
	INTEGER*4 NINTER,i

    !EXPR1=FB(NB).N

	  IF(TIPO==1)THEN !STO(nS) ---> GTO(1S)
		  SELECT CASE(INT(EXPR))
		    CASE(-2)
		      BETA_1G= 1074.41231699058*ALPHA*ALPHA
		    CASE(-1)
		      BETA_1G= 2.29635793438470*ALPHA*ALPHA
		    CASE(0)
		      BETA_1G= 0.270949809063431*ALPHA*ALPHA
		    CASE(1)
		      BETA_1G= 0.101215108431081*ALPHA*ALPHA
		    CASE(2)
		      BETA_1G= 5.296881756861357D-2*ALPHA*ALPHA
		    CASE(3)
		      BETA_1G= 3.264600273603965D-2*ALPHA*ALPHA
		    CASE(4)
		      BETA_1G= 2.216912938304575D-2*ALPHA*ALPHA
		    CASE(5)
		      BETA_1G= 1.605395681123100D-2*ALPHA*ALPHA
		    CASE(6)
		      BETA_1G= 1.217031606996791D-2*ALPHA*ALPHA
		    CASE(7)
		      BETA_1G= 9.548170625583583D-3*ALPHA*ALPHA
		    CASE(8)
		      BETA_1G= 7.693499070949992D-3*ALPHA*ALPHA
		    CASE(9)
		      BETA_1G= 6.332845613724622D-3*ALPHA*ALPHA
		    CASE(10)
		      BETA_1G= 5.304741082098575D-3*ALPHA*ALPHA
		  END SELECT
	  ELSE IF(TIPO==2)THEN !GTO(nS) ---> GTO(1S)
		  SELECT CASE(INT(EXPR))
			CASE(0)
			  BETA_1G= ALPHA
		    CASE(1)
		      BETA_1G= 0.6D0*ALPHA
		    CASE(2)
		      BETA_1G= 0.428571428571440*ALPHA
		    CASE(3)
		      BETA_1G= (1.0D0/3.0D0)*ALPHA
		    CASE(4)
		      BETA_1G= 0.272727272727273*ALPHA
		    CASE(5)
		      BETA_1G= 0.230769230769236*ALPHA
		    CASE(6)
		      BETA_1G= 0.2D0*ALPHA
		    CASE(7)
		      BETA_1G= 0.176470588235297*ALPHA
		    CASE(8)
		      BETA_1G= 0.157894736842106*ALPHA
		    CASE(9)
		      BETA_1G= 0.142857142857141*ALPHA
		    CASE(10)
		      BETA_1G= 0.130434782608694*ALPHA
		  END SELECT
      ELSE IF(TIPO==3)THEN !GTO(1S) (AJUSTE NUMERICO)
		  NINTER=5000
		  a=1.0D-4
		  b=20.0D0
		  hAB=(b-a)/DFLOAT(NINTER)
		  BETA=1.0D-4
		  BETA_OLD=0.0D0

		  DO WHILE(DABS(BETA-BETA_OLD)>1.0D-5)
			  BETA_OLD=BETA

		!	  CALCULO DE LAS INTEGRALES NECESARIAS PARA LA OPTIMIZACION

			  CALL Fx1(a,BETA,EXPR,valor)
			  INTEGR1=valor
			  INTEGR2=valor*a*a
			  CALL Fx1(b,BETA,EXPR,valor)
			  INTEGR1=INTEGR1+valor
			  INTEGR2=INTEGR2+valor*b*b
			  CALL Fx1(a+hAB,BETA,EXPR,valor)
			  INTEGR1=INTEGR1+4.0D0*valor
			  INTEGR2=INTEGR2+4.0D0*valor*(a+hAB)*(a+hAB)

		!	  CALL Fx2(a,BETA,EXPR,valor)
		!	  INTEGR2=valor
		!	  CALL Fx2(b,BETA,EXPR,valor)
		!	  INTEGR2=INTEGR2+valor
		!	  CALL Fx2(a+hAB,BETA,EXPR,valor)
		!	  INTEGRAL2=INTEGR2+4.0D0*valor
		!	  INTEGR2=INTEGR2+4.0D0*valor	

			  SUMA1=0.0D0
			  SUMA2=0.0D0
			  SUMA11=0.0D0
			  SUMA22=0.0D0

			  DO i=2,NINTER/2
				CALL Fx1((a+(2.0D0*i-2.0D0)*hAB),BETA,EXPR,valor)
				SUMA1=SUMA1+valor
				SUMA11=SUMA11+valor*((a+(2.0D0*i-2.0D0)*hAB)**2)
				CALL Fx1((a+(2.0D0*i-1.0D0)*hAB),BETA,EXPR,valor)
				SUMA2=SUMA2+valor
				SUMA22=SUMA22+valor*((a+(2.0D0*i-1.0D0)*hAB)**2)

		!		CALL Fx2((a+(2.0D0*i-2.0D0)*hAB),BETA,EXPR,valor)
		!		SUMA11=SUMA11+valor
		!		CALL Fx2((a+(2.0D0*i-1.0D0)*hAB),BETA,EXPR,valor)
		!		SUMA22=SUMA22+valor
			  END DO

			  INTEGR1=hAB*(INTEGR1+(2.0D0*SUMA1)+(4.0D0*SUMA2))/3.0D0
			  INTEGR2=hAB*(INTEGR2+(2.0D0*SUMA11)+(4.0D0*SUMA22))/3.0D0
			  BETA=(3.0D0/4.0D0)*(INTEGR1/INTEGR2)
		  END DO

		  BETA_1G=BETA*ALPHA*ALPHA

      ELSE IF(TIPO==4)THEN !OPERADOR(T)*R(r) ---> GTO(1S)
		  NINTER=2000
		  a=1.0D-1
		  !a=1.0D0
		  !IF(FB(NB).N==0.0D0)a=1.0D0
		  b=10.0D0
		  hAB=(b-a)/DFLOAT(NINTER)
!		  BETA=1.0D-4
!		  BETA_OLD=0.0D0
		  BETAi=1.0D-2
		  BETAf=4.0D1
		  BETAm=0.0D0
		  VALORi=0.0D0
		  VALORf=0.0D0
		  VALORm=0.0D0
		! DO WHILE(DABS(BETA-BETA_OLD)>1.0D-5)
		  DO WHILE((BETAf-BETAi)>1.0D-4)
		!	  BETA_OLD=BETA

		!	  CALCULO DE VALORi: FUNCION DE LA QUE OBTENDREMOS LA RAIZ

			  CALL Tx1(a,BETAi,EXPR,valor,NB)
			  INTEGR1=valor
			  INTEGR2=valor*a*a
			  CALL Tx1(b,BETAi,EXPR,valor,NB)
			  INTEGR1=INTEGR1+valor
			  INTEGR2=INTEGR2+valor*b*b
			  CALL Tx1(a+hAB,BETAi,EXPR,valor,NB)
			  INTEGR1=INTEGR1+4.0D0*valor
			  INTEGR2=INTEGR2+4.0D0*valor*(a+hAB)*(a+hAB)

			  SUMA1=0.0D0
			  SUMA2=0.0D0
			  SUMA11=0.0D0
			  SUMA22=0.0D0

			  DO i=2,NINTER/2
				CALL Tx1((a+(2.0D0*i-2.0D0)*hAB),BETAi,EXPR,valor,NB)
				SUMA1=SUMA1+valor
				SUMA11=SUMA11+valor*(a+(2.0D0*i-2.0D0)*hAB)**2
				CALL Tx1((a+(2.0D0*i-1.0D0)*hAB),BETAi,EXPR,valor,NB)
				SUMA2=SUMA2+valor
				SUMA22=SUMA22+valor*(a+(2.0D0*i-1.0D0)*hAB)**2
			  END DO

			  INTEGR1=hAB*(INTEGR1+(2.0D0*SUMA1)+(4.0D0*SUMA2))/3.0D0
			  INTEGR2=hAB*(INTEGR2+(2.0D0*SUMA11)+(4.0D0*SUMA22))/3.0D0
			  !BETA=(3.0D0/4.0D0)*(INTEGR1/INTEGR2)
			  VALORi=(3.0D0/4.0D0)*(INTEGR1/INTEGR2)-BETAi

		!	  CALCULO DE VALORf: FUNCION DE LA QUE OBTENDREMOS LA RAIZ

			  CALL Tx1(a,BETAf,EXPR,valor,NB)
			  INTEGR1=valor
			  INTEGR2=valor*a*a
			  CALL Tx1(b,BETAf,EXPR,valor,NB)
			  INTEGR1=INTEGR1+valor
			  INTEGR2=INTEGR2+valor*b*b
			  CALL Tx1(a+hAB,BETAf,EXPR,valor,NB)
			  INTEGR1=INTEGR1+4.0D0*valor
			  INTEGR2=INTEGR2+4.0D0*valor*(a+hAB)*(a+hAB)

			  SUMA1=0.0D0
			  SUMA2=0.0D0
			  SUMA11=0.0D0
			  SUMA22=0.0D0

			  DO i=2,NINTER/2
				CALL Tx1((a+(2.0D0*i-2.0D0)*hAB),BETAf,EXPR,valor,NB)
				SUMA1=SUMA1+valor
				SUMA11=SUMA11+valor*(a+(2.0D0*i-2.0D0)*hAB)**2
				CALL Tx1((a+(2.0D0*i-1.0D0)*hAB),BETAf,EXPR,valor,NB)
				SUMA2=SUMA2+valor
				SUMA22=SUMA22+valor*(a+(2.0D0*i-1.0D0)*hAB)**2
			  END DO

			  INTEGR1=hAB*(INTEGR1+(2.0D0*SUMA1)+(4.0D0*SUMA2))/3.0D0
			  INTEGR2=hAB*(INTEGR2+(2.0D0*SUMA11)+(4.0D0*SUMA22))/3.0D0
			  !BETA=(3.0D0/4.0D0)*(INTEGR1/INTEGR2)
			  VALORf=(3.0D0/4.0D0)*(INTEGR1/INTEGR2)-BETAf

			  BETAm=(BETAf+BETAi)/2.0D0

		!	  CALCULO DE VALORf: FUNCION DE LA QUE OBTENDREMOS LA RAIZ

			  CALL Tx1(a,BETAm,EXPR,valor,NB)
			  INTEGR1=valor
			  INTEGR2=valor*a*a
			  CALL Tx1(b,BETAm,EXPR,valor,NB)
			  INTEGR1=INTEGR1+valor
			  INTEGR2=INTEGR2+valor*b*b
			  CALL Tx1(a+hAB,BETAm,EXPR,valor,NB)
			  INTEGR1=INTEGR1+4.0D0*valor
			  INTEGR2=INTEGR2+4.0D0*valor*(a+hAB)*(a+hAB)

			  SUMA1=0.0D0
			  SUMA2=0.0D0
			  SUMA11=0.0D0
			  SUMA22=0.0D0

			  DO i=2,NINTER/2
				CALL Tx1((a+(2.0D0*i-2.0D0)*hAB),BETAm,EXPR,valor,NB)
				SUMA1=SUMA1+valor
				SUMA11=SUMA11+valor*(a+(2.0D0*i-2.0D0)*hAB)**2
				CALL Tx1((a+(2.0D0*i-1.0D0)*hAB),BETAm,EXPR,valor,NB)
				SUMA2=SUMA2+valor
				SUMA22=SUMA22+valor*(a+(2.0D0*i-1.0D0)*hAB)**2
			  END DO

			  INTEGR1=hAB*(INTEGR1+(2.0D0*SUMA1)+(4.0D0*SUMA2))/3.0D0
			  INTEGR2=hAB*(INTEGR2+(2.0D0*SUMA11)+(4.0D0*SUMA22))/3.0D0
			  !BETA=(3.0D0/4.0D0)*(INTEGR1/INTEGR2)
			  VALORm=(3.0D0/4.0D0)*(INTEGR1/INTEGR2)-BETAm

			  IF((DSIGN(1.0D0,VALORi)).EQ.(DSIGN(1.0D0,VALORm)))THEN
				BETAi=BETAm
			  !IF((DSIGN(1.0D0,VALORf)).EQ.(DSIGN(1.0D0,VALORm)))THEN
			  ELSE
				BETAf=BETAm
			  END IF

		  END DO

		  !BETA_1G=BETAm
		  !BETA_1G=BETA/2.0D0
		  BETA_1G=BETAm/2.0D0
		  CONTINUE
	  END IF

	
	RETURN
	END FUNCTION

! INTEGRANDO DE LA FUNCION DEL NUMERADOR 

	SUBROUTINE Fx1(x,BETA,EXPR1,valor)
	USE ESTRUCT
	USE GLOBAL
	REAL*8 x,valor,BETA,EXPR1
	  valor=0.0D0
	  valor=x*x*DEXP(-BETA*x*x)*(x**EXPR1)*DEXP(-x)
	RETURN
	END 

! INTEGRANDO DE LA FUNCION DEL DENOMINADOR

	SUBROUTINE Fx2(x,BETA,EXPR1,valor)
	USE ESTRUCT
	USE GLOBAL
	REAL*8 x,valor,BETA,EXPR1
	  valor=0.0D0
	  valor=(x**4)*DEXP(-BETA*x*x)*(x**EXPR1)*DEXP(-x)
	RETURN
	END 
! INTEGRANDO DE LA FUNCION DEL NUMERADOR

	SUBROUTINE Tx1(x,BETA,EXPR1,valor,NB)
	USE ESTRUCT
	USE GLOBAL
	REAL*8 x,valor,BETA,EXPR1
	INTEGER*4 NB
	  valor=0.0D0
	  !valor=x*x*DEXP(-BETA*x*x)*DABS(TBASE2(NB,x)) ! OPERADOR_T*FUNCION
	  valor=x*x*DEXP(-BETA*x*x)*((TBASE2(NB,x))**2) ! OPERADOR_T*FUNCION
	  !valor=x*x*DEXP(-BETA*x*x)*(TBASE2(NB,x)) ! OPERADOR_T*FUNCION
	RETURN
	END 

! INTEGRANDO DE LA FUNCION DEL DENOMINADOR

	SUBROUTINE Tx2(x,BETA,EXPR1,valor,NB)
	USE ESTRUCT
	USE GLOBAL
	REAL*8 x,valor,BETA,EXPR1
	INTEGER*4 NB
	  valor=0.0D0
	  valor=(x**4)*DEXP(-BETA*x*x)*TBASE2(NB,x) ! OPERADOR_T*FUNCION
	RETURN
	END 

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL OPERADOR  T
! ---   APLICADO A UNA FUNCION DE BASE 
! -------------------------------------------------------------
    DOUBLE PRECISION FUNCTION TBASE2(NB,X)
	USE GLOBAL
	USE ESTRUCT
	IMPLICIT REAL*8(A-H,O-Z)
	INTEGER*4 NB
	!RECORD/RCSTFI/POL !,POL1,POL2

    L=0
    IF(FB(NB).NTF>=1)L=1
    IF(FB(NB).NTF>=4)L=2
    IF(FB(NB).NTF>=9)L=3
    
	CALL DEV_FBASE2(NB,X,PRIMERAD,SEGUNDAD)

	TBASE2=SEGUNDAD+PRIMERAD*2.D0/X
    TBASE2=TBASE2-DFLOAT(L*(L+1))*(X**FB(NB).N)*DEXP(-FB(NB).ALFA*X-FB(NB).BETA*X*X)/X**2
    TBASE2=-0.5D0*TBASE2

	RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DE LA DERIVADA PRIMERA Y SEGUNDA
! ---   ANALITICA RESPECTO A R DE UNA FUNCION DE BASE.
! -------------------------------------------------------------
	SUBROUTINE DEV_FBASE2(NB,X,DT1,DT2)
	USE GLOBAL
	USE ESTRUCT
	IMPLICIT REAL*8(A-H,O-Z)
	REAL*8 DT1,DT2,ALPHA,BETA,RAUX,X
	INTEGER*4 NAUX,NB

!	RECORD/RCSTFI/P

	IF(FB(NB).BETA<1.0D-12)THEN	! EXPONENCIAL SIMPLE	
		DT1 = 0.0D0
		DT2 = 0.0D0

		ALPHA = FB(NB).ALFA
		NAUX = FB(NB).N
		
		DT1 = DEXP(-ALPHA*X)*(NAUX*X**(NAUX-1) - ALPHA*X**NAUX)
		!DT1 = DT1*FACTANG(FB(NB).NTF,P.CST,P.FI) 
		
		DT2 = DEXP(-ALPHA*X)*((ALPHA**2)*(X**NAUX)-2.0D0*ALPHA*NAUX &
		*X**(NAUX-1) + NAUX*(NAUX-1)*X**(NAUX-2))
		!DT2 = DT2*FACTANG(FB(NB).NTF,P.CST,P.FI) 
	ELSE  ! EXPONENCIAL COMPUESTA
		DT1 = 0.0D0
		DT2 = 0.0D0

		ALPHA = FB(NB).ALFA
		BETA = FB(NB).BETA
		NAUX = FB(NB).N
		
		DT1 = DEXP(-ALPHA*X-BETA*X**2)*(NAUX*X**(NAUX-1) - (ALPHA+2.0D0*BETA*X)*X**NAUX)
		!DT1 = DT1*FACTANG(FB(NB).NTF,P.CST,P.FI) 
		
		DT2 = DEXP(-ALPHA*X-BETA*X**2)*( &
		(-ALPHA-BETA*X**2)*(NAUX*X**(NAUX-1)-(X**NAUX)*(ALPHA+2.0D0*BETA*X)) &
		+(NAUX*(NAUX-1)*X**(NAUX-2) - NAUX*X**(NAUX-1)*ALPHA &
		-2.0D0*BETA*(NAUX+1)*X**NAUX)) 
		!DT2 = DT2*FACTANG(FB(NB).NTF,P.CST,P.FI) 
	END IF

	RETURN
	END

!---------------------------------------------------------------------
!  SUBROUTINE PARA CORREGIR EL PARAMETRO DE LA FUNCION DE PESO
!---------------------------------------------------------------------
	SUBROUTINE CORREC_PESO(NB1,NB2,CI,ALPHA)
	  REAL*8 ALPHA,ALPHA1,ALPHA2,ALPHA3,VAR_ALPHA1,VAR_ALPHA2,VAR_ALPHA3,VAR_INT
	  REAL*8 brent
	  CHARACTER*1 CI
	  INTEGER*4 NB1,NB2,VALE
		
		VALE=0
		ALPHA2=ALPHA
		ALPHA1=ALPHA2/2.0D0
		ALPHA3=ALPHA2+ALPHA1
		
		VAR_ALPHA1=VAR_INT(NB1,NB2,CI,ALPHA1)
		VAR_ALPHA2=VAR_INT(NB1,NB2,CI,ALPHA2)
		VAR_ALPHA3=VAR_INT(NB1,NB2,CI,ALPHA3)
		IF((VAR_ALPHA1.EQ.VAR_ALPHA2).OR.(VAR_ALPHA1.EQ.VAR_ALPHA3).OR.(VAR_ALPHA2.EQ.VAR_ALPHA3))RETURN 

		DO WHILE(VALE.EQ.0)
			IF((VAR_ALPHA1.GT.VAR_ALPHA2).AND.(VAR_ALPHA2.LT.VAR_ALPHA3))THEN
				VALE=1
			ELSE IF((VAR_ALPHA1.LT.VAR_ALPHA2).AND.(VAR_ALPHA2.LT.VAR_ALPHA3))THEN
				ALPHA3=ALPHA2
				ALPHA2=ALPHA1
				VAR_ALPHA3=VAR_ALPHA2
				VAR_ALPHA2=VAR_ALPHA1
				ALPHA1=ALPHA2/2.0D0
				VAR_ALPHA1=VAR_INT(NB1,NB2,CI,ALPHA1)
			ELSE IF((VAR_ALPHA1.GT.VAR_ALPHA2).AND.(VAR_ALPHA2.GT.VAR_ALPHA3))THEN
				ALPHA1=ALPHA2
				ALPHA2=ALPHA3
				VAR_ALPHA1=VAR_ALPHA2
				VAR_ALPHA2=VAR_ALPHA3
				ALPHA3=ALPHA2+(ALPHA2/2.0D0)
				VAR_ALPHA3=VAR_INT(NB1,NB2,CI,ALPHA3)
			END IF
		END DO
		VAR_ALPHA1=brent(NB1,NB2,CI,ALPHA1,ALPHA2,ALPHA3,1.0D-4,ALPHA)
		           
	  RETURN
	END
!---------------------------------------------------------------------
!  FUNCION PARA CALCULAR LA VARIANZA DE LA INTEGRAL
!---------------------------------------------------------------------
	FUNCTION VAR_INT(NB1,NB2,CI,ALPHA)
	REAL*8 ALPHA,VAR_INT,a,b,hAB,INTEGR1,SUMA1,SUMA2,INTEGRANDO_RADIAL
	CHARACTER*1 CI
	INTEGER*4 NB1,NB2,NINTER
		      
	  VAR_INT=0.0D0
	  INTEGR1=0.0D0

!	  CALCULO DE LAS INTEGRALES NECESARIAS PARA LA OPTIMIZACION
	  NINTER=5000
	  a=1.0D-4
	  b=20.0D0
	  hAB=(b-a)/DFLOAT(NINTER)

	  INTEGR1=INTEGRANDO_RADIAL(NB1,NB2,CI,ALPHA,a)
	  INTEGR1=INTEGR1+INTEGRANDO_RADIAL(NB1,NB2,CI,ALPHA,b)
	  INTEGR1=INTEGR1+4.0D0*INTEGRANDO_RADIAL(NB1,NB2,CI,ALPHA,a+hAB)
	  
	  SUMA1=0.0D0
	  SUMA2=0.0D0
	  
	  DO i=2,NINTER/2
		  SUMA1=SUMA1+INTEGRANDO_RADIAL(NB1,NB2,CI,ALPHA,(a+(2.0D0*i-2.0D0)*hAB))
		  SUMA2=SUMA2+INTEGRANDO_RADIAL(NB1,NB2,CI,ALPHA,(a+(2.0D0*i-1.0D0)*hAB))
	  END DO

	  !INTEGR1=hAB*(INTEGR1+(2.0D0*SUMA1)+(4.0D0*SUMA2))/3.0D0
	  VAR_INT=hAB*(INTEGR1+(2.0D0*SUMA1)+(4.0D0*SUMA2))/3.0D0

	RETURN
	END

!---------------------------------------------------------------------
!  FUNCION QUE CALCULA LA PARTE RADIAL DE LA FUNCION DE BASE
!---------------------------------------------------------------------
	FUNCTION INTEGRANDO_RADIAL(NB1,NB2,CI,ALPHA,X)
	USE GLOBAL
	USE ESTRUCT
	REAL*8 FBASE_RADIAL,INTEGRANDO_RADIAL,X,ALPHA
	CHARACTER*1 CI
	INTEGER*4 NB1,NB2

		INTEGRANDO_RADIAL=0.0D0

		IF((CI.EQ.'S').OR.(CI.EQ.'J'))THEN
		
			INTEGRANDO_RADIAL=FBASE_RADIAL(NB1,X)*FBASE_RADIAL(NB2,X)*X*X
			INTEGRANDO_RADIAL=INTEGRANDO_RADIAL*INTEGRANDO_RADIAL
			!INTEGRANDO_RADIAL=INTEGRANDO_RADIAL/( DSQRT(ALPHA)*DEXP(-ALPHA*X*X) )
			INTEGRANDO_RADIAL=INTEGRANDO_RADIAL/( ALPHA*DEXP(-ALPHA*X) )

		ELSE IF(CI.EQ.'T')THEN

			INTEGRANDO_RADIAL=FBASE_RADIAL(NB1,X)*TBASE2(NB2,X)*X*X
			INTEGRANDO_RADIAL=INTEGRANDO_RADIAL*INTEGRANDO_RADIAL
			!INTEGRANDO_RADIAL=INTEGRANDO_RADIAL/( DSQRT(ALPHA)*DEXP(-ALPHA*X*X) )
			INTEGRANDO_RADIAL=INTEGRANDO_RADIAL/( ALPHA*DEXP(-ALPHA*X) )

		ELSE IF(CI.EQ.'V')THEN
		
			INTEGRANDO_RADIAL=FBASE_RADIAL(NB1,X)*FBASE_RADIAL(NB2,X)*X
			INTEGRANDO_RADIAL=INTEGRANDO_RADIAL*INTEGRANDO_RADIAL
			!INTEGRANDO_RADIAL=INTEGRANDO_RADIAL/( DSQRT(ALPHA)*DEXP(-ALPHA*X*X) )
			INTEGRANDO_RADIAL=INTEGRANDO_RADIAL/( ALPHA*DEXP(-ALPHA*X) )

		ELSE IF((CI.EQ.'X').OR.(CI.EQ.'Y').OR.(CI.EQ.'Z'))THEN
			INTEGRANDO_RADIAL=FBASE_RADIAL(NB1,X)*FBASE_RADIAL(NB2,X)*X*X*X
			INTEGRANDO_RADIAL=INTEGRANDO_RADIAL*INTEGRANDO_RADIAL
			!INTEGRANDO_RADIAL=INTEGRANDO_RADIAL/( DSQRT(ALPHA)*DEXP(-ALPHA*X*X) )
			INTEGRANDO_RADIAL=INTEGRANDO_RADIAL/( ALPHA*DEXP(-ALPHA*X) )
		!ELSE IF(CI.EQ.'Y')THEN
		!ELSE IF(CI.EQ.'Z')THEN						
		END IF

	RETURN
	END 

!---------------------------------------------------------------------
!  FUNCION QUE CALCULA LA PARTE RADIAL DE LA FUNCION DE BASE
!---------------------------------------------------------------------
	FUNCTION FBASE_RADIAL(NB,X)
	USE GLOBAL
	USE ESTRUCT
	REAL*8 X,FBASE_RADIAL
	INTEGER*4 NB

	FBASE_RADIAL=0.0D0
	IF (EXGEN==1) THEN
		FBASE_RADIAL=CALCFUNC(X,CFUNC(NB))
	ELSE IF (EXGEN==0) THEN
		FBASE_RADIAL=X**FB(NB).N*DEXP(-FB(NB).ALFA*X-FB(NB).BETA*X**2)
	END IF
	IF(RECORT==1.OR.RECORT==2) THEN
		FBASE_RADIAL=FBASE_RADIAL*SIGMA(NB,X)
    ENDIF
	
	RETURN
	END 


!---------------------------------------------------------------------
!  SUBROUTINE QUE CALCULA LA FUNCION DE PESO
!---------------------------------------------------------------------
	SUBROUTINE FPESO(NB1,NB2,P1,P2,P12,ARPR,ATOTR,ARPT,ARPF,PPOLIGR,PPOLIGT,PPOLIGF,STRPOLIGR,STRPOLIGT,STRPOLIGF)
	USE ESTRUCT
	USE GLOBAL
	RECORD/XYZ/P1,P2,P12	!COORDENADAS CARTESIANAS DEL CENTRO DE LAS 
							!FUNCIONES DE BASE Y DEL CENTRO
	RECORD/XY/PPOLIGR(1:INCREMENT+1),PPOLIGT(1:INCREMENT+1),PPOLIGF(1:INCREMENT+1)
	REAL*8 STRPOLIGR(INCREMENT),STRPOLIGT(INCREMENT),STRPOLIGF(INCREMENT)
	REAL*8 RG1,RG2
	CHARACTER*1 CI
	REAL*8 AREXPR,ATOTR,ARPR,ARPT,ARPF
	INTEGER*4 NB1,NB2

	IF (EXGEN==1) THEN  !SI SON GENÉRICAS LAS CENTRAMOS EN EL CENTRO
		SELECT CASE (NPOLIG)
			CASE (1)
				CALL POLI_R(NB1,NB2,ARPR,AREXPR,ATOTR,PPOLIGR,STRPOLIGR,P1,P2,P12)
			CASE (2)
				CALL POLI_R(NB1,NB2,ARPR,AREXPR,ATOTR,PPOLIGR,STRPOLIGR,P1,P2,P12)
				CALL POLI_ANG(NB1,NB2,ARPT,PPOLIGT,STRPOLIGT,'T',P1,P2,P12)
			CASE (3)
				CALL POLI_R(NB1,NB2,ARPR,AREXPR,ATOTR,PPOLIGR,STRPOLIGR,P1,P2,P12)
				CALL POLI_ANG(NB1,NB2,ARPT,PPOLIGT,STRPOLIGT,'T',P1,P2,P12)
				CALL POLI_ANG(NB1,NB2,ARPF,PPOLIGF,STRPOLIGF,'F',P1,P2,P12)
		END SELECT
	ELSE
	
		!SI SON EXPONENCIALES EL DEL PRODUCTO DE LAS GAUSSIANAS
		!QUE MEJOR AJUSTASEN LAS FUNCIONES REALMENTE USADAS
		!P12.X=(P1.X*(FB(NB1).ALFA**2+FB(NB1).BETA)+P2.X*(FB(NB2).ALFA**2+FB(NB2).BETA))/(FB(NB1).ALFA**2+FB(NB1).BETA+FB(NB2).ALFA**2+FB(NB2).BETA)
		!P12.Y=(P1.Y*(FB(NB1).ALFA**2+FB(NB1).BETA)+P2.Y*(FB(NB2).ALFA**2+FB(NB2).BETA))/(FB(NB1).ALFA**2+FB(NB1).BETA+FB(NB2).ALFA**2+FB(NB2).BETA)
		!P12.Z=(P1.Z*(FB(NB1).ALFA**2+FB(NB1).BETA)+P2.Z*(FB(NB2).ALFA**2+FB(NB2).BETA))/(FB(NB1).ALFA**2+FB(NB1).BETA+FB(NB2).ALFA**2+FB(NB2).BETA)

		!SELECCION DEL EXPONENTE DE LA FUNCION DE PESO (=EL QUE MENOR ERROR
		!SUMINISTRA PARA UNA INTEGRAL DE CALIBRADO).
		IF (UNASOLA==1)THEN
			IF(CLASINT=='S'.OR.CLASINT=='s')THEN
				CI=CLASINT	
			ELSE
				CI=STIPO
			ENDIF
		ELSE
			CI=CLASINT
		ENDIF
		IF(CI=='S')DENO= FB(NB1).N+FB(NB2).N+3.0D0
		IF(CI=='T')DENO= FB(NB1).N+FB(NB2).N+2.5D0
		IF(CI=='V')DENO= FB(NB1).N+FB(NB2).N+2.0D0
		IF(CI=='H')DENO= FB(NB1).N+FB(NB2).N+2.5D0
		IF(CI=='X')DENO= FB(NB1).N+FB(NB2).N+4.0D0
		IF(CI=='Y')DENO= FB(NB1).N+FB(NB2).N+4.0D0
		IF(CI=='Z')DENO= FB(NB1).N+FB(NB2).N+4.0D0
		RG1=DSQRT(FB(NB1).BETA)
		RG2=DSQRT(FB(NB2).BETA)
		EXP0= (FB(NB1).ALFA+FB(NB2).ALFA+RG1+RG2)/DENO
	END IF	

	END

!******************************************************************
! ----CENTRA LA FUNCION DE PESO
!******************************************************************
	SUBROUTINE CENTRA_PESO(NB1,NB2,C1,C2,C12)
	USE GLOBAL
	USE ESTRUCT
    RECORD/RCSTFI/POLAR
	RECORD/XYZ/C1,C2,C12,P,PMED
	RECORD/DAT_METODO/MET
	REAL*8 GR,GT,GF,Y0,RMAX,YFUNC,W,PUNTO,SP
	INTEGER*4 NB1,NB2,NP,JSEM

	IF (NMC<=1000)THEN	!NUMERO DE PUNTOS PARA HACER EL PREMUESTREO
		NP=100	
	ELSEIF (NMC>1000.AND.NMC<=10000)THEN
		NP=1000
	ELSEIF (NMC>10000)THEN
		NP=NMC/100
	ENDIF
	JSEM=1	!SEMILLA PARA ESTE CASO

	IF (C1.X==C2.X.AND.C1.Y==C2.Y.AND.C1.Z==C2.Z)THEN
		C12.X=C1.X
		C12.Y=C1.Y
		C12.Z=C1.Z
	ELSE
		PMED.X=(C1.X+C2.X)/2.D0
		PMED.Y=(C1.Y+C2.Y)/2.D0
		PMED.Z=(C1.Z+C2.Z)/2.D0

		RMAX=DSQRT((C1.X-C2.X)**2+(C1.Y-C2.Y)**2+(C1.Z-C2.Z)**2) !RADIO MÁXIMO DE MUESTREO
		W=3.D0/(4.D0*PI*RMAX**3)	!1/VOLUMEN DE LA ESFERA DE MUESTREO 
			
		SX=0.D0
		SY=0.D0
		SZ=0.D0
		SP=0.D0
		DO I=1,NP
			CALL RND(JSEM,GR)
			GR=GR*RMAX
			CALL RND(JSEM,GT)
			CALL RND(JSEM,GF)
			
			! ---  PASO A CARTESIANAS
			POLAR.R=GR
			POLAR.CST=1.D0-2.*GT
			POLAR.FI=2.D0*PI*GF
			CALL POLAR2CAR(POLAR,P)

			P.X=P.X+PMED.X
			P.Y=P.Y+PMED.Y
			P.Z=P.Z+PMED.Z

			PUNTO=YFUNC(NB1,NB2,POLAR,P,C1,C2,W)
			PUNTO=DABS(PUNTO)
			SP=SP+PUNTO
			IF (DABS(SP)>CERO)THEN
				SX=SX+(P.X-SX)*PUNTO/SP
				SY=SY+(P.Y-SY)*PUNTO/SP
				SZ=SZ+(P.Z-SZ)*PUNTO/SP
			ENDIF
		ENDDO
		C12.X=SX
		C12.Y=SY
		C12.Z=SZ
	ENDIF
	
	END
!******************************************************************
! ----CENTRA LA FUNCION DE PESO PARA INTEGRALES MIXTAS
!******************************************************************
	SUBROUTINE CENTRA_PESO_MIXT(NB1,NB2,C1,C2,C12)
	USE GLOBAL
	USE ESTRUCT
    RECORD/RCSTFI/POLAR
	RECORD/XYZ/C1,C2,C12,P,PMED
	RECORD/DAT_METODO/MET
	REAL*8 GR,GT,GF,Y0,RMAX,YFUNC,W,PUNTO,SP
	INTEGER*4 NB1,NB2,NP,JSEM

	IF (NMC<=1000)THEN	!NUMERO DE PUNTOS PARA HACER EL PREMUESTREO
		NP=100	
	ELSEIF (NMC>1000.AND.NMC<=10000)THEN
		NP=1000
	ELSEIF (NMC>10000)THEN
		NP=NMC/100
	ENDIF
	JSEM=1	!SEMILLA PARA ESTE CASO

	IF (C1.X==C2.X.AND.C1.Y==C2.Y.AND.C1.Z==C2.Z)THEN
		C12.X=C1.X
		C12.Y=C1.Y
		C12.Z=C1.Z
	ELSE
		PMED.X=(C1.X+C2.X)/2.D0
		PMED.Y=(C1.Y+C2.Y)/2.D0
		PMED.Z=(C1.Z+C2.Z)/2.D0

		RMAX=DSQRT((C1.X-C2.X)**2+(C1.Y-C2.Y)**2+(C1.Z-C2.Z)**2) !RADIO MÁXIMO DE MUESTREO
		W=3.D0/(4.D0*PI*RMAX**3)	!1/VOLUMEN DE LA ESFERA DE MUESTREO 
			
		SX=0.D0
		SY=0.D0
		SZ=0.D0
		SP=0.D0
		DO I=1,NP
			CALL RND(JSEM,GR)
			GR=GR*RMAX
			CALL RND(JSEM,GT)
			CALL RND(JSEM,GF)
			
			! ---  PASO A CARTESIANAS
			POLAR.R=GR
			POLAR.CST=1.D0-2.*GT
			POLAR.FI=2.D0*PI*GF
			CALL POLAR2CAR(POLAR,P)

			P.X=P.X+PMED.X
			P.Y=P.Y+PMED.Y
			P.Z=P.Z+PMED.Z
			IF(CLASINT=='J')THEN
				CLASINT='S'
				PUNTO=YFUNC_MIXT(NB1,NB2,POLAR,P,C1,C2,W)
				CLASINT='J'
			ELSE
				PUNTO=YFUNC_MIXT(NB1,NB2,POLAR,P,C1,C2,W)
			END IF
			PUNTO=DABS(PUNTO)
			SP=SP+PUNTO
			IF (DABS(SP)>CERO)THEN
				SX=SX+(P.X-SX)*PUNTO/SP
				SY=SY+(P.Y-SY)*PUNTO/SP
				SZ=SZ+(P.Z-SZ)*PUNTO/SP
			ENDIF
		ENDDO
		C12.X=SX
		C12.Y=SY
		C12.Z=SZ
	ENDIF
	
	END

!******************************************************************
! ----SUBPROGRAMA QUE DADO EL VALOR GENERADO ALEATORIAMENTE CALCULA
!     A QUE PARTE DE LA POLIGONAL CORRESPONDE, ES DECIR, DADA LA F(R)
!     (ALEATORIO) NOS DEVUELVE EL VALOR DE R EN LA POLIGONAL.
!     ADEMAS DE EL AREA DE LA POLIGONAL Y EL AREA TOTAL DE LA FUNCION
!     DE PESO (O FUNCION DENSIDAD)
!******************************************************************
    SUBROUTINE INV_FDEN_R(IMAL,ARP,AREATOT,ALEA,FDEN,MET,P,STR,CMON,IISEM)
	USE GLOBAL
	USE ESTRUCT
    RECORD/DAT_METODO/MET
	RECORD/XY/P(1:INCREMENT+1)
	REAL*8 STR(INCREMENT)
	INTEGER*4 N1,N2,IMAL,IELEG,I1
	REAL*8 ARP,AREATOT,ALEA,FDEN,RN
	REAL*8 REXP
	CHARACTER*3 CMON


	CALL GENERA_MONTECARLO(MET,CMON,IISEM,IMAL,ALEA,RN)
	IF(RN<(ARP/AREATOT))THEN ! ----- muestrea con la poligonal
		CALL BUSCA_TRAPECIO(AREATOT,RN,P,STR,ALEA,FDEN)
	ELSE  ! ----	muestrear con f.d. k exp(-c*r) en el intervalo-[a,inf.)
		REXP=(A0*(ARP-AREATOT*RN))/CEXP+DEXP(-A0*P(INCREMENT+1).X)
		IF (REXP>=0.D0) THEN 
			ALEA=-DLOG(REXP)/A0
			FDEN=CEXP*DEXP(-A0*ALEA)
		ELSE
			!IMAL=IMAL+1
			ALEA=VALINF
			FDEN=CERO
		ENDIF
	ENDIF

	RETURN
    END

! --------------------------------------------------------------------
!   SUBPROGRAMA QUE DADO EL VALOR GENERADO ALEATORIAMENTE CALCULA
!   A QUE PARTE DE LA POLIGONAL CORRESPONDE, ES DECIR, DADA LA F(ANG)
!   (ALEATORIO) NOS DEVUELVE EL VALOR DEL ANGULO EN LA POLIGONAL.
!   ADEMAS DE EL AREA DE LA POLIGONAL Y EL AREA TOTAL DE LA FUNCION
!   DE PESO (O FUNCION DENSIDAD)
! --------------------------------------------------------------------
    SUBROUTINE INV_FDEN_ANG(IMAL,ARP,ALEA,FDEN,MET,P,STR,CMON,IISEM)
	USE GLOBAL,ONLY:INCREMENT
	USE ESTRUCT,ONLY:DAT_METODO,XY
    RECORD/DAT_METODO/MET
	RECORD/XY/P(1:INCREMENT+1)
	REAL*8 STR(INCREMENT)
	INTEGER*4 IMAL,IISEM
	REAL*8 ARP,ALEA,FDEN,RN
	
	CHARACTER*3 CMON
	

	CALL GENERA_MONTECARLO(MET,CMON,IISEM,IMAL,ALEA,RN)

	CALL BUSCA_TRAPECIO(ARP,RN,P,STR,ALEA,FDEN)
	
    RETURN
    END


!******************************************************************
!  SUBPROGRAMA PARA CALCULAR LOS VERTICES DE LA POLIGONAL PARA R
!  AREA DE CADA TRAPECIO (STR) Y AREA TOTAL DE LA POLIGONAL(ARP)
!******************************************************************
    SUBROUTINE POLI_R(N1,N2,ARP,ARE,ATOT,P,STR,C1,C2,PC)
	USE GLOBAL
	USE ESTRUCT
	INTEGER*4 N1,N2,I
	REAL*8 ARP,ARE,ATOT
	REAL*8 RULT,YR0
	INTEGER*4 IULT
	RECORD/XY/P(1:INCREMENT+1)
	REAL*8 STR(INCREMENT)
	REAL*8 CALCFUNC,PY,PX
	RECORD/RCSTFI/POLIPOLAR,POLIPOLAR1,POLIPOLAR2
	RECORD/XYZ/C1,C2,PC,POLICAR,POLICAR1,POLICAR2
	INTEGER*4 CONT
	REAL*8 ANGULOT,ANGULOF

	!INI=0.D0
	!FIN=10.D0
	CONT=0

	DO I=1,INCREMENT+1
		P(I).X=INIR+DBLE(I-1)*(FINR-INIR)/DBLE(INCREMENT)
		P(I).Y=0.D0
		IF (P(I).X<=R0)THEN 
			RULT=P(I).X
			IULT=I
		ENDIF
				
		POLIPOLAR.R=P(I).X  !coordenas para la poligonal
		DO J=1,20
			ANGULOT=-1.D0+DFLOAT(J)/10.D0
			POLIPOLAR.CST=ANGULOT
			
			DO K=0,23
				ANGULOF=K*PI/4.D0
				POLIPOLAR.FI=ANGULOF
				
				! ---  PASO A CARTESIANAS
				CALL POLAR2CAR(POLIPOLAR,POLICAR)
								
				!--CALCULO EN CARTESIANAS DE LOS PUNTOS DE LA POLIGONAL RESPECTO A CADA CENTRO
				POLICAR1.X=POLICAR.X+(PC.X-C1.X)
				POLICAR1.Y=POLICAR.Y+(PC.Y-C1.Y)
				POLICAR1.Z=POLICAR.Z+(PC.Z-C1.Z)
				POLICAR2.X=POLICAR.X+(PC.X-C2.X)
				POLICAR2.Y=POLICAR.Y+(PC.Y-C2.Y)
				POLICAR2.Z=POLICAR.Z+(PC.Z-C2.Z)							
				
				!PASO A POLARES 
				CALL CAR2POLAR(POLICAR1,POLIPOLAR1)
				CALL CAR2POLAR(POLICAR2,POLIPOLAR2)

				IF(CLASINT/='J')THEN
					IF (POLIPOLAR2.R/=0.D0)THEN
						IF(CLASINT=='S')V2=CALCFUNC(POLIPOLAR2.R,CFUNC(N2))
						IF(CLASINT=='T')V2=TRBASE(N2,POLIPOLAR2.R)
						IF(CLASINT=='V')V2=VRBASE(N2,POLIPOLAR2,C2)
						IF(CLASINT=='H')V2=HRBASE(N2,POLIPOLAR2,C2)
						IF(CLASINT=='X')V2=XRBASE(N2,POLIPOLAR2,PC)	
					ELSE
						V2=0.D0
					END IF
					P(I).Y=P(I).Y+DABS(CALCFUNC(POLIPOLAR1.R,CFUNC(N1))*V2*(P(I).X)**2.D0)
				ELSE
					P(I).Y=P(I).Y+DABS(CALCFUNC(POLIPOLAR1.R,CFUNC(N1))*CALCFUNC(POLIPOLAR2.R,CFUNC(N2))*(P(I).X)**2.D0)
				END IF
			ENDDO
		ENDDO
	END DO

! --CALCULO DEL EXPONENTE DE LA FUNCIÓN DE PESO(parte exponencial): A0
	IF(RECORT==0)THEN

10		PX=2.D0*FINR
		
		IF(CLASINT/='J')THEN
			PY=CALCFUNC(PX,CFUNC(N1))
					
			POLIPOLAR2.R=PX	!COORDENADAS RESPECTO AL CENTRO 2
			POLIPOLAR2.CST=CERO
			POLIPOLAR2.FI=CERO

			IF (POLIPOLAR2.R/=0.D0)THEN
				IF(CLASINT=='S')V2=CALCFUNC(PX,CFUNC(N2))
				IF(CLASINT=='T')V2=TRBASE(N2,POLIPOLAR2.R)
				IF(CLASINT=='V')V2=VRBASE(N2,POLIPOLAR2,C2)
				IF(CLASINT=='H')V2=HRBASE(N2,POLIPOLAR2,C2)
				IF(CLASINT=='X')V2=XRBASE(N2,POLIPOLAR2,PC)	
			ELSE
				V2=0.D0
			END IF
			PY=DABS(PY*V2*(PX)**2.D0)
		ELSE
			PY=CALCFUNC(PX,CFUNC(N1))*CALCFUNC(PX,CFUNC(N2))
 			PY=DABS(PY*(PX)**2.D0)
		END IF
		
		IF (P(INCREMENT+1).Y>PY) THEN
			IF (P(INCREMENT+1).Y>CERO) THEN
				A0=DLOG(P(INCREMENT+1).Y/PY)/FINR
			ELSE
				A0=0.D0
			ENDIF
		ELSE
			CONT=CONT+1
			IF (CONT<=100) THEN
				GOTO 10
			ELSE 
				!WRITE(*,*)'LA FUNCION ES SIEMPRE CRECIENTE Y SE HA TOMADO COMO EXPONENTE DE LA EXPONENCIAL A0=0.5'
				A0=0.5D0
			ENDIF
		ENDIF
	ENDIF
! ------calculo del area de cada trapecio -----------------------------
    DO I=1,INCREMENT
		STR(I)=(P(I).Y+P(I+1).Y)*(P(I+1).X-P(I).X)/2.D0
    END DO

! ---calculo del area de todos los trapecios --------------------------
    ARP=0.D0
    
	DO I=1,INCREMENT
		ARP=ARP+STR(I)
	END	DO
	IF(RECORT==1.OR.RECORT==2)THEN	
		A0=0.D0
		ARE=0.D0
	ELSE IF(RECORT==0)THEN
		IF (A0/=0.D0)THEN	!   CALCULA EL AREA DE LA EXPONENCIAL
			ARE=P(INCREMENT+1).Y/A0
			CEXP=P(INCREMENT+1).Y*DEXP(A0*P(INCREMENT+1).X)
			!IF(P(INCREMENT+1).Y<CERO)THEN
			!	ARE=1.D0
			!	C=A0
			!ENDIF
		ELSE
			ARE=0.D0
		ENDIF
	ENDIF

!   CALCULA EL AREA TOTAL
	ATOT=ARP+ARE	
    
	END

!******************************************************************
!  SUBPROGRAMA PARA CALCULAR LOS VERTICES DE LA POLIGONAL PARA ANGULOS
!  AREA DE CADA TRAPECIO (STR) Y AREA TOTAL DE LA POLIGONAL(ARP)
!******************************************************************
    SUBROUTINE POLI_ANG(N1,N2,ARP,P,STR,CLASE,C1,C2,PC)
	USE GLOBAL
	USE ESTRUCT
	INTEGER*4 N1,N2,I
	REAL*8 ARP
	RECORD/XY/P(1:INCREMENT+1)
	REAL*8 STR(INCREMENT)
	REAL*8 CALCFUNC,FACTANG_CST,FACTANG_FI
	RECORD/RCSTFI/POLIPOLAR,POLIPOLAR1,POLIPOLAR2
	RECORD/XYZ/C1,C2,PC,POLICAR,POLICAR1,POLICAR2
	REAL*8 ANGULOT,ANGULOF
	CHARACTER*1 CLASE !'T'=COSENO DE THETA, 'F'= ANGULO FI
	
	IF (CLASE=='T')THEN
		INIA=-1.D0
		FINA=1.D0
	ELSEIF (CLASE=='F')THEN
		INIA=0.D0
		FINA=2*PI
	END IF
	!INIA=0.D0
	!FINA=1.D0

	DO I=1,INCREMENT+1
		P(I).X=INIA+DBLE(I-1)*(FINA-INIA)/DBLE(INCREMENT)
		P(I).Y=0.D0
				
		IF (CLASE=='T')THEN
			POLIPOLAR.CST=P(I).X  !coordenas para la poligonal
			DO J=1,20
				RADIO=DFLOAT(J)/5.D0
				POLIPOLAR.R=RADIO
			
				DO K=0,23
					ANGULOF=K*PI/4.D0
					POLIPOLAR.FI=ANGULOF
					
					! ---  PASO A CARTESIANAS
					CALL POLAR2CAR(POLIPOLAR,POLICAR)
								
					!--CALCULO EN CARTESIANAS DE LOS PUNTOS DE LA POLIGONAL RESPECTO A CADA CENTRO
					POLICAR1.X=POLICAR.X+(PC.X-C1.X)
					POLICAR1.Y=POLICAR.Y+(PC.Y-C1.Y)
					POLICAR1.Z=POLICAR.Z+(PC.Z-C1.Z)
					POLICAR2.X=POLICAR.X+(PC.X-C2.X)
					POLICAR2.Y=POLICAR.Y+(PC.Y-C2.Y)
					POLICAR2.Z=POLICAR.Z+(PC.Z-C2.Z)							
				
					!PASO A POLARES 
					CALL CAR2POLAR(POLICAR1,POLIPOLAR1)
					CALL CAR2POLAR(POLICAR2,POLIPOLAR2)

					P(I).Y=DABS(FACTANG_CST(FB(N1).NTF,POLIPOLAR1.CST)*FACTANG_CST(FB(N2).NTF,POLIPOLAR2.CST))
		
				ENDDO
			ENDDO
		ELSEIF (CLASE=='F')THEN
			POLIPOLAR.FI=P(I).X  !coordenas para la poligonal
			DO J=1,20
				RADIO=DFLOAT(J)/5.D0
				POLIPOLAR.R=RADIO
			
				DO K=1,20
					ANGULOT=-1.D0+DFLOAT(K)/10.D0
					POLIPOLAR.CST=ANGULOT
					
					! ---  PASO A CARTESIANAS
					CALL POLAR2CAR(POLIPOLAR,POLICAR)
								
					!--CALCULO EN CARTESIANAS DE LOS PUNTOS DE LA POLIGONAL RESPECTO A CADA CENTRO
					POLICAR1.X=POLICAR.X+(PC.X-C1.X)
					POLICAR1.Y=POLICAR.Y+(PC.Y-C1.Y)
					POLICAR1.Z=POLICAR.Z+(PC.Z-C1.Z)
					POLICAR2.X=POLICAR.X+(PC.X-C2.X)
					POLICAR2.Y=POLICAR.Y+(PC.Y-C2.Y)
					POLICAR2.Z=POLICAR.Z+(PC.Z-C2.Z)							
				
					!PASO A POLARES 
					CALL CAR2POLAR(POLICAR1,POLIPOLAR1)
					CALL CAR2POLAR(POLICAR2,POLIPOLAR2)
	
					P(I).Y=DABS(FACTANG_FI(FB(N1).NTF,POLIPOLAR1.FI)*FACTANG_FI(FB(N2).NTF,POLIPOLAR2.FI))
				ENDDO
			ENDDO
		END IF	
	END DO
! ------calculo del area de cada trapecio -----------------------------
    DO I=1,INCREMENT
		STR(I)=(P(I).Y+P(I+1).Y)*(P(I+1).X-P(I).X)/2.D0
    END DO

! ---calculo del area de todos los trapecios --------------------------
    ARP=0.D0
    DO I=1,INCREMENT
		ARP=ARP+STR(I)
    END DO

    END


!--------------------------------------------------------------------
!	SUBRUTINA QUE DADO EL VALOR DE LA FUNCION GENERADO ALEATORIAMENTE
!	NOS DICE EN QUE TRAPECIO DENTRO DE LA POLIGONAL SE ENCUENTRA
!--------------------------------------------------------------------
	SUBROUTINE BUSCA_TRAPECIO(AREATOT,RN,P,STR,ALEA,FDEN)
	USE GLOBAL,ONLY:INCREMENT
	USE ESTRUCT,ONLY:XY
    RECORD/XY/P(1:INCREMENT+1)
	REAL*8 STR(INCREMENT)
	INTEGER*4 IELEG,I1
	REAL*8 AREATOT,ALEA,FDEN,RN,BUTRA
	REAL*8 PEN,TERIND,AA,BB,CC,RAIZ

    IELEG=0

	BUTRA=RN*AREATOT
	I1=1
10	BUTRA=BUTRA-STR(I1)
	IF(BUTRA<0)THEN
		IELEG=I1
		BUTRA=DABS(BUTRA)
	ELSE
	    I1=I1+1
	    GOTO 10
	END IF
	PEN=(P(IELEG+1).Y-P(IELEG).Y)/(P(IELEG+1).X-P(IELEG).X)
	IF(PEN/=0.D0)THEN
		TERIND=P(IELEG).Y-PEN*P(IELEG).X
		AA=PEN
		BB=2*TERIND
		CC=2*BUTRA-TERIND*P(IELEG+1).X-P(IELEG+1).Y*P(IELEG+1).X
		RAIZ=DSQRT(BB**2.D0-4.D0*AA*CC)
		ALEA=(-BB-RAIZ)/(2.D0*AA)
		
		IF(ALEA<P(IELEG).X.OR.ALEA>P(IELEG+1).X)THEN
			ALEA=(-BB+RAIZ)/(2.D0*AA)
		ENDIF
	ELSE
		TERIND=P(IELEG).Y
		!ALEA=(2.D0*BUTRA-P(IELEG+1).X*(TERIND+P(IELEG+1).Y))/2.D0*TERIND
		ALEA=P(IELEG+1).X-(BUTRA/TERIND)
	ENDIF
	FDEN=(PEN*ALEA+TERIND)

	END

!--------------------------------------------------------------------
!	SUBROUTINE QUE DEVUELVE EL NUMERO GENERADO ALEATORIAMENTE CON EL 
!	TIPO DE MONTECARLO ELEGIDO
!--------------------------------------------------------------------
	SUBROUTINE GENERA_MONTECARLO(MET,CMON,IISEM,IMAL,ALEA,RN)
	USE GLOBAL,ONLY:CERO
	USE ESTRUCT,ONLY:DAT_METODO
    RECORD/DAT_METODO/MET
	INTEGER*4 IMAL,IISEM
	REAL*8 RN,ALEA
	CHARACTER*3 CMON


    IF(CMON=='HAS'.OR.CMON=='GAS'.OR.CMON=='AAS')THEN
10		CALL HAS(MET.RAIZ,MET.DNUMERO,RN)
		IF(RN<=CERO)THEN
			IMAL=IMAL+1
			GOTO 10
		END IF
    END IF
    IF(CMON=='HAL'.OR.CMON=='GAL'.OR.CMON=='AAL')THEN
20		CALL HALTON(MET.NUM,MET.NR1,MET.NR2,RN)
		IF(RN<=CERO)THEN
			IMAL=IMAL+1
			GOTO 20
		END IF
    END IF
	IF(CMON=='HAM'.OR.CMON=='GAM'.OR.CMON=='AAM')THEN
		RN=ALEA		
    END IF
	IF(CMON=='RND'.OR.CMON=='GND'.OR.CMON=='AND')THEN
30		CALL RND(IISEM,RN)
		IF(RN<=CERO)THEN
			IMAL=IMAL+1
			GOTO 30
		END IF
    END IF
	END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL OPERADOR  T
! ---   APLICADO A UNA FUNCION DE BASE EN UN PUNTO "RR".
! -------------------------------------------------------------
    DOUBLE PRECISION FUNCTION TRBASE(NB,RR)
	USE GLOBAL
	USE ESTRUCT
	IMPLICIT REAL*8(A-H,O-Z)
	INTEGER*4 NB
	
    L=0
    IF(FB(NB).NTF>=1)L=1
    IF(FB(NB).NTF>=4)L=2
    IF(FB(NB).NTF>=9)L=3
    	
	R1=RR+DELTA
	R2=RR-DELTA
	PRIMERAD=DERIVAR(NB,RR)
	SEGUNDAD=(DERIVAR(NB,R1)-DERIVAR(NB,R2))/(2.D0*DELTA)
	
    !CALL RICHARDR(NB,RR,DELTA,1,1,PRIMERAD)
	!CALL RICHARDR(NB,RR,DELTA,1,2,SEGUNDAD)
	TRBASE=SEGUNDAD+PRIMERAD*2.D0/RR
    TRBASE=TRBASE-DFLOAT(L*(L+1))*CALCFUNC(RR,CFUNC(NB))/RR**2
    TRBASE=-0.5D0*TRBASE

	RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DE LA DERIVADA RESPECTO A R
! ---   DE UNA FUNCION DE BASE EN UN PUNTO "RR".
! -------------------------------------------------------------
    DOUBLE PRECISION FUNCTION DERIVAR(NB,RR)
	USE GLOBAL
	USE ESTRUCT
	IMPLICIT REAL*8(A-H,O-Z)
	INTEGER*4 NB
	
    R1=RR+DELTA
	R2=RR-DELTA
	
	F1=CALCFUNC(R1,CFUNC(NB))
	F2=CALCFUNC(R2,CFUNC(NB))
    DERIVAR=(F1-F2)/(2.D0*DELTA)

    RETURN
    END

! ----------------------------------------------------------------------
!     CALCULA LA DERIVADA DE UNA FUNCION F(X)
!     POR APROXIMACION PARABOLICA Y EXTRAPOLACION DE RICHARDSON 
! --------------------------------------------------------------------- 
    RECURSIVE SUBROUTINE RICHARDR(NB,RR,H,NPASOS,ORDEN,RES)
	USE ESTRUCT
    REAL*8 H,H2,HH,DERIVA,A,R1,R2,RES,DR1,DR2,RR,RR1,RR2
    INTEGER*4 NPASOS,I,NB,ORDEN,AUX

	IF (ORDEN==1) THEN
		A=1.D0
		IF(NPASOS==0)THEN
			RES=DERIVAR(NB,RR)
			RETURN
		ENDIF

		DO I=1,NPASOS		
			A=4.D0*A
			AUX=I-1
			CALL RICHARDR(NB,RR,H,AUX,ORDEN,R1)
			H2=0.5D0*H
			CALL RICHARDR(NB,RR,H2,AUX,ORDEN,R2)
			RES=(A*R2-R1)/(A-1.D0)  
		ENDDO
	ELSEIF (ORDEN==2) THEN
		HH=H*10.D0
		RR1=RR+HH
		AUX=ORDEN-1
		CALL RICHARDR(NB,RR1,H,NPASOS,AUX,R1)
		RR2=RR-HH
		CALL RICHARDR(NB,RR2,H,NPASOS,AUX,R2)
		DR1=(R1-R2)/(2.D0*HH)
		RR1=RR+HH/2.D0
		CALL RICHARDR(NB,RR1,H,NPASOS,AUX,R1)
		RR2=RR-HH/2.D0
		CALL RICHARDR(NB,RR2,H,NPASOS,AUX,R2)
		DR2=(R1-R2)/HH
		RES=(4.D0*DR2-DR1)/3.D0
	ENDIF
	   
	RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL OPERADOR  H
! ---   APLICADO A UNA FUNCION DE BASE EN UN PUNTO "R,TETA,FI".
! ---   (CST ES EL COSENO DE TETA)
! -------------------------------------------------------------
    DOUBLE PRECISION FUNCTION HRBASE(NB,POL,CENT)
	USE ESTRUCT
	!USE GLOBAL
    RECORD/RCSTFI/POL
	RECORD/XYZ/CENT
	INTEGER*4 NB

    HRBASE=TRBASE(NB,POL.R)+VRBASE(NB,POL,CENT)

    RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL PRODUCTO
! ---   "V" POR UNA FUNCION DE BASE.
! ---   (CST ES EL COSENO DE TETA)
! ---    EL PUNTO (R,CST,FI) ENTRA YA DEFINIDO RESPECTO AL
! ---    ORIGEN DE LA FUNCION DE BASE IMPLICADA,  PERO LAS
! ---    COORDENADAS NUCLEARES (entran respecto al origen)
! ---    SON TRASLADADAS POR EL SUBPROGRAMA.
! -------------------------------------------------------------
	DOUBLE PRECISION FUNCTION VRBASE(NB,POL,CENT)
	USE ESTRUCT
	USE GLOBAL
	IMPLICIT REAL*8(A-H,O-Z)
    RECORD/RCSTFI/POL
	RECORD/XYZ/P,CENT,PP0
	INTEGER*4 NB
	  
	!CALL POLAR2CAR(POL,P)
	
    VRBASE=0.D0
! --- CALCULO DE LAS COORDENADAS DE CADA NUCLEO RESPECTO AL 
! --- CENTRO DE LA SEGUNDA FUNCION DE BASE:
	IF(NUC==0)RETURN
    DO K=1,NUC
	!	PP0.X=NUCLEOS(K).X-CENT.X
	!	PP0.Y=NUCLEOS(K).Y-CENT.Y	!CENT ES EL CENTRO DE LA 2º FUNCION DE BASE
	!	PP0.Z=NUCLEOS(K).Z-CENT.Z	
	!	X0=P.X-PP0.X
	!	Y0=P.Y-PP0.Y
	!	Z0=P.Z-PP0.Z 
	!	R0=DSQRT(X0*X0+Y0*Y0+Z0*Z0)   
	!	IF(R0<CERO)R0=CERO
	!	VRBASE=VRBASE-NUCLEOS(K).CARGA/R0
		VRBASE=VRBASE-NUCLEOS(K).CARGA/POL.R
	END DO

    VRBASE=VRBASE*CALCFUNC(POL.R,CFUNC(NB))

    RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL PRODUCTO
! ---   "X**Nx * Y**Ny * Z**Nz" POR UNA FUNCION DE BASE.
! ---   (CST ES EL COSENO DE TETA)
! ---    EL PUNTO (R,CST,FI) ENTRA YA DEFINIDO RESPECTO AL
! ---    ORIGEN DE LA FUNCION DE BASE IMPLICADA,  PERO LAS
! ---    COORDENADAS NUCLEARES TIENEN QUE SER TRASLADADAS.
! -------------------------------------------------------------
    DOUBLE PRECISION FUNCTION XRBASE(NB,POL,P)
    USE ESTRUCT
	USE GLOBAL
	IMPLICIT REAL*8(A-H,O-Z)
	RECORD/XYZ/P
    RECORD/RCSTFI/POL   
	INTEGER*4 NB
	    
	!CALL POLAR2CAR(POL,P)

	!RR=(P.X-P0.X)**2+(P.Y-P0.Y)**2+(P.Z-P0.Z)**2
	!XRBASE=RR**(NN.NX+NN.NY+NN.NZ)
	XRBASE=(P.X-P0.X)**NN.NX*(P.Y-P0.Y)**NN.NY*(P.Z-P0.Z)**NN.NZ
    XRBASE=XRBASE*CALCFUNC(POL.R,CFUNC(NB))

    RETURN
    END