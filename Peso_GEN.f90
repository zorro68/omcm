!---------------------------------------------------------------------
!  SUBROUTINE QUE CALCULA LA FUNCION DE PESO PARA LAS GENERALIZADAS
!---------------------------------------------------------------------
	SUBROUTINE FPESO_GEN(NB1,NB2,P1,P2,P12,ARPR,ATOTR,ARPT,ARPF,PPOLIGR,PPOLIGT,PPOLIGF,STRPOLIGR,STRPOLIGT,STRPOLIGF)
	USE ESTRUCT
	USE GLOBAL
    IMPLICIT NONE
	TYPE (XYZ) :: P1,P2,P12	!COORDENADAS CARTESIANAS DEL CENTRO DE LAS 
							!FUNCIONES DE BASE Y DEL CENTRO
	TYPE(XY) :: PPOLIGR(1:INCREMENT+1),PPOLIGT(1:INCREMENT+1),PPOLIGF(1:INCREMENT+1)
	REAL*16 :: STRPOLIGR(INCREMENT),STRPOLIGT(INCREMENT),STRPOLIGF(INCREMENT)
	REAL*16 :: ARPR,ARPT,ARPF,AREXPR,ATOTR
    INTEGER*4 :: NB1,NB2
    
	SELECT CASE (NPOLIG) !SI SON GENÉRICAS LAS CENTRAMOS EN EL CENTRO
		CASE (1)
			CALL POLI_R(NB1,NB2,ARPR,AREXPR,ATOTR,PPOLIGR,STRPOLIGR,P1,P2,P12)
		CASE (2)
			CALL POLI_R(NB1,NB2,ARPR,AREXPR,ATOTR,PPOLIGR,STRPOLIGR,P1,P2,P12)
			CALL POLI_ANG(NB1,NB2,ARPT,PPOLIGT,STRPOLIGT,'T',P1,P2,P12)
		CASE (3)
			CALL POLI_R(NB1,NB2,ARPR,AREXPR,ATOTR,PPOLIGR,STRPOLIGR,P1,P2,P12)
			CALL POLI_ANG(NB1,NB2,ARPT,PPOLIGT,STRPOLIGT,'T',P1,P2,P12)
			CALL POLI_ANG(NB1,NB2,ARPF,PPOLIGF,STRPOLIGF,'F',P1,P2,P12)
	END SELECT
	
	END

    
!******************************************************************
! ----SUBPROGRAMA QUE DADO EL VALOR GENERADO ALEATORIAMENTE CALCULA
!     A QUE PARTE DE LA POLIGONAL CORRESPONDE, ES DECIR, DADA LA F(R)
!     (ALEATORIO) NOS DEVUELVE EL VALOR DE R EN LA POLIGONAL.
!     ADEMAS DE EL AREA DE LA POLIGONAL Y EL AREA TOTAL DE LA FUNCION
!     DE PESO (O FUNCION DENSIDAD)
!******************************************************************
    SUBROUTINE INV_FDEN_R(IMAL,ARP,AREATOT,ALEA,FDEN,MET,P,STR,CMON,IISEM)
	USE GLOBAL
	USE ESTRUCT
    IMPLICIT NONE
    TYPE(DAT_METODO)::MET
	TYPE(XY)::P(1:INCREMENT+1)
	REAL*16 ::STR(INCREMENT)
	INTEGER*4 :: N1,N2,IMAL,IELEG,I1,IISEM
	REAL*16 :: ARP,AREATOT,ALEA,FDEN,RN
	REAL*16 :: REXP
	CHARACTER*3 CMON


	CALL GENERA_MONTECARLO(MET,CMON,IISEM,IMAL,ALEA,RN)
	IF(RN<(ARP/AREATOT))THEN ! ----- muestrea con la poligonal
		CALL BUSCA_TRAPECIO(AREATOT,RN,P,STR,ALEA,FDEN)
	ELSE  ! ----	muestrear con f.d. k exp(-c*r) en el intervalo-[a,inf.)
		REXP=(A0*(ARP-AREATOT*RN))/CEXP+QEXP(-A0*P(INCREMENT+1).X)
		IF (REXP>=0.Q0) THEN 
			ALEA=-QLOG(REXP)/A0
			FDEN=CEXP*QEXP(-A0*ALEA)
		ELSE
			!IMAL=IMAL+1
			ALEA=VALINF
			FDEN=CERO
		ENDIF
	ENDIF

	RETURN
    END

! --------------------------------------------------------------------
!   SUBPROGRAMA QUE DADO EL VALOR GENERADO ALEATORIAMENTE CALCULA
!   A QUE PARTE DE LA POLIGONAL CORRESPONDE, ES DECIR, DADA LA F(ANG)
!   (ALEATORIO) NOS DEVUELVE EL VALOR DEL ANGULO EN LA POLIGONAL.
!   ADEMAS DE EL AREA DE LA POLIGONAL Y EL AREA TOTAL DE LA FUNCION
!   DE PESO (O FUNCION DENSIDAD)
! --------------------------------------------------------------------
    SUBROUTINE INV_FDEN_ANG(IMAL,ARP,ALEA,FDEN,MET,P,STR,CMON,IISEM)
	USE GLOBAL,ONLY:INCREMENT
	USE ESTRUCT,ONLY:DAT_METODO,XY
    IMPLICIT NONE
    TYPE(DAT_METODO)::MET
	TYPE(XY)::P(1:INCREMENT+1)
	REAL*16 STR(INCREMENT)
	INTEGER*4 IMAL,IISEM
	REAL*16 ARP,ALEA,FDEN,RN
	CHARACTER*3 CMON
	

	CALL GENERA_MONTECARLO(MET,CMON,IISEM,IMAL,ALEA,RN)

	CALL BUSCA_TRAPECIO(ARP,RN,P,STR,ALEA,FDEN)
	
    RETURN
    END


!******************************************************************
!  SUBPROGRAMA PARA CALCULAR LOS VERTICES DE LA POLIGONAL PARA R
!  AREA DE CADA TRAPECIO (STR) Y AREA TOTAL DE LA POLIGONAL(ARP)
!******************************************************************
    SUBROUTINE POLI_R(N1,N2,ARP,ARE,ATOT,P,STR,C1,C2,PC)
	USE GLOBAL
	USE ESTRUCT
	IMPLICIT NONE
    INTEGER*4 N1,N2,I,J,K
	REAL*16 ARP,ARE,ATOT
	REAL*16 RULT,YR0
	INTEGER*4 IULT
	TYPE(XY)::P(1:INCREMENT+1)
	REAL*16 STR(INCREMENT)
	REAL*16 CALCFUNC,TRBASE,VRBASE,HRBASE,XRBASE,PY,PX
	TYPE(RCSTFI)::POLIPOLAR,POLIPOLAR1,POLIPOLAR2
	TYPE(XYZ)::C1,C2,PC,POLICAR,POLICAR1,POLICAR2
	INTEGER*4 CONT
	REAL*16 ANGULOT,ANGULOF,VV

	!INI=0.Q0
	!FIN=10.Q0
	CONT=0

	DO I=1,INCREMENT+1
		P(I).X=INIR+DBLE(I-1)*(FINR-INIR)/DBLE(INCREMENT)
		P(I).Y=0.Q0
		IF (P(I).X<=R0)THEN 
			RULT=P(I).X
			IULT=I
		ENDIF
				
		POLIPOLAR.R=P(I).X  !coordenas para la poligonal
		DO J=1,20
			ANGULOT=-1.Q0+DFLOAT(J)/10.Q0
			POLIPOLAR.CST=ANGULOT
			
			DO K=0,23
				ANGULOF=K*PI/4.Q0
				POLIPOLAR.FI=ANGULOF
				
				! ---  PASO A CARTESIANAS
				CALL POLAR2CAR(POLIPOLAR,POLICAR)
								
				!--CALCULO EN CARTESIANAS DE LOS PUNTOS DE LA POLIGONAL RESPECTO A CADA CENTRO
				POLICAR1.X=POLICAR.X+(PC.X-C1.X)
				POLICAR1.Y=POLICAR.Y+(PC.Y-C1.Y)
				POLICAR1.Z=POLICAR.Z+(PC.Z-C1.Z)
				POLICAR2.X=POLICAR.X+(PC.X-C2.X)
				POLICAR2.Y=POLICAR.Y+(PC.Y-C2.Y)
				POLICAR2.Z=POLICAR.Z+(PC.Z-C2.Z)							
				
				!PASO A POLARES 
				CALL CAR2POLAR(POLICAR1,POLIPOLAR1)
				CALL CAR2POLAR(POLICAR2,POLIPOLAR2)

				IF(CLASINT/='J')THEN
					IF (POLIPOLAR2.R/=0.Q0)THEN
						IF(CLASINT=='S')VV=CALCFUNC(POLIPOLAR2.R,CFUNC(N2))
						IF(CLASINT=='T')VV=TRBASE(N2,POLIPOLAR2)
						IF(CLASINT=='V')VV=VRBASE(N2,POLIPOLAR2,C2)
						IF(CLASINT=='H')VV=HRBASE(N2,POLIPOLAR2,C2)
						IF(CLASINT=='X')VV=XRBASE(N2,POLIPOLAR2,PC)	
						!IF(ISNAN(VV))VV=0.Q0 !PARA EVITAR QUE SE CUELGUE
					ELSE
						VV=0.Q0
					END IF
					P(I).Y=P(I).Y+QABS(CALCFUNC(POLIPOLAR1.R,CFUNC(N1))*VV*(P(I).X)**2.Q0)
				ELSE
					P(I).Y=P(I).Y+QABS(CALCFUNC(POLIPOLAR1.R,CFUNC(N1))*CALCFUNC(POLIPOLAR2.R,CFUNC(N2))*(P(I).X)**2.Q0)
				END IF
			ENDDO
		ENDDO
	END DO

! --CALCULO DEL EXPONENTE DE LA FUNCIÓN DE PESO(parte exponencial): A0
	IF(RECORT==0)THEN

10		PX=2.Q0*FINR
		
		IF(CLASINT/='J')THEN
			PY=CALCFUNC(PX,CFUNC(N1))
					
			POLIPOLAR2.R=PX	!COORDENADAS RESPECTO AL CENTRO 2
			POLIPOLAR2.CST=CERO
			POLIPOLAR2.FI=CERO

			IF (POLIPOLAR2.R/=0.Q0)THEN
				IF(CLASINT=='S')VV=CALCFUNC(PX,CFUNC(N2))
				IF(CLASINT=='T')VV=TRBASE(N2,POLIPOLAR2)
				IF(CLASINT=='V')VV=VRBASE(N2,POLIPOLAR2,C2)
				IF(CLASINT=='H')VV=HRBASE(N2,POLIPOLAR2,C2)
				IF(CLASINT=='X')VV=XRBASE(N2,POLIPOLAR2,PC)	
			ELSE
				VV=0.Q0
			END IF
			PY=QABS(PY*VV*(PX)**2.Q0)
		ELSE
			PY=CALCFUNC(PX,CFUNC(N1))*CALCFUNC(PX,CFUNC(N2))
 			PY=QABS(PY*(PX)**2.Q0)
		END IF
		
		IF (P(INCREMENT+1).Y>PY) THEN
			IF (P(INCREMENT+1).Y>CERO) THEN
				A0=QLOG(P(INCREMENT+1).Y/PY)/FINR
			ELSE
				A0=0.Q0
			ENDIF
		ELSE
			CONT=CONT+1
			IF (CONT<=100) THEN
				GOTO 10
			ELSE 
				!WRITE(*,*)'LA FUNCION ES SIEMPRE CRECIENTE Y SE HA TOMADO COMO EXPONENTE DE LA EXPONENCIAL A0=0.5'
				A0=0.5Q0
			ENDIF
		ENDIF
	ENDIF
! ------calculo del area de cada trapecio -----------------------------
    DO I=1,INCREMENT
		STR(I)=(P(I).Y+P(I+1).Y)*(P(I+1).X-P(I).X)/2.Q0
    END DO

! ---calculo del area de todos los trapecios --------------------------
    ARP=0.Q0
    
	DO I=1,INCREMENT
		ARP=ARP+STR(I)
	END	DO
	IF(RECORT==1.OR.RECORT==2)THEN	
		A0=0.Q0
		ARE=0.Q0
	ELSE IF(RECORT==0)THEN
		IF (A0/=0.Q0)THEN	!   CALCULA EL AREA DE LA EXPONENCIAL
			ARE=P(INCREMENT+1).Y/A0
			CEXP=P(INCREMENT+1).Y*QEXP(A0*P(INCREMENT+1).X)
			!IF(P(INCREMENT+1).Y<CERO)THEN
			!	ARE=1.Q0
			!	C=A0
			!ENDIF
		ELSE
			ARE=0.Q0
		ENDIF
	ENDIF

!   CALCULA EL AREA TOTAL
	ATOT=ARP+ARE	
    
	END

!******************************************************************
!  SUBPROGRAMA PARA CALCULAR LOS VERTICES DE LA POLIGONAL PARA ANGULOS
!  AREA DE CADA TRAPECIO (STR) Y AREA TOTAL DE LA POLIGONAL(ARP)
!******************************************************************
    SUBROUTINE POLI_ANG(N1,N2,ARP,P,STR,CLASE,C1,C2,PC)
	USE GLOBAL
	USE ESTRUCT
    IMPLICIT NONE
	INTEGER*4 N1,N2,I,J,K
	REAL*16 ARP
	TYPE(XY)::P(1:INCREMENT+1)
	REAL*16 STR(INCREMENT)
	REAL*16 CALCFUNC,FACTANG_CST,FACTANG_FI
	TYPE(RCSTFI)::POLIPOLAR,POLIPOLAR1,POLIPOLAR2
	TYPE(XYZ)::C1,C2,PC,POLICAR,POLICAR1,POLICAR2
	REAL*16 ANGULOT,ANGULOF,RADIO
	CHARACTER*1 CLASE !'T'=COSENO DE THETA, 'F'= ANGULO FI
	
	IF (CLASE=='T')THEN
		INIA=-1.Q0
		FINA=1.Q0
	ELSEIF (CLASE=='F')THEN
		INIA=0.Q0
		FINA=2*PI
	END IF
	!INIA=0.Q0
	!FINA=1.Q0

	DO I=1,INCREMENT+1
		P(I).X=INIA+DBLE(I-1)*(FINA-INIA)/DBLE(INCREMENT)
		P(I).Y=0.Q0
				
		IF (CLASE=='T')THEN
			POLIPOLAR.CST=P(I).X  !coordenas para la poligonal
			DO J=1,20
				RADIO=DFLOAT(J)/5.Q0
				POLIPOLAR.R=RADIO
			
				DO K=0,23
					ANGULOF=K*PI/4.Q0
					POLIPOLAR.FI=ANGULOF
					
					! ---  PASO A CARTESIANAS
					CALL POLAR2CAR(POLIPOLAR,POLICAR)
								
					!--CALCULO EN CARTESIANAS DE LOS PUNTOS DE LA POLIGONAL RESPECTO A CADA CENTRO
					POLICAR1.X=POLICAR.X+(PC.X-C1.X)
					POLICAR1.Y=POLICAR.Y+(PC.Y-C1.Y)
					POLICAR1.Z=POLICAR.Z+(PC.Z-C1.Z)
					POLICAR2.X=POLICAR.X+(PC.X-C2.X)
					POLICAR2.Y=POLICAR.Y+(PC.Y-C2.Y)
					POLICAR2.Z=POLICAR.Z+(PC.Z-C2.Z)							
				
					!PASO A POLARES 
					CALL CAR2POLAR(POLICAR1,POLIPOLAR1)
					CALL CAR2POLAR(POLICAR2,POLIPOLAR2)

					P(I).Y=QABS(FACTANG_CST(FB(N1).NTF,POLIPOLAR1.CST)*FACTANG_CST(FB(N2).NTF,POLIPOLAR2.CST))
		
				ENDDO
			ENDDO
		ELSEIF (CLASE=='F')THEN
			POLIPOLAR.FI=P(I).X  !coordenas para la poligonal
			DO J=1,20
				RADIO=DFLOAT(J)/5.Q0
				POLIPOLAR.R=RADIO
			
				DO K=1,20
					ANGULOT=-1.Q0+DFLOAT(K)/10.Q0
					POLIPOLAR.CST=ANGULOT
					
					! ---  PASO A CARTESIANAS
					CALL POLAR2CAR(POLIPOLAR,POLICAR)
								
					!--CALCULO EN CARTESIANAS DE LOS PUNTOS DE LA POLIGONAL RESPECTO A CADA CENTRO
					POLICAR1.X=POLICAR.X+(PC.X-C1.X)
					POLICAR1.Y=POLICAR.Y+(PC.Y-C1.Y)
					POLICAR1.Z=POLICAR.Z+(PC.Z-C1.Z)
					POLICAR2.X=POLICAR.X+(PC.X-C2.X)
					POLICAR2.Y=POLICAR.Y+(PC.Y-C2.Y)
					POLICAR2.Z=POLICAR.Z+(PC.Z-C2.Z)							
				
					!PASO A POLARES 
					CALL CAR2POLAR(POLICAR1,POLIPOLAR1)
					CALL CAR2POLAR(POLICAR2,POLIPOLAR2)
	
					P(I).Y=QABS(FACTANG_FI(FB(N1).NTF,POLIPOLAR1.FI)*FACTANG_FI(FB(N2).NTF,POLIPOLAR2.FI))
				ENDDO
			ENDDO
		END IF	
	END DO
! ------calculo del area de cada trapecio -----------------------------
    DO I=1,INCREMENT
		STR(I)=(P(I).Y+P(I+1).Y)*(P(I+1).X-P(I).X)/2.Q0
    END DO

! ---calculo del area de todos los trapecios --------------------------
    ARP=0.Q0
    DO I=1,INCREMENT
		ARP=ARP+STR(I)
    END DO

    END


!--------------------------------------------------------------------
!	SUBRUTINA QUE DADO EL VALOR DE LA FUNCION GENERADO ALEATORIAMENTE
!	NOS DICE EN QUE TRAPECIO DENTRO DE LA POLIGONAL SE ENCUENTRA
!--------------------------------------------------------------------
	SUBROUTINE BUSCA_TRAPECIO(AREATOT,RN,P,STR,ALEA,FDEN)
	USE GLOBAL,ONLY:INCREMENT
	USE ESTRUCT,ONLY:XY
    IMPLICIT NONE
    TYPE(XY)P(1:INCREMENT+1)
	REAL*16 STR(INCREMENT)
	INTEGER*4 IELEG,I1
	REAL*16 AREATOT,ALEA,FDEN,RN,BUTRA
	REAL*16 PEN,TERIND,AA,BB,CC,RAIZ

    IELEG=0

	BUTRA=RN*AREATOT
	I1=1
10	BUTRA=BUTRA-STR(I1)
	IF(BUTRA<0)THEN
		IELEG=I1
		BUTRA=QABS(BUTRA)
	ELSE
	    I1=I1+1
	    GOTO 10
	END IF
	PEN=(P(IELEG+1).Y-P(IELEG).Y)/(P(IELEG+1).X-P(IELEG).X)
	IF(PEN/=0.Q0)THEN
		TERIND=P(IELEG).Y-PEN*P(IELEG).X
		AA=PEN
		BB=2*TERIND
		CC=2*BUTRA-TERIND*P(IELEG+1).X-P(IELEG+1).Y*P(IELEG+1).X
		RAIZ=QSQRT(BB**2.Q0-4.Q0*AA*CC)
		ALEA=(-BB-RAIZ)/(2.Q0*AA)
		
		IF(ALEA<P(IELEG).X.OR.ALEA>P(IELEG+1).X)THEN
			ALEA=(-BB+RAIZ)/(2.Q0*AA)
		ENDIF
	ELSE
		TERIND=P(IELEG).Y
		!ALEA=(2.Q0*BUTRA-P(IELEG+1).X*(TERIND+P(IELEG+1).Y))/2.Q0*TERIND
		ALEA=P(IELEG+1).X-(BUTRA/TERIND)
	ENDIF
	FDEN=(PEN*ALEA+TERIND)

	END

!--------------------------------------------------------------------
!	SUBROUTINE QUE DEVUELVE EL NUMERO GENERADO ALEATORIAMENTE CON EL 
!	TIPO DE MONTECARLO ELEGIDO
!--------------------------------------------------------------------
	SUBROUTINE GENERA_MONTECARLO(MET,CMON,IISEM,IMAL,ALEA,RN)
	USE GLOBAL,ONLY:CERO
	USE ESTRUCT,ONLY:DAT_METODO
    IMPLICIT NONE
    TYPE(DAT_METODO)::MET
	INTEGER*4 IMAL,IISEM
	REAL*16 RN,ALEA
	CHARACTER*3 CMON


!    IF(CMON=='HAS')THEN
!10		CALL HAS(MET.RAIZ,MET.DNUMERO,RN)
!		IF(RN<=CERO)THEN
!			IMAL=IMAL+1
!			GOTO 10
!		END IF
!    END IF
!    IF(CMON=='HAL')THEN
!20		CALL HALTON(MET.NUM,MET.NR1,MET.NR2,RN)
!		IF(RN<=CERO)THEN
!			IMAL=IMAL+1
!			GOTO 20
!		END IF
!     END IF
!	IF(CMON=='HAM')THEN
!		RN=ALEA		
!    END IF
	IF(CMON=='RND')THEN
30      RN=RAN(IISEM)
		IF(RN<=CERO)THEN
			IMAL=IMAL+1
			GOTO 30
		END IF
    END IF
	END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL OPERADOR  T
! ---   APLICADO A UNA FUNCION DE BASE EN UN PUNTO "RR".
! -------------------------------------------------------------
    REAL*16 FUNCTION TRBASE(NB,POL)
	USE GLOBAL
	USE ESTRUCT
	IMPLICIT NONE
	TYPE(RCSTFI)::POL
    INTEGER*4 NB,L
    REAL*16 PRIMERAD,SEGUNDAD,CALCFUNC
	
    L=0
    IF(FB(NB).NTF>=1)L=1
    IF(FB(NB).NTF>=4)L=2
    IF(FB(NB).NTF>=9)L=3
    	
	!R1=POL.R+DELTA
	!R2=POL.R-DELTA
	!PRIMERAD=DERIVAR(NB,POL.R)
	!SEGUNDAD=(DERIVAR(NB,R1)-DERIVAR(NB,R2))/(2.Q0*DELTA)
	
	CALL DERIVAR2(NB,POL.R,PRIMERAD,SEGUNDAD)

    !CALL RICHARDR(NB,POL.R,DELTA,1,1,PRIMERAD)
	!CALL RICHARDR(NB,POL.R,DELTA,1,2,SEGUNDAD)
	TRBASE=SEGUNDAD+PRIMERAD*2.Q0/POL.R
    TRBASE=TRBASE-DFLOAT(L*(L+1))*CALCFUNC(POL.R,CFUNC(NB))/POL.R**2
    TRBASE=-0.5Q0*TRBASE

	RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DE LA DERIVADA RESPECTO A R
! ---   DE UNA FUNCION DE BASE EN UN PUNTO "RR".
! -------------------------------------------------------------
    SUBROUTINE DERIVAR2(NB,RR,DT1,DT2)
	USE GLOBAL
	USE ESTRUCT
	IMPLICIT NONE
    INTEGER*4 NB
	REAL*16 RR,RR1,RR2,DT1,DT2,D1,D2,DFR1,DFR2,RRR
	REAL*16 F0,F1,F2,CALCFUNC,SIGMA
    REAL*16 DELTA
    
    DELTA=1.Q-6 
    
    RR1=RR+DELTA
	RR2=RR-DELTA
	
	IF (RECORT==0)THEN
		F0=CALCFUNC(RR,CFUNC(NB))
		F1=CALCFUNC(RR1,CFUNC(NB))
		F2=CALCFUNC(RR2,CFUNC(NB))
		DT1=(F1-F2)/(2.Q0*DELTA)
		DT2=(F1+F2-2.Q0*F0)/DELTA**2
	ELSEIF (RECORT==1) THEN
		RECORT=0  !ESTO SE HACE PARA QUE NO MULTIPLIQUE POR LA F. SIGMA
		IF (RR1>FB(NB).RECOR.R0) THEN
			F1=-CALCFUNC(RR2,CFUNC(NB)) !EXTRAPOLACIÓN POR REFLEXIÓN DEL PUNTO ANTERIOR
		ELSE
			F1=CALCFUNC(RR1,CFUNC(NB))
		ENDIF
		F0=CALCFUNC(RR,CFUNC(NB))
		F2=CALCFUNC(RR2,CFUNC(NB))
		RECORT=1	!SE VUELVE A PONER COMO ESTABA
		D1=(F1-F2)/(2.Q0*DELTA)
		D2=(F1+F2-2.Q0*F0)/DELTA**2
		DFR1=0.Q0
		DFR2=0.Q0
		IF(FB(NB).RECOR.TIPORECORT==0)THEN
			IF (RR<FB(NB).RECOR.R1.AND.RR>FB(NB).RECOR.R1-FB(NB).RECOR.D1) THEN
				RRR=RR-FB(NB).RECOR.R1
				DFR1=FB(NB).RECOR.COEF(1)+2.Q0*FB(NB).RECOR.COEF(2)*RRR+3.Q0*FB(NB).RECOR.COEF(3)*RRR*RRR
				DFR2=2.Q0*FB(NB).RECOR.COEF(2)+6.Q0*FB(NB).RECOR.COEF(3)*RRR
			ENDIF
		ELSEIF(FB(NB).RECOR.TIPORECORT==1)THEN
			IF (RR>FB(NB).RECOR.R0.AND.RR<FB(NB).RECOR.R0+FB(NB).RECOR.D0) THEN
				RRR=RR-FB(NB).RECOR.R0
				DFR1=FB(NB).RECOR.COEF(1)+2.Q0*FB(NB).RECOR.COEF(2)*RRR+3.Q0*FB(NB).RECOR.COEF(3)*RRR*RRR
				DFR2=2.Q0*FB(NB).RECOR.COEF(2)+6.Q0*FB(NB).RECOR.COEF(3)*RRR
			ENDIF
		ELSEIF(FB(NB).RECOR.TIPORECORT==2)THEN
			IF (RR>FB(NB).RECOR.R0.AND.RR<FB(NB).RECOR.R0+FB(NB).RECOR.D0) THEN
				RRR=RR-FB(NB).RECOR.R0
				DFR1=FB(NB).RECOR.COEF(1)+2.Q0*FB(NB).RECOR.COEF(2)*RRR+3.Q0*FB(NB).RECOR.COEF(3)*RRR*RRR
				DFR2=2.Q0*FB(NB).RECOR.COEF(2)+6.Q0*FB(NB).RECOR.COEF(3)*RRR
			ELSEIF (RR<FB(NB).RECOR.R1.AND.RR>FB(NB).RECOR.R1-FB(NB).RECOR.D1) THEN
				RRR=RR-FB(NB).RECOR.R1
				DFR1=FB(NB).RECOR.COEF(4)+2.Q0*FB(NB).RECOR.COEF(5)*RRR+3.Q0*FB(NB).RECOR.COEF(6)*RRR*RRR
				DFR2=2.Q0*FB(NB).RECOR.COEF(5)+6.Q0*FB(NB).RECOR.COEF(6)*RRR
			ENDIF
		ENDIF
		DT1=SIGMA(NB,RR)*D1+F0*DFR1
		DT2=SIGMA(NB,RR)*D2+F0*DFR2+2.Q0*D1*DFR1
	ELSEIF (RECORT==2) THEN
		RECORT=0	!ESTO SE HACE PARA QUE NO MULTIPLIQUE POR LA F. SIGMA
		IF (RR1>FB(NB).RECOR.R0) THEN
			F1=-CALCFUNC(RR2,CFUNC(NB)) !EXTRAPOLACIÓN POR REFLEXIÓN DEL PUNTO ANTERIOR
		ELSE
			F1=CALCFUNC(RR1,CFUNC(NB))
		ENDIF
		F0=CALCFUNC(RR,CFUNC(NB))
		F2=CALCFUNC(RR2,CFUNC(NB))
		RECORT=2	!SE VUELVE A PONER COMO ESTABA
		D1=(F1-F2)/(2.Q0*DELTA)
		D2=(F1+F2-2.Q0*F0)/DELTA**2
		DFR1=0.Q0
		DFR2=0.Q0
		IF(FB(NB).RECOR.TIPORECORT==0)THEN
			IF (RR<FB(NB).RECOR.R1.AND.RR>FB(NB).RECOR.R1-FB(NB).RECOR.D1) THEN
				RRR=RR-FB(NB).RECOR.R1
				DFR1=3.Q0*FB(NB).RECOR.COEF(1)*RRR*RRR+4.Q0*FB(NB).RECOR.COEF(2)*RRR*RRR*RRR+5.Q0*FB(NB).RECOR.COEF(3)*RRR*RRR*RRR*RRR
				DFR2=6.Q0*FB(NB).RECOR.COEF(1)*RRR+12.Q0*FB(NB).RECOR.COEF(2)*RRR*RRR+20.Q0*FB(NB).RECOR.COEF(3)*RRR*RRR*RRR
			ENDIF
		ELSEIF(FB(NB).RECOR.TIPORECORT==1)THEN
			IF (RR>FB(NB).RECOR.R0.AND.RR<FB(NB).RECOR.R0+FB(NB).RECOR.D0) THEN
				RRR=RR-FB(NB).RECOR.R0
				DFR1=3.Q0*FB(NB).RECOR.COEF(1)*RRR*RRR+4.Q0*FB(NB).RECOR.COEF(2)*RRR*RRR*RRR+5.Q0*FB(NB).RECOR.COEF(3)*RRR*RRR*RRR*RRR
				DFR2=6.Q0*FB(NB).RECOR.COEF(1)*RRR+12.Q0*FB(NB).RECOR.COEF(2)*RRR*RRR+20.Q0*FB(NB).RECOR.COEF(3)*RRR*RRR*RRR
			ENDIF
		ELSEIF(FB(NB).RECOR.TIPORECORT==2)THEN
			IF (RR>FB(NB).RECOR.R0.AND.RR<FB(NB).RECOR.R0+FB(NB).RECOR.D0) THEN
				RRR=RR-FB(NB).RECOR.R0
				DFR1=3.Q0*FB(NB).RECOR.COEF(1)*RRR*RRR+4.Q0*FB(NB).RECOR.COEF(2)*RRR*RRR*RRR+5.Q0*FB(NB).RECOR.COEF(3)*RRR*RRR*RRR*RRR
				DFR2=6.Q0*FB(NB).RECOR.COEF(1)*RRR+12.Q0*FB(NB).RECOR.COEF(2)*RRR*RRR+20.Q0*FB(NB).RECOR.COEF(3)*RRR*RRR*RRR
			ELSEIF (RR<FB(NB).RECOR.R1.AND.RR>FB(NB).RECOR.R1-FB(NB).RECOR.D1) THEN
				RRR=RR-FB(NB).RECOR.R1
				DFR1=3.Q0*FB(NB).RECOR.COEF(4)*RRR*RRR+4.Q0*FB(NB).RECOR.COEF(5)*RRR*RRR*RRR+5.Q0*FB(NB).RECOR.COEF(6)*RRR*RRR*RRR*RRR
				DFR2=6.Q0*FB(NB).RECOR.COEF(4)*RRR+12.Q0*FB(NB).RECOR.COEF(5)*RRR*RRR+20.Q0*FB(NB).RECOR.COEF(6)*RRR*RRR*RRR
			ENDIF
		ENDIF
		DT1=SIGMA(NB,RR)*D1+F0*DFR1
		DT2=SIGMA(NB,RR)*D2+F0*DFR2+2.Q0*D1*DFR1
	ENDIF

    RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DE LA DERIVADA RESPECTO A R
! ---   DE UNA FUNCION DE BASE EN UN PUNTO "RR".
! -------------------------------------------------------------
    REAL*16 FUNCTION DERIVAR(NB,RR)
	USE GLOBAL
	USE ESTRUCT
	IMPLICIT NONE
    INTEGER*4 NB
    REAL*16 RR,RR1,RR2,F1,F2,CALCFUNC
    REAL*16 DELTA
    
    DELTA=1.Q-6 
		
    RR1=RR+DELTA
	RR2=RR-DELTA
	
	F1=CALCFUNC(RR1,CFUNC(NB))
	F2=CALCFUNC(RR2,CFUNC(NB))
    DERIVAR=(F1-F2)/(2.Q0*DELTA)

    RETURN
    END

! ----------------------------------------------------------------------
!     CALCULA LA DERIVADA DE UNA FUNCION F(X)
!     POR APROXIMACION PARABOLICA Y EXTRAPOLACION DE RICHARDSON 
! --------------------------------------------------------------------- 
    RECURSIVE SUBROUTINE RICHARDR(NB,RR,H,NPASOS,ORDEN,RES)
	USE ESTRUCT
    IMPLICIT NONE
    REAL*16 H,H2,HH,DERIVA,A,R1,R2,RES,DR1,DR2,RR,RR1,RR2,DERIVAR
    INTEGER*4 NPASOS,I,NB,ORDEN

	IF (ORDEN==1) THEN
		A=1.Q0
		IF(NPASOS==0)THEN
			RES=DERIVAR(NB,RR)
			RETURN
		ENDIF

		DO I=1,NPASOS		
			A=4.Q0*A
			CALL RICHARDR(NB,RR,H,I-1,ORDEN,R1)
			H2=0.5Q0*H
			CALL RICHARDR(NB,RR,H2,I-1,ORDEN,R2)
			RES=(A*R2-R1)/(A-1.Q0)  
		ENDDO
	ELSEIF (ORDEN==2) THEN
		HH=H*10.Q0
		RR1=RR+HH
		CALL RICHARDR(NB,RR1,H,NPASOS,ORDEN-1,R1)
		RR2=RR-HH
		CALL RICHARDR(NB,RR2,H,NPASOS,ORDEN-1,R2)
		DR1=(R1-R2)/(2.Q0*HH)
		RR1=RR+HH/2.Q0
		CALL RICHARDR(NB,RR1,H,NPASOS,ORDEN-1,R1)
		RR2=RR-HH/2.Q0
		CALL RICHARDR(NB,RR2,H,NPASOS,ORDEN-1,R2)
		DR2=(R1-R2)/HH
		RES=(4.Q0*DR2-DR1)/3.Q0
	ENDIF
	   
	RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL OPERADOR  H
! ---   APLICADO A UNA FUNCION DE BASE EN UN PUNTO "R,TETA,FI".
! ---   (CST ES EL COSENO DE TETA)
! -------------------------------------------------------------
    REAL*16 FUNCTION HRBASE(NB,POL,CENT)
	USE ESTRUCT
	!USE GLOBAL
    IMPLICIT NONE
    TYPE(RCSTFI)::POL
	TYPE(XYZ)::CENT
    INTEGER*4 NB
    REAL*16 TRBASE,VRBASE

    HRBASE=TRBASE(NB,POL)+VRBASE(NB,POL,CENT)

    RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL PRODUCTO
! ---   "V" POR UNA FUNCION DE BASE.
! ---   (CST ES EL COSENO DE TETA)
! ---    EL PUNTO (R,CST,FI) ENTRA YA DEFINIDO RESPECTO AL
! ---    ORIGEN DE LA FUNCION DE BASE IMPLICADA,  PERO LAS
! ---    COORDENADAS NUCLEARES (entran respecto al origen)
! ---    SON TRASLADADAS POR EL SUBPROGRAMA.
! -------------------------------------------------------------
	REAL*16 FUNCTION VRBASE(NB,POL,CENT)
	USE ESTRUCT
	USE GLOBAL
	IMPLICIT NONE
    TYPE(RCSTFI)::POL
	TYPE(XYZ)::P,CENT,PP0
    INTEGER*4 NB,K
    REAL*16 VBASE,CALCFUNC
	  
	!CALL POLAR2CAR(POL,P)
	
    VRBASE=0.Q0
! --- CALCULO DE LAS COORDENADAS DE CADA NUCLEO RESPECTO AL 
! --- CENTRO DE LA SEGUNDA FUNCION DE BASE:
	IF(NUC==0)RETURN
    DO K=1,NUC
	!	PP0.X=NUCLEOS(K).X-CENT.X
	!	PP0.Y=NUCLEOS(K).Y-CENT.Y	!CENT ES EL CENTRO DE LA 2º FUNCION DE BASE
	!	PP0.Z=NUCLEOS(K).Z-CENT.Z	
	!	X0=P.X-PP0.X
	!	Y0=P.Y-PP0.Y
	!	Z0=P.Z-PP0.Z 
	!	R0=QSQRT(X0*X0+Y0*Y0+Z0*Z0)   
	!	IF(R0<CERO)R0=CERO
	!	VRBASE=VRBASE-NUCLEOS(K).CARGA/R0
		VRBASE=VRBASE-NUCLEOS(K).CARGA/POL.R
	END DO

    VRBASE=VRBASE*CALCFUNC(POL.R,CFUNC(NB))

    RETURN
    END

! -------------------------------------------------------------
! ---   SUBPROGRAMA PARA EL CALCULO DEL VALOR DEL PRODUCTO
! ---   "X**Nx * Y**Ny * Z**Nz" POR UNA FUNCION DE BASE.
! ---   (CST ES EL COSENO DE TETA)
! ---    EL PUNTO (R,CST,FI) ENTRA YA DEFINIDO RESPECTO AL
! ---    ORIGEN DE LA FUNCION DE BASE IMPLICADA,  PERO LAS
! ---    COORDENADAS NUCLEARES TIENEN QUE SER TRASLADADAS.
! -------------------------------------------------------------
    REAL*16 FUNCTION XRBASE(NB,POL,P)
    USE ESTRUCT
	USE GLOBAL
	IMPLICIT NONE
	TYPE(XYZ)::P
    TYPE(RCSTFI)::POL   
    INTEGER*4 NB
    REAL*16 CALCFUNC
	    
	!CALL POLAR2CAR(POL,P)

	!RR=(P.X-P0.X)**2+(P.Y-P0.Y)**2+(P.Z-P0.Z)**2
	!XRBASE=RR**(NN.NX+NN.NY+NN.NZ)
	XRBASE=(P.X-P0.X)**NN.NX*(P.Y-P0.Y)**NN.NY*(P.Z-P0.Z)**NN.NZ
    XRBASE=XRBASE*CALCFUNC(POL.R,CFUNC(NB))

    RETURN
    END